{"db":[{"meta":{"exported_on":1452525686702,"version":"004"},"data":{"app_fields":[],"app_settings":[],"apps":[],"client_trusted_domains":[],"permissions":[{"id":1,"uuid":"5ca3fca8-8693-4008-a8f5-6e0d5faffec4","name":"Export database","object_type":"db","action_type":"exportContent","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":2,"uuid":"aea8da83-4bf2-4593-8494-32ec371a7bba","name":"Import database","object_type":"db","action_type":"importContent","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":3,"uuid":"28a8dde6-668f-4c86-b10f-a99997f47fd5","name":"Delete all content","object_type":"db","action_type":"deleteAllContent","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":4,"uuid":"18777053-82b6-4ec0-b446-1137e2ca47e2","name":"Send mail","object_type":"mail","action_type":"send","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":5,"uuid":"c986d00a-af82-4655-b571-d161dad81b62","name":"Browse notifications","object_type":"notification","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":6,"uuid":"c359d160-00cf-4428-a219-13201cf426b3","name":"Add notifications","object_type":"notification","action_type":"add","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":7,"uuid":"40da3006-dae9-4c5d-b9d9-de18fc3f2230","name":"Delete notifications","object_type":"notification","action_type":"destroy","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":8,"uuid":"e5786f6a-05ca-4cea-bfb0-ea0bb2075f9f","name":"Browse posts","object_type":"post","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":9,"uuid":"6e2b543f-75b4-4f59-b174-baef304aaeca","name":"Read posts","object_type":"post","action_type":"read","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":10,"uuid":"9d932cf0-730d-4ffa-9623-ac72dc25f356","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":11,"uuid":"45bfd5dd-a818-43a2-b364-21e953cb87a2","name":"Add posts","object_type":"post","action_type":"add","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":12,"uuid":"0d16b514-eda9-4f03-bf32-2c054cc465d1","name":"Delete posts","object_type":"post","action_type":"destroy","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":13,"uuid":"e7431cfb-2b8c-460a-a51c-9b9224061301","name":"Browse settings","object_type":"setting","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":14,"uuid":"f34068ca-3c3b-4c70-9994-d35a1f92de1b","name":"Read settings","object_type":"setting","action_type":"read","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":15,"uuid":"80d638e1-ed0c-4cde-b5d6-87d42297001d","name":"Edit settings","object_type":"setting","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":16,"uuid":"934d33cd-7272-4e69-aa58-0eea09e47b18","name":"Generate slugs","object_type":"slug","action_type":"generate","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":17,"uuid":"76a5f527-08be-488e-9e4e-4c7a00ca827c","name":"Browse tags","object_type":"tag","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":18,"uuid":"8e8e49b2-e2dd-495d-9cb2-ded271c22367","name":"Read tags","object_type":"tag","action_type":"read","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":19,"uuid":"ec1816dc-47de-44e1-880d-ea5ab667a65d","name":"Edit tags","object_type":"tag","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":20,"uuid":"729db729-7736-453e-bac3-eaca1eea994f","name":"Add tags","object_type":"tag","action_type":"add","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":21,"uuid":"6828f3ef-840e-4582-89ef-c2ef152b3de7","name":"Delete tags","object_type":"tag","action_type":"destroy","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":22,"uuid":"74c272ee-fcfd-4265-9851-61b1c3fc7cad","name":"Browse themes","object_type":"theme","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":23,"uuid":"5a529ed7-7fb5-4b66-8097-a7820800b480","name":"Edit themes","object_type":"theme","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":24,"uuid":"ae1030a2-6237-4220-8f28-9b8325cc17d5","name":"Browse users","object_type":"user","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":25,"uuid":"3262073c-7691-42c7-b0dc-f88d2332e53e","name":"Read users","object_type":"user","action_type":"read","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":26,"uuid":"d8bc98f0-1519-437f-af7b-d5387bbfb689","name":"Edit users","object_type":"user","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":27,"uuid":"91c7c0cc-484e-4541-9b4c-ca2f56b7c74b","name":"Add users","object_type":"user","action_type":"add","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":28,"uuid":"34fdfa25-bf81-4af8-92d2-c75a78ae75d7","name":"Delete users","object_type":"user","action_type":"destroy","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":29,"uuid":"b845a56f-c996-4e8f-858f-0f52c13836f3","name":"Assign a role","object_type":"role","action_type":"assign","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":30,"uuid":"5d0c7f66-29c2-41cb-a49d-8ccd0a30ae58","name":"Browse roles","object_type":"role","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1}],"permissions_apps":[],"permissions_roles":[{"id":1,"role_id":1,"permission_id":1},{"id":2,"role_id":1,"permission_id":2},{"id":3,"role_id":1,"permission_id":3},{"id":4,"role_id":1,"permission_id":4},{"id":5,"role_id":1,"permission_id":5},{"id":6,"role_id":1,"permission_id":6},{"id":7,"role_id":1,"permission_id":7},{"id":8,"role_id":1,"permission_id":8},{"id":9,"role_id":1,"permission_id":9},{"id":10,"role_id":1,"permission_id":10},{"id":11,"role_id":1,"permission_id":11},{"id":12,"role_id":1,"permission_id":12},{"id":13,"role_id":1,"permission_id":13},{"id":14,"role_id":1,"permission_id":14},{"id":15,"role_id":1,"permission_id":15},{"id":16,"role_id":1,"permission_id":16},{"id":17,"role_id":1,"permission_id":17},{"id":18,"role_id":1,"permission_id":18},{"id":19,"role_id":1,"permission_id":19},{"id":20,"role_id":1,"permission_id":20},{"id":21,"role_id":1,"permission_id":21},{"id":22,"role_id":1,"permission_id":22},{"id":23,"role_id":1,"permission_id":23},{"id":24,"role_id":1,"permission_id":24},{"id":25,"role_id":1,"permission_id":25},{"id":26,"role_id":1,"permission_id":26},{"id":27,"role_id":1,"permission_id":27},{"id":28,"role_id":1,"permission_id":28},{"id":29,"role_id":1,"permission_id":29},{"id":30,"role_id":1,"permission_id":30},{"id":31,"role_id":2,"permission_id":8},{"id":32,"role_id":2,"permission_id":9},{"id":33,"role_id":2,"permission_id":10},{"id":34,"role_id":2,"permission_id":11},{"id":35,"role_id":2,"permission_id":12},{"id":36,"role_id":2,"permission_id":13},{"id":37,"role_id":2,"permission_id":14},{"id":38,"role_id":2,"permission_id":16},{"id":39,"role_id":2,"permission_id":17},{"id":40,"role_id":2,"permission_id":18},{"id":41,"role_id":2,"permission_id":19},{"id":42,"role_id":2,"permission_id":20},{"id":43,"role_id":2,"permission_id":21},{"id":44,"role_id":2,"permission_id":24},{"id":45,"role_id":2,"permission_id":25},{"id":46,"role_id":2,"permission_id":26},{"id":47,"role_id":2,"permission_id":27},{"id":48,"role_id":2,"permission_id":28},{"id":49,"role_id":2,"permission_id":29},{"id":50,"role_id":2,"permission_id":30},{"id":51,"role_id":3,"permission_id":8},{"id":52,"role_id":3,"permission_id":9},{"id":53,"role_id":3,"permission_id":11},{"id":54,"role_id":3,"permission_id":13},{"id":55,"role_id":3,"permission_id":14},{"id":56,"role_id":3,"permission_id":16},{"id":57,"role_id":3,"permission_id":17},{"id":58,"role_id":3,"permission_id":18},{"id":59,"role_id":3,"permission_id":20},{"id":60,"role_id":3,"permission_id":24},{"id":61,"role_id":3,"permission_id":25},{"id":62,"role_id":3,"permission_id":30}],"permissions_users":[],"posts":[{"id":3,"uuid":"27e88a8f-a60c-4161-8b53-2712da8e25d3","title":"UIView的生命周期总结","slug":"uiviewlifetime","markdown":"# 序言:\n\n1. `loadView`、`viewDidLoad`、`viewDidAppear`、<font color = \"rgb(226,238,250)\">`initWithNibName`</font>、<font color = \"rgb(226,238,250)\">`awakeFromNib`</font>等经常出现在UIViewController中的方法介绍。\n2. 这些方法分别用来作哪些工作，换言之，创建自定义的View时代码放到以上哪个方法中。\n3. 一个UIView的生命周期是怎样的。以上几个方法的调用顺序如何。\n4. 通过IB和代码加载视图，有什么区别\n\n**文章主要参考官方和文档和StackOVerFlow有关问题整理得出，由于水平有限，如有错误之处请及时与我联系。**\n\n# UIViewController\n#####视图层次和根视图\n\n每个视图控制器都维护一个<font color=red>**视图层次(view hierarchy)**</font>。\n\n因为每个视图都有自己的**子视图**，这个**视图层次**其实也可以理解为一棵树状的数据结构。而树的根节点，也就是根视图(root view)，在UIViewController中以<font color = \"rgb(226,238,250)\">`view`</font>属性。它可以被看做是其他所有子视图的容器。\n\n\n##### 视图的加载方式\n\nUIViewController采用懒加载的方式，也就是说第一次访问到<font color = \"rgb(226,238,250)\">`view`</font>属性时才会加载或创建它。由于视图由视图控制器管理，所以讨论视图的加载方式时，主要讨论视图控制器的加载方式。\n\n* 通过Storyboard加载：这是苹果推荐的方式，也是未来的趋势。\t\t\t\n\t\n\t 通过这种方式创建<font color = \"rgb(226,238,250)\">`UIViewController `</font>对象的话，首先生成<font color = \"rgb(226,238,250)\">`UIStoryboard`</font>类型的对象，然后调用这个对象的<font color = \"rgb(226,238,250)\">`instantiateViewControllerWithIdentifier: `</font>方法\n\n* 通过Nib文件加载：\n\n\tNib文件其实就是xib文件，Storyboard相当于是聚合了多个nib文件，并且添加了对不同的<font color = \"rgb(226,238,250)\">`UIViewController `</font>之间的segue和relationship的管理。但总的实现原理非常类似\n\t\n\t通过这种方式加载视图,需要调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>类的<font color = \"rgb(226,238,250)\">`initWithNibName:bundle:  `</font>方法\n* 通过loadview方法加载：\n\n\t这就是通过代码加载。这需要我们在<font color = \"rgb(226,238,250)\">`loadView`</font>\t方法中，通过编程创建自己的**视图层次**，并且把把根视图赋值给<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`view `</font>属性。\n\t\n因此，通过代码自定义View的时候，<font color = \"rgb(226,238,250)\">`loadView`</font>\t方法大概是这样的：\n\t\n```Objective-C\n- (void)loadView{\n\tself.view = [[XXXView alloc] init];\n}\n```\n\n\n###处理视图相关通知\n\n当视图的可见性发生变化时，视图控制器会自动调用一系列方法来响应变化。\n\n所有可能的状态、方法和状态之间的转换关系在下图中被明确标出。\n\n![](http://7xonij.com1.z0.glb.clouddn.com/UIViewLifeCircle/StateTransitionspng.png)\n\n可以看到每一个will方法都有自己对应的did方法。但是如果我们在will方法中开始一个任务，不仅要在对应的did方法中结束它，还要考虑到和这个will方法相反的那个will方法（注意到Appearing和Disappearing这两个状态是可以互相转化的）\n\n\n#在运行时展示View\n\nUIKit极大的简化了加载和展示View的过程，它大概会按照以下顺序执行一些任务：\n\n1. 通过storyboard文件中的信息实例化视图\n2. 连接outlet和action\n3. 把根视图赋值给<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`view `</font>属性（其实就是调用<font color = \"rgb(226,238,250)\">`loadView`</font>\t方法）\n4. 调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法。要注意，在调用方法前，</font>的<font color = \"rgb(226,238,250)\">`trait collecion`</font>为空且子视图的位置可能不正确\n5. 调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`viewDidLoad `</font>方法。\n\n此时已经完成了视图的加载工作，在展示到屏幕之前，还有以下几个步骤：\n\n6. 调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`viewWillAppear `</font>方法。\n7. 更新视图的布局\n8. 把视图展示到屏幕上\n9. 调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`viewDidAppear `</font>方法。\n\n##### awakeFromNib方法\n\n至此，第一个问题已经几乎解释完了，还剩一个<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法。\n\n我们已经知道，<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法被调用时，所有视图的outlet和action已经连接，但还没有被确定。这个方法可以算作是和视图控制器的实例化配合在一起使用的，因为有些需要根据用户喜好来进行设置的内容，无法存在storyboard中，所以可以在<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法中被加载进来。\n\n<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法在视图控制器的生命周期内只会被调用一次。因为它和视图控制器从nib文件中的解档密切相关，和view的关系却不大。\n\n#具体方法的解释\n\n\n#####loadView方法\n\n当执行到<font color = \"rgb(226,238,250)\">`loadView `</font>方法时，视图控制器已经从nib文件中被解档并创建好了，接下来的任务主要是对view进行初始化。\n\n<font color = \"rgb(226,238,250)\">`loadView `</font>方法在<font color = \"rgb(226,238,250)\">`UIViewController `</font>对象的<font color = \"rgb(226,238,250)\">`view `</font>属性被访问到且为空的时候调用。\n这是它与<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法的一个区别。假设我们在处理内存警告时释放<font color = \"rgb(226,238,250)\">`view `</font>属性（其实并不应该这么做，这里举个例子）：<font color = \"rgb(226,238,250)\">`self.view = nil `</font>。因此<font color = \"rgb(226,238,250)\">`loadView `</font>方法在视图控制器的生命周期内可能会被多次调用。\n\n这个方法不应该被直接调用，而是由系统自动调用。它会加载或创建一个view并把它赋值给<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`view `</font>属性。\n\n在创建view的过程中，首先会根据<font color = \"rgb(226,238,250)\">`nibName `</font>去找对应的Nib文件然后加载。如果<font color = \"rgb(226,238,250)\">`nibName `</font>为空，或找不到对应的Nib文件，则会创建一个空视图(这种情况一般是纯代码，也就是为什么说代码构建View的时候，要重写<font color = \"rgb(226,238,250)\">`loadView`</font>\t方法)。\n\n注意在重写<font color = \"rgb(226,238,250)\">`loadView`</font>方法的时候，不要调用父类的方法。\n\n\n###viewDidLoad方法\n<font color = \"rgb(226,238,250)\">`loadView`</font>方法执行完之后，就会执行<font color = \"rgb(226,238,250)\">`viewDidLoad `</font>方法。此时整个**视图层次(view hierarchy)**已经被放到内存中。\n\n无论是从nib文件加载，还是通过纯代码编写界面，<font color = \"rgb(226,238,250)\">`viewDidLoad `</font>方法都会执行。我们可以重写这个方法，对通过nib文件加载的view做一些其他的初始化工作。比如可以移除一些视图，修改约束，加载数据等。\n\n\n##### viewWillAppear和viewDidAppear方法\n\n在视图加载完成，并即将显示在屏幕上时，会调用<font color = \"rgb(226,238,250)\">`viewWillAppear `</font>方法，在这个方法里，可以改变当前屏幕方向或状态栏的风格等。\n\n当<font color = \"rgb(226,238,250)\">`viewWillAppear `</font>方法执行完后，系统会执行<font color = \"rgb(226,238,250)\">`viewDidAppear `</font>方法。在这个方法中，还可以对视图做一些关于展示效果方面的修改。\n\n\n#视图的生命历程\n\n到目前为止，我们已经了解了每个方法的作用，接下来就把整个流程梳理一遍。\n\n1. <font color = \"rgb(226,238,250)\">`-[ViewController  initWithCoder:]`或`-[ViewController  initWithNibName:Bundle]`</font>:首先从归档文件中加载<font color = \"rgb(226,238,250)\">`UIViewController `</font>对象。即使是纯代码，也会把nil作为参数传给后者。\n2. <font color = \"rgb(226,238,250)\">`-[ViewController awakeFromNib]`</font>:作为第一个方法的助手，方便处理一些额外的设置。\n3. <font color = \"rgb(226,238,250)\">`-[ViewController loadView]`</font>:创建或加载一个view并把它赋值给<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`view `</font>属性\n4. <font color = \"rgb(226,238,250)\">`-[ViewController viewDidLoad]`</font>:此时整个**视图层次(view hierarchy)**已经被放到内存中，可以移除一些视图，修改约束，加载数据等\n5. <font color = \"rgb(226,238,250)\">`-[ViewController viewWillAppear:] `</font>:视图加载完成，并即将显示在屏幕上,还没有设置动画，可以改变当前屏幕方向或状态栏的风格等。\n6. <font color = \"rgb(226,238,250)\">`-[ViewController viewWillLayoutSubviews]`</font>：即将开始子视图位置布局\n7. <font color = \"rgb(226,238,250)\">`-[ViewController viewDidLayoutSubviews] `</font>：用于通知视图的位置布局已经完成\n8. <font color = \"rgb(226,238,250)\">`-[ViewController viewDidAppear:] `</font>：视图已经展示在屏幕上，可以对视图做一些关于展示效果方面的修改。\n9. <font color = \"rgb(226,238,250)\">`-[ViewController viewWillDisappear:]`</font>：视图即将消失\n10. <font color = \"rgb(226,238,250)\">`-[ViewController viewDidDisappear:]`</font>：视图已经消失\n\n如果考虑<font color = \"rgb(226,238,250)\">`UIViewController`</font>可能在某个时刻释放整个<font color = \"rgb(226,238,250)\">`view`</font>。那么再次加载视图时显然会从步骤3开始。因为此时的<font color = \"rgb(226,238,250)\">`UIViewController`</font>对象依然存在。\n\n#总结\n\n1. 只有init系列的方法,如<font color = \"rgb(226,238,250)\">`initWithNibName`</font>需要自己调用，其他方法如<font color = \"rgb(226,238,250)\">`loadView`</font>和<font color = \"rgb(226,238,250)\">`awakeFromNib`</font>则是系统自动调用。而<font color = \"rgb(226,238,250)\">`viewWill/Did`</font>系列的方法则类似于回调和通知，也会被自动调用。\n2. 纯代码写视图布局时需要注意，要手动调用<font color = \"rgb(226,238,250)\">`loadView`</font>方法，而且不要调用父类的<font color = \"rgb(226,238,250)\">`loadView`</font>方法。纯代码和用IB的区别仅存在于<font color = \"rgb(226,238,250)\">`loadView`</font>方法及其之前，编程时需要注意的也就是<font color = \"rgb(226,238,250)\">`loadView`</font>方法。\n3. 除了<font color = \"rgb(226,238,250)\">`initWithNibName`</font>和<font color = \"rgb(226,238,250)\">`awakeFromNib`</font>方法是处理视图控制器外，其他方法都是处理视图。这两个方法在视图控制器的生命周期里只会调用一次。\n\n\n#参考资料\n\n 1. [UIViewController Class Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/)\n 2. [View Controller Programming Guide for iOS](https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/DefiningYourSubclass.html#//apple_ref/doc/uid/TP40007457-CH7-SW1)\n 3. [NSObject UIKit Additions Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/NSObject_UIKitAdditions/index.html#//apple_ref/occ/instm/NSObject/awakeFromNib)\n 4. [Process of a UIViewController birth](http://stackoverflow.com/questions/5107604/can-somebody-explain-the-process-of-a-uiviewcontroller-birth-which-method-follo)\n 5. [Which should I use, -awakeFromNib or -viewDidLoad?](http://stackoverflow.com/questions/377202/which-should-i-use-awakefromnib-or-viewdidload)\n","html":"<h1 id=\"\">序言:</h1>\n\n<ol>\n<li><code>loadView</code>、<code>viewDidLoad</code>、<code>viewDidAppear</code>、<font color = \"rgb(226,238,250)\"><code>initWithNibName</code></font>、<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>等经常出现在UIViewController中的方法介绍。  </li>\n<li>这些方法分别用来作哪些工作，换言之，创建自定义的View时代码放到以上哪个方法中。  </li>\n<li>一个UIView的生命周期是怎样的。以上几个方法的调用顺序如何。  </li>\n<li>通过IB和代码加载视图，有什么区别</li>\n</ol>\n\n<p><strong>文章主要参考官方和文档和StackOVerFlow有关问题整理得出，由于水平有限，如有错误之处请及时与我联系。</strong></p>\n\n<h1 id=\"uiviewcontroller\">UIViewController</h1>\n\n<h5 id=\"\">视图层次和根视图</h5>\n\n<p>每个视图控制器都维护一个<font color=red><strong>视图层次(view hierarchy)</strong></font>。</p>\n\n<p>因为每个视图都有自己的<strong>子视图</strong>，这个<strong>视图层次</strong>其实也可以理解为一棵树状的数据结构。而树的根节点，也就是根视图(root view)，在UIViewController中以<font color = \"rgb(226,238,250)\"><code>view</code></font>属性。它可以被看做是其他所有子视图的容器。</p>\n\n<h5 id=\"\">视图的加载方式</h5>\n\n<p>UIViewController采用懒加载的方式，也就是说第一次访问到<font color = \"rgb(226,238,250)\"><code>view</code></font>属性时才会加载或创建它。由于视图由视图控制器管理，所以讨论视图的加载方式时，主要讨论视图控制器的加载方式。</p>\n\n<ul>\n<li><p>通过Storyboard加载：这是苹果推荐的方式，也是未来的趋势。            </p>\n\n<p>通过这种方式创建<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>对象的话，首先生成<font color = \"rgb(226,238,250)\"><code>UIStoryboard</code></font>类型的对象，然后调用这个对象的<font color = \"rgb(226,238,250)\"><code>instantiateViewControllerWithIdentifier:</code></font>方法</p></li>\n<li><p>通过Nib文件加载：</p>\n\n<p>Nib文件其实就是xib文件，Storyboard相当于是聚合了多个nib文件，并且添加了对不同的<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>之间的segue和relationship的管理。但总的实现原理非常类似</p>\n\n<p>通过这种方式加载视图,需要调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>类的<font color = \"rgb(226,238,250)\"><code>initWithNibName:bundle:</code></font>方法</p></li>\n<li><p>通过loadview方法加载：</p>\n\n<p>这就是通过代码加载。这需要我们在<font color = \"rgb(226,238,250)\"><code>loadView</code></font>  方法中，通过编程创建自己的<strong>视图层次</strong>，并且把把根视图赋值给<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性。</p></li>\n</ul>\n\n<p>因此，通过代码自定义View的时候，<font color = \"rgb(226,238,250)\"><code>loadView</code></font>    方法大概是这样的：</p>\n\n<pre><code class=\"language-Objective-C\">- (void)loadView{\n    self.view = [[XXXView alloc] init];\n}\n</code></pre>\n\n<h3 id=\"\">处理视图相关通知</h3>\n\n<p>当视图的可见性发生变化时，视图控制器会自动调用一系列方法来响应变化。</p>\n\n<p>所有可能的状态、方法和状态之间的转换关系在下图中被明确标出。</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/UIViewLifeCircle/StateTransitionspng.png\" alt=\"\" /></p>\n\n<p>可以看到每一个will方法都有自己对应的did方法。但是如果我们在will方法中开始一个任务，不仅要在对应的did方法中结束它，还要考虑到和这个will方法相反的那个will方法（注意到Appearing和Disappearing这两个状态是可以互相转化的）</p>\n\n<h1 id=\"view\">在运行时展示View</h1>\n\n<p>UIKit极大的简化了加载和展示View的过程，它大概会按照以下顺序执行一些任务：</p>\n\n<ol>\n<li>通过storyboard文件中的信息实例化视图  </li>\n<li>连接outlet和action  </li>\n<li>把根视图赋值给<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性（其实就是调用<font color = \"rgb(226,238,250)\"><code>loadView</code></font>    方法）  </li>\n<li>调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法。要注意，在调用方法前，</font>的<font color = \"rgb(226,238,250)\"><code>trait collecion</code></font>为空且子视图的位置可能不正确  </li>\n<li>调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>viewDidLoad</code></font>方法。</li>\n</ol>\n\n<p>此时已经完成了视图的加载工作，在展示到屏幕之前，还有以下几个步骤：</p>\n\n<ol>\n<li>调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>viewWillAppear</code></font>方法。  </li>\n<li>更新视图的布局  </li>\n<li>把视图展示到屏幕上  </li>\n<li>调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>viewDidAppear</code></font>方法。</li>\n</ol>\n\n<h5 id=\"awakefromnib\">awakeFromNib方法</h5>\n\n<p>至此，第一个问题已经几乎解释完了，还剩一个<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法。</p>\n\n<p>我们已经知道，<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法被调用时，所有视图的outlet和action已经连接，但还没有被确定。这个方法可以算作是和视图控制器的实例化配合在一起使用的，因为有些需要根据用户喜好来进行设置的内容，无法存在storyboard中，所以可以在<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法中被加载进来。</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法在视图控制器的生命周期内只会被调用一次。因为它和视图控制器从nib文件中的解档密切相关，和view的关系却不大。</p>\n\n<h1 id=\"\">具体方法的解释</h1>\n\n<h5 id=\"loadview\">loadView方法</h5>\n\n<p>当执行到<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法时，视图控制器已经从nib文件中被解档并创建好了，接下来的任务主要是对view进行初始化。</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法在<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>对象的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性被访问到且为空的时候调用。 <br />\n这是它与<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法的一个区别。假设我们在处理内存警告时释放<font color = \"rgb(226,238,250)\"><code>view</code></font>属性（其实并不应该这么做，这里举个例子）：<font color = \"rgb(226,238,250)\"><code>self.view = nil</code></font>。因此<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法在视图控制器的生命周期内可能会被多次调用。</p>\n\n<p>这个方法不应该被直接调用，而是由系统自动调用。它会加载或创建一个view并把它赋值给<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性。</p>\n\n<p>在创建view的过程中，首先会根据<font color = \"rgb(226,238,250)\"><code>nibName</code></font>去找对应的Nib文件然后加载。如果<font color = \"rgb(226,238,250)\"><code>nibName</code></font>为空，或找不到对应的Nib文件，则会创建一个空视图(这种情况一般是纯代码，也就是为什么说代码构建View的时候，要重写<font color = \"rgb(226,238,250)\"><code>loadView</code></font>    方法)。</p>\n\n<p>注意在重写<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法的时候，不要调用父类的方法。</p>\n\n<h3 id=\"viewdidload\">viewDidLoad方法</h3>\n\n<p><font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法执行完之后，就会执行<font color = \"rgb(226,238,250)\"><code>viewDidLoad</code></font>方法。此时整个<strong>视图层次(view hierarchy)</strong>已经被放到内存中。</p>\n\n<p>无论是从nib文件加载，还是通过纯代码编写界面，<font color = \"rgb(226,238,250)\"><code>viewDidLoad</code></font>方法都会执行。我们可以重写这个方法，对通过nib文件加载的view做一些其他的初始化工作。比如可以移除一些视图，修改约束，加载数据等。</p>\n\n<h5 id=\"viewwillappearviewdidappear\">viewWillAppear和viewDidAppear方法</h5>\n\n<p>在视图加载完成，并即将显示在屏幕上时，会调用<font color = \"rgb(226,238,250)\"><code>viewWillAppear</code></font>方法，在这个方法里，可以改变当前屏幕方向或状态栏的风格等。</p>\n\n<p>当<font color = \"rgb(226,238,250)\"><code>viewWillAppear</code></font>方法执行完后，系统会执行<font color = \"rgb(226,238,250)\"><code>viewDidAppear</code></font>方法。在这个方法中，还可以对视图做一些关于展示效果方面的修改。</p>\n\n<h1 id=\"\">视图的生命历程</h1>\n\n<p>到目前为止，我们已经了解了每个方法的作用，接下来就把整个流程梳理一遍。</p>\n\n<ol>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController  initWithCoder:]</code>或<code>-[ViewController  initWithNibName:Bundle]</code></font>:首先从归档文件中加载<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>对象。即使是纯代码，也会把nil作为参数传给后者。  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController awakeFromNib]</code></font>:作为第一个方法的助手，方便处理一些额外的设置。  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController loadView]</code></font>:创建或加载一个view并把它赋值给<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewDidLoad]</code></font>:此时整个<strong>视图层次(view hierarchy)</strong>已经被放到内存中，可以移除一些视图，修改约束，加载数据等  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewWillAppear:]</code></font>:视图加载完成，并即将显示在屏幕上,还没有设置动画，可以改变当前屏幕方向或状态栏的风格等。  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewWillLayoutSubviews]</code></font>：即将开始子视图位置布局  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewDidLayoutSubviews]</code></font>：用于通知视图的位置布局已经完成  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewDidAppear:]</code></font>：视图已经展示在屏幕上，可以对视图做一些关于展示效果方面的修改。  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewWillDisappear:]</code></font>：视图即将消失  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewDidDisappear:]</code></font>：视图已经消失</li>\n</ol>\n\n<p>如果考虑<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>可能在某个时刻释放整个<font color = \"rgb(226,238,250)\"><code>view</code></font>。那么再次加载视图时显然会从步骤3开始。因为此时的<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>对象依然存在。</p>\n\n<h1 id=\"\">总结</h1>\n\n<ol>\n<li>只有init系列的方法,如<font color = \"rgb(226,238,250)\"><code>initWithNibName</code></font>需要自己调用，其他方法如<font color = \"rgb(226,238,250)\"><code>loadView</code></font>和<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>则是系统自动调用。而<font color = \"rgb(226,238,250)\"><code>viewWill/Did</code></font>系列的方法则类似于回调和通知，也会被自动调用。  </li>\n<li>纯代码写视图布局时需要注意，要手动调用<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法，而且不要调用父类的<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法。纯代码和用IB的区别仅存在于<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法及其之前，编程时需要注意的也就是<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法。  </li>\n<li>除了<font color = \"rgb(226,238,250)\"><code>initWithNibName</code></font>和<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法是处理视图控制器外，其他方法都是处理视图。这两个方法在视图控制器的生命周期里只会调用一次。</li>\n</ol>\n\n<h1 id=\"\">参考资料</h1>\n\n<ol>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/\">UIViewController Class Reference</a></li>\n<li><a href=\"https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/DefiningYourSubclass.html#//apple_ref/doc/uid/TP40007457-CH7-SW1\">View Controller Programming Guide for iOS</a></li>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/NSObject_UIKitAdditions/index.html#//apple_ref/occ/instm/NSObject/awakeFromNib\">NSObject UIKit Additions Reference</a></li>\n<li><a href=\"http://stackoverflow.com/questions/5107604/can-somebody-explain-the-process-of-a-uiviewcontroller-birth-which-method-follo\">Process of a UIViewController birth</a></li>\n<li><a href=\"http://stackoverflow.com/questions/377202/which-should-i-use-awakefromnib-or-viewdidload\">Which should I use, -awakeFromNib or -viewDidLoad?</a></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":"UIView的生命周期总结","meta_description":"","author_id":1,"created_at":"2016-01-11T13:40:39.000Z","created_by":1,"updated_at":"2016-01-11T15:14:48.000Z","updated_by":1,"published_at":"2015-11-26T13:44:00.000Z","published_by":1},{"id":2,"uuid":"2fe16a2a-f153-4000-8658-ca86765487aa","title":"修改一个数字破解Mac上的应用","slug":"xiu-gai-yi-ge-shu-zi-po-jie-macshang-de-ying-yong","markdown":"在某位大神的博客里看到了Mac一款非常好用的App，叫<font color=red>Paw</font>。\n\nPaw可以在Mac上模拟各种HTTP请求，可视化的管理HTTP Header、Parameters、Cookies等，还有一点非常出乎意料的功能是通过下载插件可以自动生成Swfit、OC、JS等多种语言的代码。\n\n然而Paw巨贵（200软妹币），而且破解版不好搜。于是寻思着自己动手解决需求，于是可怜的Paw成了实验对象。[先从这里下载原版app](https://luckymarmot.com/paw),一会儿教程中会逐步分析如何破解这个软件。\n\n由于在此之前我毫无逆向工程方面的经验，在看别人的介绍时各种不懂，深受折磨，所以我尽量用简单、详细的语言描述本次从零开始破解app之旅。作为参考，我用了**大约七个小时**的时间完成了此次破解（大量的时间浪费在找工具以及学习使用工具上，后面可以看到破解这个事情本身并不难）。在文章的最后会给出最新版Paw（2.2.6）的原版和破解版下载。\n\n由于水平有限，只是介绍了基本的逆向工程知识，算是自己的学习笔记，也希望向更多的和我一样还只是菜鸟的程序员科普一些逆向工程的基本知识，同时督促自己平时在Coding过程中的注意代码规范和安全。\n\n#知识储备\n\n想要破解app，首先自己得开发过app，至少了解一些基本的命令行操作，源代码、汇编代码和二进制码的基本定义。如果这些基本要求有某一点不满足，那么整个过程会是非常痛苦的。\n\n#工具准备\n破解Paw用到的工具主要有以下几个。\n\n+ <font color=red>homebrew</font> —— 不知道这个的估计都不好意思说自己是用Mac的程序员。\n+ [<font color=red>Hopper Disassembler</font>](http://pan.baidu.com/s/1bn94SDx) —— 反编译工具，根据可执行文件反编译出汇编码。\n+ [<font color=red>Class-dump</font>](http://stevenygard.com/projects/class-dump/) —— 逆向工程的入门级工具，导出一个App的某些信息。\n+ <font color = red>otx</font> —— 国外某位大神的博客上用的一个工具，我也说不出明确的用处。通过`brew install --HEAD homebrew/head-only/otx`命令安装。\n+ [<font color=red>Hex friend</font>](http://ridiculousfish.com/hexfiend/) —— 二进制文件编辑器，要用这个修改原来的二进制文件。\n+ <font color=red>gdb</font> —— 著名的调试器，用lldb也行。通过`brew install gdb`命令安装。\n\n#Begin cracking\n\n###找到破解点\n要破解App当然要明白自己为什么要破解它，它哪一点限制了我们，首先运行原版的Paw。可以看到如下界面:\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/real-paw-welcome.png)\n\n这个Welcome界面非常讨厌，由于它的存在，我们不能点击程序主界面。而想要关掉这个Welcome界面，只有两个方法，选择**Try Paw**按钮获得30天试用期或点击**Register License**按钮输入自己的License。\n\n因此我们的目的以及非常明确了——**<font color = red>关闭这个Welcome页面</font>**\n\n###初探Paw\n\n既然要破解这个App，免不了要去了解这个App的结构。现在我们手上只有在Applications文件夹下的Paw.app这一个文件。突破口在于**Paw.app/Contents/MacOs/Paw**这个可执行的二进制文件。我们以后的操作，绝大多数时候是与它打交道。在“**应用程序**”文件夹下，右键Paw，选择“**显示包内容**”就可以看到这个二进制文件了\n\n这时候，第一个工具——<font color = \"rgb(226,238,250)\">`class-dump`</font>出场了。由于篇幅所限，我就不介绍这个工具的具体配置方法了。可以参考这篇文章\n\n>\t[<font color = red>使用class-dump导出其他应用头文件</font>](http://www.jianshu.com/p/6a6ce18f998e)\n\n我们先用<font color = \"rgb(226,238,250)\">`class-dump`</font>导出Paw的头文件看看，在终端中执行命令：\n\n<font color = \"rgb(226,238,250)\">`class-dump -H /Applications/PawReal.app/Contents/MacOS/Paw -o /Users/你的用户名/Desktop/classdump`</font>,\n\n换上你的用户名，等运行结束之后，在桌面上可以看到一个叫<font color = \"rgb(226,238,250)\">`classdump`</font>的文件夹。不要被里面密密麻麻的文件吓到，这就是这个app所有的头文件了。\n\n###换位思考，变通思路\n\n接下来怎么找我们需要的信息呢，要想一个一个看过去，即使头文件里面只有方法和变量的定义，也是不现实的。好在<font color = \"rgb(226,238,250)\">`class-dump`</font>还有别的功能。执行命令：\n\n<font color = \"rgb(226,238,250)\">`class-dump -f license /Applications/PawReal.app/Contents/MacOS/Paw`</font>\n\n可以找到头文件中所有和license有关的部分。\n\n会什么要找license呢，这个就需要猜了。既然这个软件需要注册码，并且Welcome界面有一个**Register License**按钮，一定会有一部分代码是用来管理证书（License）相关的。让我们站在开发者的角度上想，如果要遵守命名规范，那么头文件中也许会有**License**关键字的身影。\n\n当然，这只是猜想，如果针对**License**关键字的查找结果不理想的话，我们还可以换一些关键字，比如**Register**、**Validate**等。\n\n不过好在我们通过<font color = \"rgb(226,238,250)\">`class-dump`</font>发现了一些线索，如图所示：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/class-dump-license.png)\n\n在图中，我们发现了一个比较有价值的类:<font color = \"rgb(226,238,250)\">`LMWelcomeViewController`</font>\n\n###合理猜想，趁胜追击\n\n发现<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>这个用来管理Welcome页面的类之后，我们打开头文件看看里面的函数。很“巧”地，里面有一组函数，都是以<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>开头。直觉告诉我们，这个用来显示Welcome页面的方法，很有可能就是解决问题的关键。\n\n故技重施，再看一看<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>这个函数的信息。运行：\n\n<font color = \"rgb(226,238,250)\">`class-dump -f showWelcome /Applications/PawCrack.app/Contents/MacOS/Paw`</font>\n\n可以看到这样的结果：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/class-dump-showWelcome.png)\n\n这就基本上印证了之前的猜想:<font color = \"rgb(226,238,250)\">`LMApplicationDelegate.m`</font>中的代码在程序启动时执行，通过某种方式判断用户是否已注册，**如果没有的话**，就调用<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>这个函数，同时把<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>类的实例对象作为参数，这个对象再执行自己的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法，**展示Welcome页面**\n\n当然，这样的分析很可能是错的。因为判断是否注册这个逻辑并不一定在<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>中进行，也可以放在<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>里。但无论如何，注意到黑体字部分连起来也是一段话，整个过程其实是一个**“如果……，就……”**的逻辑。\n\n记住这个逻辑，一会儿我们会根据这个逻辑做一些修改！\n\n###细看函数实现\n\n我们已经知道<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法可能是解决问题的关键，接下来我们就来看看这个方法到底是怎么实现的。\n\n打开Hopper Disassembler，把**MacOS**文件夹下的**Paw**二进制文件拖入其中，开始分析。Hopper Disassembler可以根据二进制文件反汇编成汇编代码。刚打开的时候，这个软件是这个样子：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/Hopper-Disassembler-introduction.png)\n\n在这个软件中看到的东西往往非常奇葩，和任何一种高级编程语言都不同。这种汇编语言给新手的阅读造成了极大的障碍，好在有一些注释，也可以生成伪代码，辅助我们阅读。我几乎不太能看懂汇编语言，所以尽量避免过多的研究他们。\n\n在左边的Labels标签下搜索我们感兴趣的内容，比如刚刚说的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法。\n\n可以分别看到在<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>和<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>中<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法的实现：\n\n![<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>](https://raw.githubusercontent.com/649395594/AppCrack/master/search-1.png)\n\n![<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>](https://raw.githubusercontent.com/649395594/AppCrack/master/search-2.png)\n\n<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>中的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法非常简单，根据绿色部分的注释可以猜到调用了参数的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法。或者我们可以选中这段汇编代码，点右上角的![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo-icon.png)图标生成伪代码。\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo1.png)\n\n<font color = \"rgb(226,238,250)\">`LMWelcomeViewController `</font>中的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法比较复杂。\n\n之前的图片上可以看到两个汇编指令分别是：<font color = \"rgb(226,238,250)\">`je `</font>和<font color = \"rgb(226,238,250)\">`ret `</font>\n\n<font color = \"rgb(226,238,250)\">`je`</font>是**\"jump euqal\"**的缩写，表示如果相等，则跳转到某个地址。所以我们可以在<font color = \"rgb(226,238,250)\">`je `</font>的上面一行看到<font color = \"rgb(226,238,250)\">`cmp `</font>指令。与<font color = \"rgb(226,238,250)\">`je `</font>相对应的就是<font color = \"rgb(226,238,250)\">`jne `</font>，表示**\"jump not euqal\"**\n\n<font color = \"rgb(226,238,250)\">`ret`</font>顾名思义就是**return的缩写了**，表示函数在这里返回。\n\n其实在这里我们已经可以大概了解这个</font>中的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法的实现了。进行了一个判断，如果城里就返回，否则就进行下面一段操作，而根据右侧绿色提示，我们看到了**“可怕”**的<font color =\"rgb(226,238,250)\">`showWindow`</font>方法，这个方法没有在头文件里面看到，估计就是一个 私有方法了。\n\n如果不放心的话还可以生成伪代码看看：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo2.png)\n\n###巧变逻辑\n\n之前分析了整个Welcome页面出现的逻辑其实是一个**“如果……，就……”**的判断，那么要想破解，也很容易。方法有两个，要么判断条件不成立，要么改变执行语句。显然，对于不熟悉汇编和逆向工程的新手而言，让判断条件不容易更加简单一些。注意到<font color = \"rgb(226,238,250)\">`je`</font>指令之前有一个数字：**00000001000cdfaf**，它表示的是这条指令在虚拟内存空间中的地址。那么这个地址有什么用呢？\n\n###梳理思路\n\n确实乍一看，获取指令的地址并没有用处。而且从开始到现在，一直在接触完全没接触过的东西，已经有点晕乎了。\n\n梳理一下到目前为止的思路，我们从**license**关键字树藤摸瓜，找到了<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法。分析出其中的关键一步是<font color = \"rgb(226,238,250)\">`je`</font>指令，最后还知道了这条指令在虚拟内存中的地址。\n\n其实我们的目的非常简单，就是把<font color = \"rgb(226,238,250)\">`je`</font>指令换成<font color = \"rgb(226,238,250)\">`jne`</font>指令。到目前为止，只剩三步。\n\n1. 算出<font color = \"rgb(226,238,250)\">`je`</font>指令的二进制码。\n2. 算出<font color = \"rgb(226,238,250)\">`jne`</font>指令的二进制码。\n3. 在二进制文件中，把算出<font color = \"rgb(226,238,250)\">`je`</font>指令的二进制码换成算出<font color = \"rgb(226,238,250)\">`jne`</font>指令的二进制码。\n\n幸好，gdb调试器能够为我们做前两步。免去了我们完全不熟悉的从汇编到二进制码转换的过程。gdb调试器有一个<font color = \"rgb(226,238,250)\">`x/x`</font>命令，可以读取给定内存地址中的数据。\n\n我们知道，程序运行的过程，简单来说其实就是二进制码从硬盘加载进内存，然后从程序入口开始运行的过程。我们不是汇编器，不善于做静态的、从汇编码到二进制码的转换工作。但是gdb调试器允许我们动态地、逆向的从内存中找到二进制码。\n\n所以，距离成功还差最后一步！\n\n###二进制文件\n\n所以，执行：\n\n<font color = \"rgb(226,238,250)\">`x/x 0x00000001000cdfaf`</font>\n\n可以得到如下的结果：\n\n<font color = \"rgb(226,238,250)\">`0x1000cdfaf <_mh_execute_header+843695>:\t0x83480774`</font>\n\n这里的**0x83480774**就是16进制格式的程序二进制码。接下来就可以打开**Hex friend**软件对二进制码进行修改了。**Hex friend**把应用程序以16进制的形式展现出了，支持查找、替换功能。\n\n按下<font color = \"rgb(226,238,250)\">`Command + F`</font>进行查找。\n\n特别需要注意点是**字节序问题（Byte Order）**，Intel处理器一般是以**小端（Little endian）**进行存储，而在硬盘上的二进制码，则是以**大端（Big endian）**存储。所谓的**大端**，就是把数字的最高位放在最前面，**小端**则是把最高位放在最后面。\n\n也就是说**0x83480774**作为一个**小端**数，它的**大端**形式应该是**74074883**,点击**Replace & Find**按钮之后，很不幸的事情出现了：这个数字不止出现了一次。\n\n解决方案很简单，用同样的方法，看看下一条指令的的二进制码就可以了。执行：\n\n<font color = \"rgb(226,238,250)\">`0x1000cdfb1 <_mh_execute_header+843695>:\t0x83480774`</font>\n\n得到：\n\n<font color = \"rgb(226,238,250)\">`0x1000cdfaf <_mh_execute_header+843695>:\t0x08c48348`</font>\n\n用大端表示就是**4883c408**，这个数字的前四位和之前的数字的后四位刚好是相同的。这个不是巧合，因为不同的指令，二进制码长度不同。而gdb的<font color = \"rgb(226,238,250)\">`x/x`</font>指令总是读取相同长度的内存中的数据。\n\n这一点并不影响破解Paw，但是如果想了解的非常透彻的话，可以用<font color = \"rgb(226,238,250)\">`otx`</font>命令查看：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/otx.png)\n\n可以看到其实<font color = \"rgb(226,238,250)\">`eq`</font>指令的实际二进制码是**7407**。\n\n现在终于确定了要被替换的数字式**74074883c408**，这里面包含了<font color = \"rgb(226,238,250)\">`eq`</font>指令的二进制码和接下来一些指令的二进制码。这些多余信息是为了唯一确定这组数的位置的。\n\n**“7407”**由**“74”**和**“07”**两部分组成，查阅相关资料或者多找几个其他的<font color = \"rgb(226,238,250)\">`eq`</font>指令和<font color = \"rgb(226,238,250)\">`enq`</font>指令可以知道，<font color = \"rgb(226,238,250)\">`eq`</font>指令的二进制码是**“74”**而<font color = \"rgb(226,238,250)\">`eq`</font>指令的二进制码是**“75”**。\n\n所以用来替换的数应该就是**“75074883c408”**。在**Hex friend**中填写好相关数据后选择**Replace**并保存。如图所示：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/replace.png)\n\n\n至此，整个破解的过程就完成了。其实细想一下，我们只是**把一个4换成了5**而已！\n\n###文件签名\n\n用修改过后的二进制文件替换原来文件后，打开程序总是会立刻报错。如果在命令行中运行，还可以看到**killed 9**的提示。\n\n这是因为苹果为了保证软件的安全加入了**<font color=red>代码签名（CodeSignature）</font>**机制。在**Contents**文件夹下可以找到**_CodeSignature**文件夹和其中的**CodeResources**文件。任何对二进制文件的修改，都无法通过代码签名的检查。\n\n关于代码签名的具体解释，和操作过程，可以看这篇文章：\n> [《How to re-sign Apple's applications once they've been modified》](http://forums.macnn.com/79/developer-center/355720/how-re-sign-apples-applications-once/)\n\n文章把每一步都描述得非常透彻，我就不重述了。按照文章所描述的，建立好自己的签名证书后，只要执行这条命令：\n\n\n<font color = \"rgb(226,238,250)\">`codesign -f -s 证书名 /Applications/PawCrack.app/Contents/MacOS/Paw`</font>\n\n其中证书名写自己创建的证书的名字，一切顺利的话，会得到这样的提示：\n<font color = \"rgb(226,238,250)\">`/Applications/PawCrack.app/Contents/MacOS/Paw: replacing existing signature`</font>\n\n代码重签名完成之后，就可以成功打开破解之后的App了。\n\n###尾巴\n\n打开App之后我们可以发现，**烦人**的Welcome页不见了。因为反转了判断逻辑，所以不执行<font color = \"rgb(226,238,250)\">`showWelcomeWindow`</font>方法了。\n\n不过可惜的是，发送HTTP请求的按钮依然点击无效。应该是还有判断机制。只要按照之前的步骤再来一次就可以了。\n\n#总结\n\n首先回顾一下整个破解过程。准备好工具之后，我们先从头文件里面搜索可以的方法名，再用反编译工具查看具体方法的汇编代码实现。结合基本的汇编语法和伪代码，了解整个方法的工作原理。最后修改if语句的逻辑从而完成破解。\n\n其实由于大部分针对功能的限制，都是基于<font color = \"rgb(226,238,250)\">`if else`</font>语句进行判断的，也就是说对于相当多的软件，只要我们分析出它的逻辑，只需要把一个4改成5即可破解。\n\n整个破解过程，除了巩固了操作系统的基础知识之外，我觉得对于iOS engineer来说还有一些其他的收获：\n\n1. 严格遵守**“迪米特法则”**，把不必要对外提供的在.m文件里定义、实现。这样不仅防止被class-dump扫描到，也能减轻与你合作的同事开发时的负担。\n2. 发布版本gcc编译时去掉<font color = \"rgb(226,238,250)\">`-g`</font>参数。我猜测，正是由于Paw这么做了，导致我无法用gdb调试器加断点。因为找不到函数的符号名。\n3. 对于极为核心的部分，可以做适当的代码混淆。\n\n做到以上几点非常轻松，但是足以防止数量广大，但又技术一般的tinkerer(比如作者本人)的捣鼓了。\n\n##参考资料\n1.\t[《Giving gdb permission to control other processes》](http://www.cnblogs.com/yishuiliunian/archive/2013/01/13/2858836.html)\n2.\t[《I Can Crack Your App With Just A Shell》](http://kswizz.com/2011-01-16/hacking-mac-apps/)\n3.\t[《How to re-sign Apple's applications once they've been modified》](http://forums.macnn.com/79/developer-center/355720/how-re-sign-apples-applications-once/)\n4.\t[Beginning Mac Hacking](http://www.mrspeaker.net/2011/01/06/mac-hacking/)","html":"<p>在某位大神的博客里看到了Mac一款非常好用的App，叫<font color=red>Paw</font>。</p>\n\n<p>Paw可以在Mac上模拟各种HTTP请求，可视化的管理HTTP Header、Parameters、Cookies等，还有一点非常出乎意料的功能是通过下载插件可以自动生成Swfit、OC、JS等多种语言的代码。</p>\n\n<p>然而Paw巨贵（200软妹币），而且破解版不好搜。于是寻思着自己动手解决需求，于是可怜的Paw成了实验对象。<a href=\"https://luckymarmot.com/paw\">先从这里下载原版app</a>,一会儿教程中会逐步分析如何破解这个软件。</p>\n\n<p>由于在此之前我毫无逆向工程方面的经验，在看别人的介绍时各种不懂，深受折磨，所以我尽量用简单、详细的语言描述本次从零开始破解app之旅。作为参考，我用了<strong>大约七个小时</strong>的时间完成了此次破解（大量的时间浪费在找工具以及学习使用工具上，后面可以看到破解这个事情本身并不难）。在文章的最后会给出最新版Paw（2.2.6）的原版和破解版下载。</p>\n\n<p>由于水平有限，只是介绍了基本的逆向工程知识，算是自己的学习笔记，也希望向更多的和我一样还只是菜鸟的程序员科普一些逆向工程的基本知识，同时督促自己平时在Coding过程中的注意代码规范和安全。</p>\n\n<h1 id=\"\">知识储备</h1>\n\n<p>想要破解app，首先自己得开发过app，至少了解一些基本的命令行操作，源代码、汇编代码和二进制码的基本定义。如果这些基本要求有某一点不满足，那么整个过程会是非常痛苦的。</p>\n\n<h1 id=\"\">工具准备</h1>\n\n<p>破解Paw用到的工具主要有以下几个。</p>\n\n<ul>\n<li><font color=red>homebrew</font> —— 不知道这个的估计都不好意思说自己是用Mac的程序员。</li>\n<li><a href=\"http://pan.baidu.com/s/1bn94SDx\"><font color=red>Hopper Disassembler</font></a> —— 反编译工具，根据可执行文件反编译出汇编码。</li>\n<li><a href=\"http://stevenygard.com/projects/class-dump/\"><font color=red>Class-dump</font></a> —— 逆向工程的入门级工具，导出一个App的某些信息。</li>\n<li><font color = red>otx</font> —— 国外某位大神的博客上用的一个工具，我也说不出明确的用处。通过<code>brew install --HEAD homebrew/head-only/otx</code>命令安装。</li>\n<li><a href=\"http://ridiculousfish.com/hexfiend/\"><font color=red>Hex friend</font></a> —— 二进制文件编辑器，要用这个修改原来的二进制文件。</li>\n<li><font color=red>gdb</font> —— 著名的调试器，用lldb也行。通过<code>brew install gdb</code>命令安装。</li>\n</ul>\n\n<h1 id=\"begincracking\">Begin cracking</h1>\n\n<h3 id=\"\">找到破解点</h3>\n\n<p>要破解App当然要明白自己为什么要破解它，它哪一点限制了我们，首先运行原版的Paw。可以看到如下界面:</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/real-paw-welcome.png\" alt=\"\" /></p>\n\n<p>这个Welcome界面非常讨厌，由于它的存在，我们不能点击程序主界面。而想要关掉这个Welcome界面，只有两个方法，选择<strong>Try Paw</strong>按钮获得30天试用期或点击<strong>Register License</strong>按钮输入自己的License。</p>\n\n<p>因此我们的目的以及非常明确了——<strong><font color = red>关闭这个Welcome页面</font></strong></p>\n\n<h3 id=\"paw\">初探Paw</h3>\n\n<p>既然要破解这个App，免不了要去了解这个App的结构。现在我们手上只有在Applications文件夹下的Paw.app这一个文件。突破口在于<strong>Paw.app/Contents/MacOs/Paw</strong>这个可执行的二进制文件。我们以后的操作，绝大多数时候是与它打交道。在“<strong>应用程序</strong>”文件夹下，右键Paw，选择“<strong>显示包内容</strong>”就可以看到这个二进制文件了</p>\n\n<p>这时候，第一个工具——<font color = \"rgb(226,238,250)\"><code>class-dump</code></font>出场了。由于篇幅所限，我就不介绍这个工具的具体配置方法了。可以参考这篇文章</p>\n\n<blockquote>\n  <p><a href=\"http://www.jianshu.com/p/6a6ce18f998e\"><font color = red>使用class-dump导出其他应用头文件</font></a></p>\n</blockquote>\n\n<p>我们先用<font color = \"rgb(226,238,250)\"><code>class-dump</code></font>导出Paw的头文件看看，在终端中执行命令：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>class-dump -H /Applications/PawReal.app/Contents/MacOS/Paw -o /Users/你的用户名/Desktop/classdump</code></font>,</p>\n\n<p>换上你的用户名，等运行结束之后，在桌面上可以看到一个叫<font color = \"rgb(226,238,250)\"><code>classdump</code></font>的文件夹。不要被里面密密麻麻的文件吓到，这就是这个app所有的头文件了。</p>\n\n<h3 id=\"\">换位思考，变通思路</h3>\n\n<p>接下来怎么找我们需要的信息呢，要想一个一个看过去，即使头文件里面只有方法和变量的定义，也是不现实的。好在<font color = \"rgb(226,238,250)\"><code>class-dump</code></font>还有别的功能。执行命令：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>class-dump -f license /Applications/PawReal.app/Contents/MacOS/Paw</code></font></p>\n\n<p>可以找到头文件中所有和license有关的部分。</p>\n\n<p>会什么要找license呢，这个就需要猜了。既然这个软件需要注册码，并且Welcome界面有一个<strong>Register License</strong>按钮，一定会有一部分代码是用来管理证书（License）相关的。让我们站在开发者的角度上想，如果要遵守命名规范，那么头文件中也许会有<strong>License</strong>关键字的身影。</p>\n\n<p>当然，这只是猜想，如果针对<strong>License</strong>关键字的查找结果不理想的话，我们还可以换一些关键字，比如<strong>Register</strong>、<strong>Validate</strong>等。</p>\n\n<p>不过好在我们通过<font color = \"rgb(226,238,250)\"><code>class-dump</code></font>发现了一些线索，如图所示：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/class-dump-license.png\" alt=\"\" /></p>\n\n<p>在图中，我们发现了一个比较有价值的类:<font color = \"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font></p>\n\n<h3 id=\"\">合理猜想，趁胜追击</h3>\n\n<p>发现<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>这个用来管理Welcome页面的类之后，我们打开头文件看看里面的函数。很“巧”地，里面有一组函数，都是以<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>开头。直觉告诉我们，这个用来显示Welcome页面的方法，很有可能就是解决问题的关键。</p>\n\n<p>故技重施，再看一看<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>这个函数的信息。运行：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>class-dump -f showWelcome /Applications/PawCrack.app/Contents/MacOS/Paw</code></font></p>\n\n<p>可以看到这样的结果：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/class-dump-showWelcome.png\" alt=\"\" /></p>\n\n<p>这就基本上印证了之前的猜想:<font color = \"rgb(226,238,250)\"><code>LMApplicationDelegate.m</code></font>中的代码在程序启动时执行，通过某种方式判断用户是否已注册，<strong>如果没有的话</strong>，就调用<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>这个函数，同时把<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>类的实例对象作为参数，这个对象再执行自己的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法，<strong>展示Welcome页面</strong></p>\n\n<p>当然，这样的分析很可能是错的。因为判断是否注册这个逻辑并不一定在<font color = \"rgb(226,238,250)\"><code>LMApplicationDelegate</code></font>中进行，也可以放在<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>里。但无论如何，注意到黑体字部分连起来也是一段话，整个过程其实是一个<strong>“如果……，就……”</strong>的逻辑。</p>\n\n<p>记住这个逻辑，一会儿我们会根据这个逻辑做一些修改！</p>\n\n<h3 id=\"\">细看函数实现</h3>\n\n<p>我们已经知道<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法可能是解决问题的关键，接下来我们就来看看这个方法到底是怎么实现的。</p>\n\n<p>打开Hopper Disassembler，把<strong>MacOS</strong>文件夹下的<strong>Paw</strong>二进制文件拖入其中，开始分析。Hopper Disassembler可以根据二进制文件反汇编成汇编代码。刚打开的时候，这个软件是这个样子：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/Hopper-Disassembler-introduction.png\" alt=\"\" /></p>\n\n<p>在这个软件中看到的东西往往非常奇葩，和任何一种高级编程语言都不同。这种汇编语言给新手的阅读造成了极大的障碍，好在有一些注释，也可以生成伪代码，辅助我们阅读。我几乎不太能看懂汇编语言，所以尽量避免过多的研究他们。</p>\n\n<p>在左边的Labels标签下搜索我们感兴趣的内容，比如刚刚说的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法。</p>\n\n<p>可以分别看到在<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>和<font color = \"rgb(226,238,250)\"><code>LMApplicationDelegate</code></font>中<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法的实现：</p>\n\n<p><img src=\"https://raw.githubusercontent.com/649395594/AppCrack/master/search-1.png\" alt=\"<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>\" /></p>\n\n<p><img src=\"https://raw.githubusercontent.com/649395594/AppCrack/master/search-2.png\" alt=\"<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>\" /></p>\n\n<p><font color = \"rgb(226,238,250)\"><code>LMApplicationDelegate</code></font>中的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法非常简单，根据绿色部分的注释可以猜到调用了参数的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法。或者我们可以选中这段汇编代码，点右上角的<img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo-icon.png\" alt=\"\" title=\"\" />图标生成伪代码。</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo1.png\" alt=\"\" /></p>\n\n<p><font color = \"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>中的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法比较复杂。</p>\n\n<p>之前的图片上可以看到两个汇编指令分别是：<font color = \"rgb(226,238,250)\"><code>je</code></font>和<font color = \"rgb(226,238,250)\"><code>ret</code></font></p>\n\n<p><font color = \"rgb(226,238,250)\"><code>je</code></font>是<strong>\"jump euqal\"</strong>的缩写，表示如果相等，则跳转到某个地址。所以我们可以在<font color = \"rgb(226,238,250)\"><code>je</code></font>的上面一行看到<font color = \"rgb(226,238,250)\"><code>cmp</code></font>指令。与<font color = \"rgb(226,238,250)\"><code>je</code></font>相对应的就是<font color = \"rgb(226,238,250)\"><code>jne</code></font>，表示<strong>\"jump not euqal\"</strong></p>\n\n<p><font color = \"rgb(226,238,250)\"><code>ret</code></font>顾名思义就是<strong>return的缩写了</strong>，表示函数在这里返回。</p>\n\n<p>其实在这里我们已经可以大概了解这个</font>中的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法的实现了。进行了一个判断，如果城里就返回，否则就进行下面一段操作，而根据右侧绿色提示，我们看到了<strong>“可怕”</strong>的<font color =\"rgb(226,238,250)\"><code>showWindow</code></font>方法，这个方法没有在头文件里面看到，估计就是一个 私有方法了。</p>\n\n<p>如果不放心的话还可以生成伪代码看看：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo2.png\" alt=\"\" /></p>\n\n<h3 id=\"\">巧变逻辑</h3>\n\n<p>之前分析了整个Welcome页面出现的逻辑其实是一个<strong>“如果……，就……”</strong>的判断，那么要想破解，也很容易。方法有两个，要么判断条件不成立，要么改变执行语句。显然，对于不熟悉汇编和逆向工程的新手而言，让判断条件不容易更加简单一些。注意到<font color = \"rgb(226,238,250)\"><code>je</code></font>指令之前有一个数字：<strong>00000001000cdfaf</strong>，它表示的是这条指令在虚拟内存空间中的地址。那么这个地址有什么用呢？</p>\n\n<h3 id=\"\">梳理思路</h3>\n\n<p>确实乍一看，获取指令的地址并没有用处。而且从开始到现在，一直在接触完全没接触过的东西，已经有点晕乎了。</p>\n\n<p>梳理一下到目前为止的思路，我们从<strong>license</strong>关键字树藤摸瓜，找到了<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法。分析出其中的关键一步是<font color = \"rgb(226,238,250)\"><code>je</code></font>指令，最后还知道了这条指令在虚拟内存中的地址。</p>\n\n<p>其实我们的目的非常简单，就是把<font color = \"rgb(226,238,250)\"><code>je</code></font>指令换成<font color = \"rgb(226,238,250)\"><code>jne</code></font>指令。到目前为止，只剩三步。</p>\n\n<ol>\n<li>算出<font color = \"rgb(226,238,250)\"><code>je</code></font>指令的二进制码。  </li>\n<li>算出<font color = \"rgb(226,238,250)\"><code>jne</code></font>指令的二进制码。  </li>\n<li>在二进制文件中，把算出<font color = \"rgb(226,238,250)\"><code>je</code></font>指令的二进制码换成算出<font color = \"rgb(226,238,250)\"><code>jne</code></font>指令的二进制码。</li>\n</ol>\n\n<p>幸好，gdb调试器能够为我们做前两步。免去了我们完全不熟悉的从汇编到二进制码转换的过程。gdb调试器有一个<font color = \"rgb(226,238,250)\"><code>x/x</code></font>命令，可以读取给定内存地址中的数据。</p>\n\n<p>我们知道，程序运行的过程，简单来说其实就是二进制码从硬盘加载进内存，然后从程序入口开始运行的过程。我们不是汇编器，不善于做静态的、从汇编码到二进制码的转换工作。但是gdb调试器允许我们动态地、逆向的从内存中找到二进制码。</p>\n\n<p>所以，距离成功还差最后一步！</p>\n\n<h3 id=\"\">二进制文件</h3>\n\n<p>所以，执行：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>x/x 0x00000001000cdfaf</code></font></p>\n\n<p>可以得到如下的结果：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>0x1000cdfaf &lt;_mh_execute_header+843695&gt;:    0x83480774</code></font></p>\n\n<p>这里的<strong>0x83480774</strong>就是16进制格式的程序二进制码。接下来就可以打开<strong>Hex friend</strong>软件对二进制码进行修改了。<strong>Hex friend</strong>把应用程序以16进制的形式展现出了，支持查找、替换功能。</p>\n\n<p>按下<font color = \"rgb(226,238,250)\"><code>Command + F</code></font>进行查找。</p>\n\n<p>特别需要注意点是<strong>字节序问题（Byte Order）</strong>，Intel处理器一般是以<strong>小端（Little endian）</strong>进行存储，而在硬盘上的二进制码，则是以<strong>大端（Big endian）</strong>存储。所谓的<strong>大端</strong>，就是把数字的最高位放在最前面，<strong>小端</strong>则是把最高位放在最后面。</p>\n\n<p>也就是说<strong>0x83480774</strong>作为一个<strong>小端</strong>数，它的<strong>大端</strong>形式应该是<strong>74074883</strong>,点击<strong>Replace &amp; Find</strong>按钮之后，很不幸的事情出现了：这个数字不止出现了一次。</p>\n\n<p>解决方案很简单，用同样的方法，看看下一条指令的的二进制码就可以了。执行：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>0x1000cdfb1 &lt;_mh_execute_header+843695&gt;:    0x83480774</code></font></p>\n\n<p>得到：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>0x1000cdfaf &lt;_mh_execute_header+843695&gt;:    0x08c48348</code></font></p>\n\n<p>用大端表示就是<strong>4883c408</strong>，这个数字的前四位和之前的数字的后四位刚好是相同的。这个不是巧合，因为不同的指令，二进制码长度不同。而gdb的<font color = \"rgb(226,238,250)\"><code>x/x</code></font>指令总是读取相同长度的内存中的数据。</p>\n\n<p>这一点并不影响破解Paw，但是如果想了解的非常透彻的话，可以用<font color = \"rgb(226,238,250)\"><code>otx</code></font>命令查看：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/otx.png\" alt=\"\" /></p>\n\n<p>可以看到其实<font color = \"rgb(226,238,250)\"><code>eq</code></font>指令的实际二进制码是<strong>7407</strong>。</p>\n\n<p>现在终于确定了要被替换的数字式<strong>74074883c408</strong>，这里面包含了<font color = \"rgb(226,238,250)\"><code>eq</code></font>指令的二进制码和接下来一些指令的二进制码。这些多余信息是为了唯一确定这组数的位置的。</p>\n\n<p><strong>“7407”</strong>由<strong>“74”</strong>和<strong>“07”</strong>两部分组成，查阅相关资料或者多找几个其他的<font color = \"rgb(226,238,250)\"><code>eq</code></font>指令和<font color = \"rgb(226,238,250)\"><code>enq</code></font>指令可以知道，<font color = \"rgb(226,238,250)\"><code>eq</code></font>指令的二进制码是<strong>“74”</strong>而<font color = \"rgb(226,238,250)\"><code>eq</code></font>指令的二进制码是<strong>“75”</strong>。</p>\n\n<p>所以用来替换的数应该就是<strong>“75074883c408”</strong>。在<strong>Hex friend</strong>中填写好相关数据后选择<strong>Replace</strong>并保存。如图所示：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/replace.png\" alt=\"\" /></p>\n\n<p>至此，整个破解的过程就完成了。其实细想一下，我们只是<strong>把一个4换成了5</strong>而已！</p>\n\n<h3 id=\"\">文件签名</h3>\n\n<p>用修改过后的二进制文件替换原来文件后，打开程序总是会立刻报错。如果在命令行中运行，还可以看到<strong>killed 9</strong>的提示。</p>\n\n<p>这是因为苹果为了保证软件的安全加入了<strong><font color=red>代码签名（CodeSignature）</font></strong>机制。在<strong>Contents</strong>文件夹下可以找到<strong>_CodeSignature</strong>文件夹和其中的<strong>CodeResources</strong>文件。任何对二进制文件的修改，都无法通过代码签名的检查。</p>\n\n<p>关于代码签名的具体解释，和操作过程，可以看这篇文章：</p>\n\n<blockquote>\n  <p><a href=\"http://forums.macnn.com/79/developer-center/355720/how-re-sign-apples-applications-once/\">《How to re-sign Apple's applications once they've been modified》</a></p>\n</blockquote>\n\n<p>文章把每一步都描述得非常透彻，我就不重述了。按照文章所描述的，建立好自己的签名证书后，只要执行这条命令：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>codesign -f -s 证书名 /Applications/PawCrack.app/Contents/MacOS/Paw</code></font></p>\n\n<p>其中证书名写自己创建的证书的名字，一切顺利的话，会得到这样的提示：\n<font color = \"rgb(226,238,250)\"><code>/Applications/PawCrack.app/Contents/MacOS/Paw: replacing existing signature</code></font></p>\n\n<p>代码重签名完成之后，就可以成功打开破解之后的App了。</p>\n\n<h3 id=\"\">尾巴</h3>\n\n<p>打开App之后我们可以发现，<strong>烦人</strong>的Welcome页不见了。因为反转了判断逻辑，所以不执行<font color = \"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法了。</p>\n\n<p>不过可惜的是，发送HTTP请求的按钮依然点击无效。应该是还有判断机制。只要按照之前的步骤再来一次就可以了。</p>\n\n<h1 id=\"\">总结</h1>\n\n<p>首先回顾一下整个破解过程。准备好工具之后，我们先从头文件里面搜索可以的方法名，再用反编译工具查看具体方法的汇编代码实现。结合基本的汇编语法和伪代码，了解整个方法的工作原理。最后修改if语句的逻辑从而完成破解。</p>\n\n<p>其实由于大部分针对功能的限制，都是基于<font color = \"rgb(226,238,250)\"><code>if else</code></font>语句进行判断的，也就是说对于相当多的软件，只要我们分析出它的逻辑，只需要把一个4改成5即可破解。</p>\n\n<p>整个破解过程，除了巩固了操作系统的基础知识之外，我觉得对于iOS engineer来说还有一些其他的收获：</p>\n\n<ol>\n<li>严格遵守<strong>“迪米特法则”</strong>，把不必要对外提供的在.m文件里定义、实现。这样不仅防止被class-dump扫描到，也能减轻与你合作的同事开发时的负担。  </li>\n<li>发布版本gcc编译时去掉<font color = \"rgb(226,238,250)\"><code>-g</code></font>参数。我猜测，正是由于Paw这么做了，导致我无法用gdb调试器加断点。因为找不到函数的符号名。  </li>\n<li>对于极为核心的部分，可以做适当的代码混淆。</li>\n</ol>\n\n<p>做到以上几点非常轻松，但是足以防止数量广大，但又技术一般的tinkerer(比如作者本人)的捣鼓了。</p>\n\n<h2 id=\"\">参考资料</h2>\n\n<ol>\n<li><a href=\"http://www.cnblogs.com/yishuiliunian/archive/2013/01/13/2858836.html\">《Giving gdb permission to control other processes》</a>  </li>\n<li><a href=\"http://kswizz.com/2011-01-16/hacking-mac-apps/\">《I Can Crack Your App With Just A Shell》</a>  </li>\n<li><a href=\"http://forums.macnn.com/79/developer-center/355720/how-re-sign-apples-applications-once/\">《How to re-sign Apple's applications once they've been modified》</a>  </li>\n<li><a href=\"http://www.mrspeaker.net/2011/01/06/mac-hacking/\">Beginning Mac Hacking</a></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-11T13:23:58.000Z","created_by":1,"updated_at":"2016-01-11T15:19:19.000Z","updated_by":1,"published_at":"2015-11-24T07:13:00.000Z","published_by":1},{"id":4,"uuid":"f33ab947-dc99-42d3-b104-f1427e37a08e","title":"找数组中出现次数超过一半的数字","slug":"arrayoccurmorethanhalf","markdown":"数组中有一个数字出现次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组`{1,2,3,2,2,2,5,4,2}`。\n\n由于数字2在数组中出现了5次，超过数组长度一半，因此输出2\n\n#问题分析\n\n首先想到的是，可以维护一个数据结构用来存储每个数字对应的出现次数。没遇到一个新的数字就去找这个数字是否出现过，如果出现过就加1.这种思路最简单，但是时间复杂度是O(n^2)。\n\n稍做优化，可以把数组排序，然后中位数一定是要找的数。这样的时间复杂度是O(nlogn)\n\n还可以再试着优化，第一种方法之所以需要O(n^2)的时间复杂度是因为找一个数是否已经出现过，需要O（n）的时间复杂度，拿能不能用Hash呢。很不幸的是也不行，因为不知道数字的取值范围，无法构造hash函数。否则的话，也不用hash，直接基数排序就解决问题了。\n\n似乎最快的算法就是排序的O（nlogn）了。如果还想优化，关键在于利用“**出现次数超过一半**”这个条件的数学性质。\n\n#理论基础\n\n为了后面的解释，我们首先定义：\n\n> 对于数组A，出现次数超过一半的数记为H(A)\n\n还是以之前的数组A`{1,2,3,2,2,2,5,4,2}`为例,首先有H(A) = 2，我们观察一下这个2的特点：\n\n如果把前两个数`1`和`2`去掉，剩下的数组A'是`{3,2,2,2,5,4,2}`，H(A')依然为2！\n\n更进一步，我们可以这么想，既然前两个数去掉之后不影响找出现次数超过数组长度的一半的数字，那么任意去掉相邻的两个数字也不影响呢。\n\n也就是说对于任意数组A和A去掉两个相邻数字的子数组A'是否都有:`H(A) = H(A')`\n\n很不幸，这个结论也不成立，因为如果在刚刚的数组A中去掉连续的两个2，就不对了。但是只要稍稍把结论修改一下就是成立的：\n\n> 对于任意数组A，去掉A中任意两个相邻但不相等的数，得到数组A',总有`H(A) = H(A')`\n\n结论很好证明：设H(A) = p,去掉的两个数中最多有一个p，由于p原来出现的次数大于n/2，现在p-1自然一定大于(n-2)/2。所以`H（A'）= p`。\n\n#编程实现\n\n有了刚刚的结论，再看这个数组就简单多了。只要把数组从头到尾遍历一遍，剔除相邻的不同的数就可以。比如数组中有一段是`{1，2，3，4}`，可以预见到，有可能是`{2，3}`先被比较，然后被剔除，接着是`{1，4}`变成相邻的，接着被剔除。\n\n为了避免反复循环，在一个循环里解决问题，自然而然的想到了一个数据结构——“栈”。\n\n只要对于数组中的每一个元素，如果栈为空或这个元素与栈顶元素相同，则这个元素入栈，否则栈顶元素出栈即可。这样一来，不相同的数即使不相邻，迟早也会一起出栈（可以把用来和栈顶做比较元素想象为先入栈再出栈）。\n\n所以这样一来，代码会非常简洁优雅：\n\n\n```C++\nint findNumber(std::vector<int> v){\n    std::stack<int> stack = std::stack<int>();\n    for (int i = 0; i < v.size(); ++i) {\n        if (stack.empty() || stack.top() == v[i]) {\n            stack.push(v[i]);\n        }\n        else{\n            stack.pop();\n        }\n    }\n    return stack.top();\n}\n```\n\n#正确性证明\n\n对于H(A)这个数来说，它想要出栈的唯一可能是遇到一个和它不同的数（之前说过，如果把H(A)和与它不同栈顶元素比较，可以理解为H(A)先进栈再出栈）。\n\n而在数组A中，剩下所有的数出现次数的和一定小于H(A)出现的次数。所以最终的栈里一定只剩下若干个H(A)。\n\n#拓展1——判断是否存在这样的数\n\n之前我们都是基于题干所说的，出现次数超过一半的数是存在的，这一前提进行分析。如果把题干改为：\n> 判断出现次数超过一半的数是否存在，如果存在则找出这个数\n\n这时候，我们依然用同样的方法先得到之前所说的栈。这个栈如果为空，则H(A)不存在（因为已经证明H(A)存在的话栈中的数都等于H(A)）。如果不为空，也只有可能有一种数字，不妨记为x。\n\nx不一定是要找的H(A)，因为H(A)不一定存在。我们只能说如果H(A)存在的话，`x = H(A)`。所以只要重新遍历数组，看看x的出现次数是否超过n/2即可。\n\n#拓展2——不少于一半\n\n看到一个非常有意思的问题，即把题干改为找到出现次数不少于一半的数。其实非常简单的方法是判断数组的第一个元素是否满足要求。如果不满足的话，剩下的n-1个数构成数组A'，则H(A')就是要找的数。相当于划归为了之前已经解决的问题。","html":"<p>数组中有一个数字出现次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组<code>{1,2,3,2,2,2,5,4,2}</code>。</p>\n\n<p>由于数字2在数组中出现了5次，超过数组长度一半，因此输出2</p>\n\n<h1 id=\"\">问题分析</h1>\n\n<p>首先想到的是，可以维护一个数据结构用来存储每个数字对应的出现次数。没遇到一个新的数字就去找这个数字是否出现过，如果出现过就加1.这种思路最简单，但是时间复杂度是O(n^2)。</p>\n\n<p>稍做优化，可以把数组排序，然后中位数一定是要找的数。这样的时间复杂度是O(nlogn)</p>\n\n<p>还可以再试着优化，第一种方法之所以需要O(n^2)的时间复杂度是因为找一个数是否已经出现过，需要O（n）的时间复杂度，拿能不能用Hash呢。很不幸的是也不行，因为不知道数字的取值范围，无法构造hash函数。否则的话，也不用hash，直接基数排序就解决问题了。</p>\n\n<p>似乎最快的算法就是排序的O（nlogn）了。如果还想优化，关键在于利用“<strong>出现次数超过一半</strong>”这个条件的数学性质。</p>\n\n<h1 id=\"\">理论基础</h1>\n\n<p>为了后面的解释，我们首先定义：</p>\n\n<blockquote>\n  <p>对于数组A，出现次数超过一半的数记为H(A)</p>\n</blockquote>\n\n<p>还是以之前的数组A<code>{1,2,3,2,2,2,5,4,2}</code>为例,首先有H(A) = 2，我们观察一下这个2的特点：</p>\n\n<p>如果把前两个数<code>1</code>和<code>2</code>去掉，剩下的数组A'是<code>{3,2,2,2,5,4,2}</code>，H(A')依然为2！</p>\n\n<p>更进一步，我们可以这么想，既然前两个数去掉之后不影响找出现次数超过数组长度的一半的数字，那么任意去掉相邻的两个数字也不影响呢。</p>\n\n<p>也就是说对于任意数组A和A去掉两个相邻数字的子数组A'是否都有:<code>H(A) = H(A')</code></p>\n\n<p>很不幸，这个结论也不成立，因为如果在刚刚的数组A中去掉连续的两个2，就不对了。但是只要稍稍把结论修改一下就是成立的：</p>\n\n<blockquote>\n  <p>对于任意数组A，去掉A中任意两个相邻但不相等的数，得到数组A',总有<code>H(A) = H(A')</code></p>\n</blockquote>\n\n<p>结论很好证明：设H(A) = p,去掉的两个数中最多有一个p，由于p原来出现的次数大于n/2，现在p-1自然一定大于(n-2)/2。所以<code>H（A'）= p</code>。</p>\n\n<h1 id=\"\">编程实现</h1>\n\n<p>有了刚刚的结论，再看这个数组就简单多了。只要把数组从头到尾遍历一遍，剔除相邻的不同的数就可以。比如数组中有一段是<code>{1，2，3，4}</code>，可以预见到，有可能是<code>{2，3}</code>先被比较，然后被剔除，接着是<code>{1，4}</code>变成相邻的，接着被剔除。</p>\n\n<p>为了避免反复循环，在一个循环里解决问题，自然而然的想到了一个数据结构——“栈”。</p>\n\n<p>只要对于数组中的每一个元素，如果栈为空或这个元素与栈顶元素相同，则这个元素入栈，否则栈顶元素出栈即可。这样一来，不相同的数即使不相邻，迟早也会一起出栈（可以把用来和栈顶做比较元素想象为先入栈再出栈）。</p>\n\n<p>所以这样一来，代码会非常简洁优雅：</p>\n\n<pre><code class=\"language-C++\">int findNumber(std::vector&lt;int&gt; v){  \n    std::stack&lt;int&gt; stack = std::stack&lt;int&gt;();\n    for (int i = 0; i &lt; v.size(); ++i) {\n        if (stack.empty() || stack.top() == v[i]) {\n            stack.push(v[i]);\n        }\n        else{\n            stack.pop();\n        }\n    }\n    return stack.top();\n}\n</code></pre>\n\n<h1 id=\"\">正确性证明</h1>\n\n<p>对于H(A)这个数来说，它想要出栈的唯一可能是遇到一个和它不同的数（之前说过，如果把H(A)和与它不同栈顶元素比较，可以理解为H(A)先进栈再出栈）。</p>\n\n<p>而在数组A中，剩下所有的数出现次数的和一定小于H(A)出现的次数。所以最终的栈里一定只剩下若干个H(A)。</p>\n\n<h1 id=\"1\">拓展1——判断是否存在这样的数</h1>\n\n<p>之前我们都是基于题干所说的，出现次数超过一半的数是存在的，这一前提进行分析。如果把题干改为：</p>\n\n<blockquote>\n  <p>判断出现次数超过一半的数是否存在，如果存在则找出这个数</p>\n</blockquote>\n\n<p>这时候，我们依然用同样的方法先得到之前所说的栈。这个栈如果为空，则H(A)不存在（因为已经证明H(A)存在的话栈中的数都等于H(A)）。如果不为空，也只有可能有一种数字，不妨记为x。</p>\n\n<p>x不一定是要找的H(A)，因为H(A)不一定存在。我们只能说如果H(A)存在的话，<code>x = H(A)</code>。所以只要重新遍历数组，看看x的出现次数是否超过n/2即可。</p>\n\n<h1 id=\"2\">拓展2——不少于一半</h1>\n\n<p>看到一个非常有意思的问题，即把题干改为找到出现次数不少于一半的数。其实非常简单的方法是判断数组的第一个元素是否满足要求。如果不满足的话，剩下的n-1个数构成数组A'，则H(A')就是要找的数。相当于划归为了之前已经解决的问题。</p>","image":"http://7xonij.com1.z0.glb.clouddn.com/ghost/1/e3/7161ecc907a4ee5f13214f2cac9d4.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-11T15:08:45.000Z","created_by":1,"updated_at":"2016-01-11T15:14:00.000Z","updated_by":1,"published_at":"2016-01-11T15:09:01.000Z","published_by":1}],"posts_tags":[{"id":2,"post_id":2,"tag_id":2,"sort_order":0},{"id":3,"post_id":3,"tag_id":3,"sort_order":0},{"id":4,"post_id":3,"tag_id":4,"sort_order":1},{"id":5,"post_id":4,"tag_id":5,"sort_order":0}],"roles":[{"id":1,"uuid":"9d69a637-ac1f-4338-ba1d-1cf3c292681f","name":"Administrator","description":"管理员","created_at":"2016-01-11T13:11:46.000Z","created_by":1,"updated_at":"2016-01-11T13:11:46.000Z","updated_by":1},{"id":2,"uuid":"2986361a-6621-48cd-8fd6-c87472f144b7","name":"Editor","description":"编辑","created_at":"2016-01-11T13:11:46.000Z","created_by":1,"updated_at":"2016-01-11T13:11:46.000Z","updated_by":1},{"id":3,"uuid":"8cfc6b70-6ad5-4386-b036-ea0eb9dc2a35","name":"Author","description":"作者","created_at":"2016-01-11T13:11:46.000Z","created_by":1,"updated_at":"2016-01-11T13:11:46.000Z","updated_by":1},{"id":4,"uuid":"f9da9a04-55f0-48b8-94f2-69e677654ef8","name":"Owner","description":"博客所有者","created_at":"2016-01-11T13:11:46.000Z","created_by":1,"updated_at":"2016-01-11T13:11:46.000Z","updated_by":1}],"roles_users":[{"id":1,"role_id":4,"user_id":1}],"settings":[{"id":1,"uuid":"77a95eaa-c73f-4130-b778-0310bdaa3741","key":"databaseVersion","value":"004","type":"core","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T13:11:48.000Z","updated_by":1},{"id":2,"uuid":"8a239d97-b6cb-4d6b-8c65-8c5f7b0f7dda","key":"dbHash","value":"e6007452-5c61-4a78-b237-66dcc8f88a8d","type":"core","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T13:11:48.000Z","updated_by":1},{"id":3,"uuid":"14cbf063-0af8-42ca-b446-cee130053cd0","key":"nextUpdateCheck","value":"1452604340","type":"core","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T13:12:20.000Z","updated_by":1},{"id":4,"uuid":"a250de0f-aea1-4499-9add-90379ef96728","key":"displayUpdateNotification","value":"0.7.0","type":"core","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T13:12:20.000Z","updated_by":1},{"id":5,"uuid":"bf76d7cb-f128-4976-8926-709e18adc0ad","key":"title","value":"kt's Dev","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":6,"uuid":"815cdb56-8d22-4f4f-b838-13fc9086670c","key":"description","value":"欢迎来到Kt的iOS开发小站，我是张星宇(@KtZhang)，目前在读大三，热爱iOS开发。","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":7,"uuid":"c6502fb4-3871-4c31-a341-6dd09f77fe93","key":"logo","value":"/content/images/2016/01/avator.jpg","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":8,"uuid":"2301d509-d56a-461f-b5ea-224935a47410","key":"cover","value":"/content/images/2016/01/background.jpg","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":9,"uuid":"a6654a11-d191-462f-aabc-81c395033240","key":"defaultLang","value":"zh_CN","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":10,"uuid":"5c161af8-f6f5-4fd7-9d32-231bef54773f","key":"postsPerPage","value":"5","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":11,"uuid":"e3ce8226-ea96-4bf2-9496-a02dbb339ee1","key":"forceI18n","value":"true","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":12,"uuid":"a47c3754-72bc-4d52-ab15-c056f0880667","key":"permalinks","value":"/:slug/","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":13,"uuid":"b0e2509d-3b7f-48b5-84f2-3d490f3677d9","key":"ghost_head","value":"","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":14,"uuid":"ca7889d3-5809-49cc-957d-2b6d57c5d790","key":"ghost_foot","value":"","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":15,"uuid":"48835feb-a53f-4285-bbb4-902db49883ff","key":"labs","value":"{}","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":16,"uuid":"ade3cf3c-fee3-453d-9ce3-d78c981bb18f","key":"navigation","value":"[{\"label\":\"首页\", \"url\":\"/\"}]","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":17,"uuid":"3f812b37-8e8a-43f2-80e1-acbf8355e02f","key":"activeApps","value":"[]","type":"app","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T13:11:48.000Z","updated_by":1},{"id":18,"uuid":"97f9a055-2bbf-4c9e-aea5-39e3dac1631e","key":"installedApps","value":"[]","type":"app","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T15:17:06.000Z","updated_by":1},{"id":19,"uuid":"d6a30726-ecb7-41f7-8304-9cecc634cc2e","key":"isPrivate","value":"false","type":"private","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":20,"uuid":"c873facc-cdda-4406-a54f-0d618baf1e82","key":"password","value":"","type":"private","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":21,"uuid":"bdd195a1-4a2e-44c9-aad2-a1a60bea1a17","key":"activeTheme","value":"vno","type":"theme","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1}],"tags":[{"id":5,"uuid":"0b25e63d-70c7-41ef-b0c5-1d48a2734dc0","name":"算法","slug":"suan-fa","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-11T15:09:47.000Z","created_by":1,"updated_at":"2016-01-11T15:09:47.000Z","updated_by":1},{"id":2,"uuid":"701c482c-15c7-4656-9c0f-ad0c55699b75","name":"基础知识","slug":"ji-chu-zhi-shi","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-11T13:39:34.000Z","created_by":1,"updated_at":"2016-01-11T13:39:34.000Z","updated_by":1},{"id":3,"uuid":"e3e59c47-2764-4832-ad85-aeec5af87808","name":"iOS","slug":"ios","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-11T13:48:17.000Z","created_by":1,"updated_at":"2016-01-11T13:48:17.000Z","updated_by":1},{"id":4,"uuid":"37a48c42-a716-4bcd-a157-f8fe9f85f518","name":"UI","slug":"ui","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-11T13:48:17.000Z","created_by":1,"updated_at":"2016-01-11T13:48:17.000Z","updated_by":1}],"users":[{"id":1,"uuid":"dd6c4295-3190-434c-9c55-76b6388a923c","name":"张星宇","slug":"zhang","password":"$2a$10$L4nMNQU4yqljOtjhWYKK/e35x/8.SnzeTHFlP8FPB2Mmvw3QgKyh6","email":"649395594@qq.com","image":null,"cover":null,"bio":null,"website":null,"location":null,"accessibility":null,"status":"active","language":"zh_CN","meta_title":null,"meta_description":null,"tour":null,"last_login":"2016-01-11T13:12:55.000Z","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T13:12:55.000Z","updated_by":1}]}}]}