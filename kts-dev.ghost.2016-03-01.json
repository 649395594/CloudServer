{"db":[{"meta":{"exported_on":1456845553802,"version":"004"},"data":{"app_fields":[],"app_settings":[],"apps":[],"client_trusted_domains":[],"permissions":[{"id":1,"uuid":"5ca3fca8-8693-4008-a8f5-6e0d5faffec4","name":"Export database","object_type":"db","action_type":"exportContent","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":2,"uuid":"aea8da83-4bf2-4593-8494-32ec371a7bba","name":"Import database","object_type":"db","action_type":"importContent","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":3,"uuid":"28a8dde6-668f-4c86-b10f-a99997f47fd5","name":"Delete all content","object_type":"db","action_type":"deleteAllContent","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":4,"uuid":"18777053-82b6-4ec0-b446-1137e2ca47e2","name":"Send mail","object_type":"mail","action_type":"send","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":5,"uuid":"c986d00a-af82-4655-b571-d161dad81b62","name":"Browse notifications","object_type":"notification","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":6,"uuid":"c359d160-00cf-4428-a219-13201cf426b3","name":"Add notifications","object_type":"notification","action_type":"add","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":7,"uuid":"40da3006-dae9-4c5d-b9d9-de18fc3f2230","name":"Delete notifications","object_type":"notification","action_type":"destroy","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":8,"uuid":"e5786f6a-05ca-4cea-bfb0-ea0bb2075f9f","name":"Browse posts","object_type":"post","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":9,"uuid":"6e2b543f-75b4-4f59-b174-baef304aaeca","name":"Read posts","object_type":"post","action_type":"read","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":10,"uuid":"9d932cf0-730d-4ffa-9623-ac72dc25f356","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":11,"uuid":"45bfd5dd-a818-43a2-b364-21e953cb87a2","name":"Add posts","object_type":"post","action_type":"add","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":12,"uuid":"0d16b514-eda9-4f03-bf32-2c054cc465d1","name":"Delete posts","object_type":"post","action_type":"destroy","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":13,"uuid":"e7431cfb-2b8c-460a-a51c-9b9224061301","name":"Browse settings","object_type":"setting","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":14,"uuid":"f34068ca-3c3b-4c70-9994-d35a1f92de1b","name":"Read settings","object_type":"setting","action_type":"read","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":15,"uuid":"80d638e1-ed0c-4cde-b5d6-87d42297001d","name":"Edit settings","object_type":"setting","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":16,"uuid":"934d33cd-7272-4e69-aa58-0eea09e47b18","name":"Generate slugs","object_type":"slug","action_type":"generate","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":17,"uuid":"76a5f527-08be-488e-9e4e-4c7a00ca827c","name":"Browse tags","object_type":"tag","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":18,"uuid":"8e8e49b2-e2dd-495d-9cb2-ded271c22367","name":"Read tags","object_type":"tag","action_type":"read","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":19,"uuid":"ec1816dc-47de-44e1-880d-ea5ab667a65d","name":"Edit tags","object_type":"tag","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":20,"uuid":"729db729-7736-453e-bac3-eaca1eea994f","name":"Add tags","object_type":"tag","action_type":"add","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":21,"uuid":"6828f3ef-840e-4582-89ef-c2ef152b3de7","name":"Delete tags","object_type":"tag","action_type":"destroy","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":22,"uuid":"74c272ee-fcfd-4265-9851-61b1c3fc7cad","name":"Browse themes","object_type":"theme","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":23,"uuid":"5a529ed7-7fb5-4b66-8097-a7820800b480","name":"Edit themes","object_type":"theme","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":24,"uuid":"ae1030a2-6237-4220-8f28-9b8325cc17d5","name":"Browse users","object_type":"user","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":25,"uuid":"3262073c-7691-42c7-b0dc-f88d2332e53e","name":"Read users","object_type":"user","action_type":"read","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":26,"uuid":"d8bc98f0-1519-437f-af7b-d5387bbfb689","name":"Edit users","object_type":"user","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":27,"uuid":"91c7c0cc-484e-4541-9b4c-ca2f56b7c74b","name":"Add users","object_type":"user","action_type":"add","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":28,"uuid":"34fdfa25-bf81-4af8-92d2-c75a78ae75d7","name":"Delete users","object_type":"user","action_type":"destroy","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":29,"uuid":"b845a56f-c996-4e8f-858f-0f52c13836f3","name":"Assign a role","object_type":"role","action_type":"assign","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":30,"uuid":"5d0c7f66-29c2-41cb-a49d-8ccd0a30ae58","name":"Browse roles","object_type":"role","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1}],"permissions_apps":[],"permissions_roles":[{"id":1,"role_id":1,"permission_id":1},{"id":2,"role_id":1,"permission_id":2},{"id":3,"role_id":1,"permission_id":3},{"id":4,"role_id":1,"permission_id":4},{"id":5,"role_id":1,"permission_id":5},{"id":6,"role_id":1,"permission_id":6},{"id":7,"role_id":1,"permission_id":7},{"id":8,"role_id":1,"permission_id":8},{"id":9,"role_id":1,"permission_id":9},{"id":10,"role_id":1,"permission_id":10},{"id":11,"role_id":1,"permission_id":11},{"id":12,"role_id":1,"permission_id":12},{"id":13,"role_id":1,"permission_id":13},{"id":14,"role_id":1,"permission_id":14},{"id":15,"role_id":1,"permission_id":15},{"id":16,"role_id":1,"permission_id":16},{"id":17,"role_id":1,"permission_id":17},{"id":18,"role_id":1,"permission_id":18},{"id":19,"role_id":1,"permission_id":19},{"id":20,"role_id":1,"permission_id":20},{"id":21,"role_id":1,"permission_id":21},{"id":22,"role_id":1,"permission_id":22},{"id":23,"role_id":1,"permission_id":23},{"id":24,"role_id":1,"permission_id":24},{"id":25,"role_id":1,"permission_id":25},{"id":26,"role_id":1,"permission_id":26},{"id":27,"role_id":1,"permission_id":27},{"id":28,"role_id":1,"permission_id":28},{"id":29,"role_id":1,"permission_id":29},{"id":30,"role_id":1,"permission_id":30},{"id":31,"role_id":2,"permission_id":8},{"id":32,"role_id":2,"permission_id":9},{"id":33,"role_id":2,"permission_id":10},{"id":34,"role_id":2,"permission_id":11},{"id":35,"role_id":2,"permission_id":12},{"id":36,"role_id":2,"permission_id":13},{"id":37,"role_id":2,"permission_id":14},{"id":38,"role_id":2,"permission_id":16},{"id":39,"role_id":2,"permission_id":17},{"id":40,"role_id":2,"permission_id":18},{"id":41,"role_id":2,"permission_id":19},{"id":42,"role_id":2,"permission_id":20},{"id":43,"role_id":2,"permission_id":21},{"id":44,"role_id":2,"permission_id":24},{"id":45,"role_id":2,"permission_id":25},{"id":46,"role_id":2,"permission_id":26},{"id":47,"role_id":2,"permission_id":27},{"id":48,"role_id":2,"permission_id":28},{"id":49,"role_id":2,"permission_id":29},{"id":50,"role_id":2,"permission_id":30},{"id":51,"role_id":3,"permission_id":8},{"id":52,"role_id":3,"permission_id":9},{"id":53,"role_id":3,"permission_id":11},{"id":54,"role_id":3,"permission_id":13},{"id":55,"role_id":3,"permission_id":14},{"id":56,"role_id":3,"permission_id":16},{"id":57,"role_id":3,"permission_id":17},{"id":58,"role_id":3,"permission_id":18},{"id":59,"role_id":3,"permission_id":20},{"id":60,"role_id":3,"permission_id":24},{"id":61,"role_id":3,"permission_id":25},{"id":62,"role_id":3,"permission_id":30}],"permissions_users":[],"posts":[{"id":3,"uuid":"27e88a8f-a60c-4161-8b53-2712da8e25d3","title":"UIView的生命周期总结","slug":"uiviewlifetime","markdown":"# 序言:\n\n1. `loadView`、`viewDidLoad`、`viewDidAppear`、<font color = \"rgb(226,238,250)\">`initWithNibName`</font>、<font color = \"rgb(226,238,250)\">`awakeFromNib`</font>等经常出现在UIViewController中的方法介绍。\n2. 这些方法分别用来作哪些工作，换言之，创建自定义的View时代码放到以上哪个方法中。\n3. 一个UIView的生命周期是怎样的。以上几个方法的调用顺序如何。\n4. 通过IB和代码加载视图，有什么区别\n\n**文章主要参考官方和文档和StackOVerFlow有关问题整理得出，由于水平有限，如有错误之处请及时与我联系。**\n\n# UIViewController\n#####视图层次和根视图\n\n每个视图控制器都维护一个<font color=red>**视图层次(view hierarchy)**</font>。\n\n因为每个视图都有自己的**子视图**，这个**视图层次**其实也可以理解为一棵树状的数据结构。而树的根节点，也就是根视图(root view)，在UIViewController中以<font color = \"rgb(226,238,250)\">`view`</font>属性。它可以被看做是其他所有子视图的容器。\n\n\n##### 视图的加载方式\n\nUIViewController采用懒加载的方式，也就是说第一次访问到<font color = \"rgb(226,238,250)\">`view`</font>属性时才会加载或创建它。由于视图由视图控制器管理，所以讨论视图的加载方式时，主要讨论视图控制器的加载方式。\n\n* 通过Storyboard加载：这是苹果推荐的方式，也是未来的趋势。\t\t\t\n\t\n\t 通过这种方式创建<font color = \"rgb(226,238,250)\">`UIViewController `</font>对象的话，首先生成<font color = \"rgb(226,238,250)\">`UIStoryboard`</font>类型的对象，然后调用这个对象的<font color = \"rgb(226,238,250)\">`instantiateViewControllerWithIdentifier: `</font>方法\n\n* 通过Nib文件加载：\n\n\tNib文件其实就是xib文件，Storyboard相当于是聚合了多个nib文件，并且添加了对不同的<font color = \"rgb(226,238,250)\">`UIViewController `</font>之间的segue和relationship的管理。但总的实现原理非常类似\n\t\n\t通过这种方式加载视图,需要调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>类的<font color = \"rgb(226,238,250)\">`initWithNibName:bundle:  `</font>方法\n* 通过loadview方法加载：\n\n\t这就是通过代码加载。这需要我们在<font color = \"rgb(226,238,250)\">`loadView`</font>\t方法中，通过编程创建自己的**视图层次**，并且把把根视图赋值给<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`view `</font>属性。\n\t\n因此，通过代码自定义View的时候，<font color = \"rgb(226,238,250)\">`loadView`</font>\t方法大概是这样的：\n\t\n```Objective-C\n- (void)loadView{\n\tself.view = [[XXXView alloc] init];\n}\n```\n\n\n###处理视图相关通知\n\n当视图的可见性发生变化时，视图控制器会自动调用一系列方法来响应变化。\n\n所有可能的状态、方法和状态之间的转换关系在下图中被明确标出。\n\n![](http://7xonij.com1.z0.glb.clouddn.com/UIViewLifeCircle/StateTransitionspng.png)\n\n可以看到每一个will方法都有自己对应的did方法。但是如果我们在will方法中开始一个任务，不仅要在对应的did方法中结束它，还要考虑到和这个will方法相反的那个will方法（注意到Appearing和Disappearing这两个状态是可以互相转化的）\n\n\n#在运行时展示View\n\nUIKit极大的简化了加载和展示View的过程，它大概会按照以下顺序执行一些任务：\n\n1. 通过storyboard文件中的信息实例化视图\n2. 连接outlet和action\n3. 把根视图赋值给<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`view `</font>属性（其实就是调用<font color = \"rgb(226,238,250)\">`loadView`</font>\t方法）\n4. 调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法。要注意，在调用方法前，</font>的<font color = \"rgb(226,238,250)\">`trait collecion`</font>为空且子视图的位置可能不正确\n5. 调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`viewDidLoad `</font>方法。\n\n此时已经完成了视图的加载工作，在展示到屏幕之前，还有以下几个步骤：\n\n6. 调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`viewWillAppear `</font>方法。\n7. 更新视图的布局\n8. 把视图展示到屏幕上\n9. 调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`viewDidAppear `</font>方法。\n\n##### awakeFromNib方法\n\n至此，第一个问题已经几乎解释完了，还剩一个<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法。\n\n我们已经知道，<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法被调用时，所有视图的outlet和action已经连接，但还没有被确定。这个方法可以算作是和视图控制器的实例化配合在一起使用的，因为有些需要根据用户喜好来进行设置的内容，无法存在storyboard中，所以可以在<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法中被加载进来。\n\n<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法在视图控制器的生命周期内只会被调用一次。因为它和视图控制器从nib文件中的解档密切相关，和view的关系却不大。\n\n#具体方法的解释\n\n\n#####loadView方法\n\n当执行到<font color = \"rgb(226,238,250)\">`loadView `</font>方法时，视图控制器已经从nib文件中被解档并创建好了，接下来的任务主要是对view进行初始化。\n\n<font color = \"rgb(226,238,250)\">`loadView `</font>方法在<font color = \"rgb(226,238,250)\">`UIViewController `</font>对象的<font color = \"rgb(226,238,250)\">`view `</font>属性被访问到且为空的时候调用。\n这是它与<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法的一个区别。假设我们在处理内存警告时释放<font color = \"rgb(226,238,250)\">`view `</font>属性（其实并不应该这么做，这里举个例子）：<font color = \"rgb(226,238,250)\">`self.view = nil `</font>。因此<font color = \"rgb(226,238,250)\">`loadView `</font>方法在视图控制器的生命周期内可能会被多次调用。\n\n这个方法不应该被直接调用，而是由系统自动调用。它会加载或创建一个view并把它赋值给<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`view `</font>属性。\n\n在创建view的过程中，首先会根据<font color = \"rgb(226,238,250)\">`nibName `</font>去找对应的Nib文件然后加载。如果<font color = \"rgb(226,238,250)\">`nibName `</font>为空，或找不到对应的Nib文件，则会创建一个空视图(这种情况一般是纯代码，也就是为什么说代码构建View的时候，要重写<font color = \"rgb(226,238,250)\">`loadView`</font>\t方法)。\n\n注意在重写<font color = \"rgb(226,238,250)\">`loadView`</font>方法的时候，不要调用父类的方法。\n\n\n###viewDidLoad方法\n<font color = \"rgb(226,238,250)\">`loadView`</font>方法执行完之后，就会执行<font color = \"rgb(226,238,250)\">`viewDidLoad `</font>方法。此时整个**视图层次(view hierarchy)**已经被放到内存中。\n\n无论是从nib文件加载，还是通过纯代码编写界面，<font color = \"rgb(226,238,250)\">`viewDidLoad `</font>方法都会执行。我们可以重写这个方法，对通过nib文件加载的view做一些其他的初始化工作。比如可以移除一些视图，修改约束，加载数据等。\n\n\n##### viewWillAppear和viewDidAppear方法\n\n在视图加载完成，并即将显示在屏幕上时，会调用<font color = \"rgb(226,238,250)\">`viewWillAppear `</font>方法，在这个方法里，可以改变当前屏幕方向或状态栏的风格等。\n\n当<font color = \"rgb(226,238,250)\">`viewWillAppear `</font>方法执行完后，系统会执行<font color = \"rgb(226,238,250)\">`viewDidAppear `</font>方法。在这个方法中，还可以对视图做一些关于展示效果方面的修改。\n\n\n#视图的生命历程\n\n到目前为止，我们已经了解了每个方法的作用，接下来就把整个流程梳理一遍。\n\n1. <font color = \"rgb(226,238,250)\">`-[ViewController  initWithCoder:]`或`-[ViewController  initWithNibName:Bundle]`</font>:首先从归档文件中加载<font color = \"rgb(226,238,250)\">`UIViewController `</font>对象。即使是纯代码，也会把nil作为参数传给后者。\n2. <font color = \"rgb(226,238,250)\">`-[UIView awakeFromNib]`</font>:作为第一个方法的助手，方便处理一些额外的设置。\n3. <font color = \"rgb(226,238,250)\">`-[ViewController loadView]`</font>:创建或加载一个view并把它赋值给<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`view `</font>属性\n4. <font color = \"rgb(226,238,250)\">`-[ViewController viewDidLoad]`</font>:此时整个**视图层次(view hierarchy)**已经被放到内存中，可以移除一些视图，修改约束，加载数据等\n5. <font color = \"rgb(226,238,250)\">`-[ViewController viewWillAppear:] `</font>:视图加载完成，并即将显示在屏幕上,还没有设置动画，可以改变当前屏幕方向或状态栏的风格等。\n6. <font color = \"rgb(226,238,250)\">`-[ViewController viewWillLayoutSubviews]`</font>：即将开始子视图位置布局\n7. <font color = \"rgb(226,238,250)\">`-[ViewController viewDidLayoutSubviews] `</font>：用于通知视图的位置布局已经完成\n8. <font color = \"rgb(226,238,250)\">`-[ViewController viewDidAppear:] `</font>：视图已经展示在屏幕上，可以对视图做一些关于展示效果方面的修改。\n9. <font color = \"rgb(226,238,250)\">`-[ViewController viewWillDisappear:]`</font>：视图即将消失\n10. <font color = \"rgb(226,238,250)\">`-[ViewController viewDidDisappear:]`</font>：视图已经消失\n\n如果考虑<font color = \"rgb(226,238,250)\">`UIViewController`</font>可能在某个时刻释放整个<font color = \"rgb(226,238,250)\">`view`</font>。那么再次加载视图时显然会从步骤3开始。因为此时的<font color = \"rgb(226,238,250)\">`UIViewController`</font>对象依然存在。\n\n#总结\n\n1. 只有init系列的方法,如<font color = \"rgb(226,238,250)\">`initWithNibName`</font>需要自己调用，其他方法如<font color = \"rgb(226,238,250)\">`loadView`</font>和<font color = \"rgb(226,238,250)\">`awakeFromNib`</font>则是系统自动调用。而<font color = \"rgb(226,238,250)\">`viewWill/Did`</font>系列的方法则类似于回调和通知，也会被自动调用。\n2. 纯代码写视图布局时需要注意，要手动调用<font color = \"rgb(226,238,250)\">`loadView`</font>方法，而且不要调用父类的<font color = \"rgb(226,238,250)\">`loadView`</font>方法。纯代码和用IB的区别仅存在于<font color = \"rgb(226,238,250)\">`loadView`</font>方法及其之前，编程时需要注意的也就是<font color = \"rgb(226,238,250)\">`loadView`</font>方法。\n3. 除了<font color = \"rgb(226,238,250)\">`initWithNibName`</font>和<font color = \"rgb(226,238,250)\">`awakeFromNib`</font>方法是处理视图控制器外，其他方法都是处理视图。这两个方法在视图控制器的生命周期里只会调用一次。\n\n\n#参考资料\n\n 1. [UIViewController Class Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/)\n 2. [View Controller Programming Guide for iOS](https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/DefiningYourSubclass.html#//apple_ref/doc/uid/TP40007457-CH7-SW1)\n 3. [NSObject UIKit Additions Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/NSObject_UIKitAdditions/index.html#//apple_ref/occ/instm/NSObject/awakeFromNib)\n 4. [Process of a UIViewController birth](http://stackoverflow.com/questions/5107604/can-somebody-explain-the-process-of-a-uiviewcontroller-birth-which-method-follo)\n 5. [Which should I use, -awakeFromNib or -viewDidLoad?](http://stackoverflow.com/questions/377202/which-should-i-use-awakefromnib-or-viewdidload)\n","html":"<h1 id=\"\">序言:</h1>\n\n<ol>\n<li><code>loadView</code>、<code>viewDidLoad</code>、<code>viewDidAppear</code>、<font color = \"rgb(226,238,250)\"><code>initWithNibName</code></font>、<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>等经常出现在UIViewController中的方法介绍。  </li>\n<li>这些方法分别用来作哪些工作，换言之，创建自定义的View时代码放到以上哪个方法中。  </li>\n<li>一个UIView的生命周期是怎样的。以上几个方法的调用顺序如何。  </li>\n<li>通过IB和代码加载视图，有什么区别</li>\n</ol>\n\n<p><strong>文章主要参考官方和文档和StackOVerFlow有关问题整理得出，由于水平有限，如有错误之处请及时与我联系。</strong></p>\n\n<h1 id=\"uiviewcontroller\">UIViewController</h1>\n\n<h5 id=\"\">视图层次和根视图</h5>\n\n<p>每个视图控制器都维护一个<font color=red><strong>视图层次(view hierarchy)</strong></font>。</p>\n\n<p>因为每个视图都有自己的<strong>子视图</strong>，这个<strong>视图层次</strong>其实也可以理解为一棵树状的数据结构。而树的根节点，也就是根视图(root view)，在UIViewController中以<font color = \"rgb(226,238,250)\"><code>view</code></font>属性。它可以被看做是其他所有子视图的容器。</p>\n\n<h5 id=\"\">视图的加载方式</h5>\n\n<p>UIViewController采用懒加载的方式，也就是说第一次访问到<font color = \"rgb(226,238,250)\"><code>view</code></font>属性时才会加载或创建它。由于视图由视图控制器管理，所以讨论视图的加载方式时，主要讨论视图控制器的加载方式。</p>\n\n<ul>\n<li><p>通过Storyboard加载：这是苹果推荐的方式，也是未来的趋势。            </p>\n\n<p>通过这种方式创建<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>对象的话，首先生成<font color = \"rgb(226,238,250)\"><code>UIStoryboard</code></font>类型的对象，然后调用这个对象的<font color = \"rgb(226,238,250)\"><code>instantiateViewControllerWithIdentifier:</code></font>方法</p></li>\n<li><p>通过Nib文件加载：</p>\n\n<p>Nib文件其实就是xib文件，Storyboard相当于是聚合了多个nib文件，并且添加了对不同的<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>之间的segue和relationship的管理。但总的实现原理非常类似</p>\n\n<p>通过这种方式加载视图,需要调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>类的<font color = \"rgb(226,238,250)\"><code>initWithNibName:bundle:</code></font>方法</p></li>\n<li><p>通过loadview方法加载：</p>\n\n<p>这就是通过代码加载。这需要我们在<font color = \"rgb(226,238,250)\"><code>loadView</code></font>  方法中，通过编程创建自己的<strong>视图层次</strong>，并且把把根视图赋值给<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性。</p></li>\n</ul>\n\n<p>因此，通过代码自定义View的时候，<font color = \"rgb(226,238,250)\"><code>loadView</code></font>    方法大概是这样的：</p>\n\n<pre><code class=\"language-Objective-C\">- (void)loadView{\n    self.view = [[XXXView alloc] init];\n}\n</code></pre>\n\n<h3 id=\"\">处理视图相关通知</h3>\n\n<p>当视图的可见性发生变化时，视图控制器会自动调用一系列方法来响应变化。</p>\n\n<p>所有可能的状态、方法和状态之间的转换关系在下图中被明确标出。</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/UIViewLifeCircle/StateTransitionspng.png\" alt=\"\" /></p>\n\n<p>可以看到每一个will方法都有自己对应的did方法。但是如果我们在will方法中开始一个任务，不仅要在对应的did方法中结束它，还要考虑到和这个will方法相反的那个will方法（注意到Appearing和Disappearing这两个状态是可以互相转化的）</p>\n\n<h1 id=\"view\">在运行时展示View</h1>\n\n<p>UIKit极大的简化了加载和展示View的过程，它大概会按照以下顺序执行一些任务：</p>\n\n<ol>\n<li>通过storyboard文件中的信息实例化视图  </li>\n<li>连接outlet和action  </li>\n<li>把根视图赋值给<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性（其实就是调用<font color = \"rgb(226,238,250)\"><code>loadView</code></font>    方法）  </li>\n<li>调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法。要注意，在调用方法前，</font>的<font color = \"rgb(226,238,250)\"><code>trait collecion</code></font>为空且子视图的位置可能不正确  </li>\n<li>调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>viewDidLoad</code></font>方法。</li>\n</ol>\n\n<p>此时已经完成了视图的加载工作，在展示到屏幕之前，还有以下几个步骤：</p>\n\n<ol>\n<li>调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>viewWillAppear</code></font>方法。  </li>\n<li>更新视图的布局  </li>\n<li>把视图展示到屏幕上  </li>\n<li>调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>viewDidAppear</code></font>方法。</li>\n</ol>\n\n<h5 id=\"awakefromnib\">awakeFromNib方法</h5>\n\n<p>至此，第一个问题已经几乎解释完了，还剩一个<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法。</p>\n\n<p>我们已经知道，<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法被调用时，所有视图的outlet和action已经连接，但还没有被确定。这个方法可以算作是和视图控制器的实例化配合在一起使用的，因为有些需要根据用户喜好来进行设置的内容，无法存在storyboard中，所以可以在<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法中被加载进来。</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法在视图控制器的生命周期内只会被调用一次。因为它和视图控制器从nib文件中的解档密切相关，和view的关系却不大。</p>\n\n<h1 id=\"\">具体方法的解释</h1>\n\n<h5 id=\"loadview\">loadView方法</h5>\n\n<p>当执行到<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法时，视图控制器已经从nib文件中被解档并创建好了，接下来的任务主要是对view进行初始化。</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法在<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>对象的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性被访问到且为空的时候调用。 <br />\n这是它与<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法的一个区别。假设我们在处理内存警告时释放<font color = \"rgb(226,238,250)\"><code>view</code></font>属性（其实并不应该这么做，这里举个例子）：<font color = \"rgb(226,238,250)\"><code>self.view = nil</code></font>。因此<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法在视图控制器的生命周期内可能会被多次调用。</p>\n\n<p>这个方法不应该被直接调用，而是由系统自动调用。它会加载或创建一个view并把它赋值给<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性。</p>\n\n<p>在创建view的过程中，首先会根据<font color = \"rgb(226,238,250)\"><code>nibName</code></font>去找对应的Nib文件然后加载。如果<font color = \"rgb(226,238,250)\"><code>nibName</code></font>为空，或找不到对应的Nib文件，则会创建一个空视图(这种情况一般是纯代码，也就是为什么说代码构建View的时候，要重写<font color = \"rgb(226,238,250)\"><code>loadView</code></font>    方法)。</p>\n\n<p>注意在重写<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法的时候，不要调用父类的方法。</p>\n\n<h3 id=\"viewdidload\">viewDidLoad方法</h3>\n\n<p><font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法执行完之后，就会执行<font color = \"rgb(226,238,250)\"><code>viewDidLoad</code></font>方法。此时整个<strong>视图层次(view hierarchy)</strong>已经被放到内存中。</p>\n\n<p>无论是从nib文件加载，还是通过纯代码编写界面，<font color = \"rgb(226,238,250)\"><code>viewDidLoad</code></font>方法都会执行。我们可以重写这个方法，对通过nib文件加载的view做一些其他的初始化工作。比如可以移除一些视图，修改约束，加载数据等。</p>\n\n<h5 id=\"viewwillappearviewdidappear\">viewWillAppear和viewDidAppear方法</h5>\n\n<p>在视图加载完成，并即将显示在屏幕上时，会调用<font color = \"rgb(226,238,250)\"><code>viewWillAppear</code></font>方法，在这个方法里，可以改变当前屏幕方向或状态栏的风格等。</p>\n\n<p>当<font color = \"rgb(226,238,250)\"><code>viewWillAppear</code></font>方法执行完后，系统会执行<font color = \"rgb(226,238,250)\"><code>viewDidAppear</code></font>方法。在这个方法中，还可以对视图做一些关于展示效果方面的修改。</p>\n\n<h1 id=\"\">视图的生命历程</h1>\n\n<p>到目前为止，我们已经了解了每个方法的作用，接下来就把整个流程梳理一遍。</p>\n\n<ol>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController  initWithCoder:]</code>或<code>-[ViewController  initWithNibName:Bundle]</code></font>:首先从归档文件中加载<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>对象。即使是纯代码，也会把nil作为参数传给后者。  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[UIView awakeFromNib]</code></font>:作为第一个方法的助手，方便处理一些额外的设置。  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController loadView]</code></font>:创建或加载一个view并把它赋值给<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewDidLoad]</code></font>:此时整个<strong>视图层次(view hierarchy)</strong>已经被放到内存中，可以移除一些视图，修改约束，加载数据等  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewWillAppear:]</code></font>:视图加载完成，并即将显示在屏幕上,还没有设置动画，可以改变当前屏幕方向或状态栏的风格等。  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewWillLayoutSubviews]</code></font>：即将开始子视图位置布局  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewDidLayoutSubviews]</code></font>：用于通知视图的位置布局已经完成  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewDidAppear:]</code></font>：视图已经展示在屏幕上，可以对视图做一些关于展示效果方面的修改。  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewWillDisappear:]</code></font>：视图即将消失  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewDidDisappear:]</code></font>：视图已经消失</li>\n</ol>\n\n<p>如果考虑<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>可能在某个时刻释放整个<font color = \"rgb(226,238,250)\"><code>view</code></font>。那么再次加载视图时显然会从步骤3开始。因为此时的<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>对象依然存在。</p>\n\n<h1 id=\"\">总结</h1>\n\n<ol>\n<li>只有init系列的方法,如<font color = \"rgb(226,238,250)\"><code>initWithNibName</code></font>需要自己调用，其他方法如<font color = \"rgb(226,238,250)\"><code>loadView</code></font>和<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>则是系统自动调用。而<font color = \"rgb(226,238,250)\"><code>viewWill/Did</code></font>系列的方法则类似于回调和通知，也会被自动调用。  </li>\n<li>纯代码写视图布局时需要注意，要手动调用<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法，而且不要调用父类的<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法。纯代码和用IB的区别仅存在于<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法及其之前，编程时需要注意的也就是<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法。  </li>\n<li>除了<font color = \"rgb(226,238,250)\"><code>initWithNibName</code></font>和<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法是处理视图控制器外，其他方法都是处理视图。这两个方法在视图控制器的生命周期里只会调用一次。</li>\n</ol>\n\n<h1 id=\"\">参考资料</h1>\n\n<ol>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/\">UIViewController Class Reference</a></li>\n<li><a href=\"https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/DefiningYourSubclass.html#//apple_ref/doc/uid/TP40007457-CH7-SW1\">View Controller Programming Guide for iOS</a></li>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/NSObject_UIKitAdditions/index.html#//apple_ref/occ/instm/NSObject/awakeFromNib\">NSObject UIKit Additions Reference</a></li>\n<li><a href=\"http://stackoverflow.com/questions/5107604/can-somebody-explain-the-process-of-a-uiviewcontroller-birth-which-method-follo\">Process of a UIViewController birth</a></li>\n<li><a href=\"http://stackoverflow.com/questions/377202/which-should-i-use-awakefromnib-or-viewdidload\">Which should I use, -awakeFromNib or -viewDidLoad?</a></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":"UIView的生命周期总结","meta_description":"","author_id":1,"created_at":"2016-01-11T13:40:39.000Z","created_by":1,"updated_at":"2016-02-29T08:04:19.000Z","updated_by":1,"published_at":"2015-11-26T13:44:00.000Z","published_by":1},{"id":2,"uuid":"2fe16a2a-f153-4000-8658-ca86765487aa","title":"修改一个数字破解Mac上的应用","slug":"xiu-gai-yi-ge-shu-zi-po-jie-macshang-de-ying-yong","markdown":"在某位大神的博客里看到了Mac一款非常好用的App，叫<font color=red>Paw</font>。\n\nPaw可以在Mac上模拟各种HTTP请求，可视化的管理HTTP Header、Parameters、Cookies等，还有一点非常出乎意料的功能是通过下载插件可以自动生成Swfit、OC、JS等多种语言的代码。\n\n然而Paw巨贵（200软妹币），而且破解版不好搜。于是寻思着自己动手解决需求，于是可怜的Paw成了实验对象。[先从这里下载原版app](https://luckymarmot.com/paw),一会儿教程中会逐步分析如何破解这个软件。\n\n由于在此之前我毫无逆向工程方面的经验，在看别人的介绍时各种不懂，深受折磨，所以我尽量用简单、详细的语言描述本次从零开始破解app之旅。作为参考，我用了**大约七个小时**的时间完成了此次破解（大量的时间浪费在找工具以及学习使用工具上，后面可以看到破解这个事情本身并不难）。在文章的最后会给出最新版Paw（2.2.6）的原版和破解版下载。\n\n由于水平有限，只是介绍了基本的逆向工程知识，算是自己的学习笔记，也希望向更多的和我一样还只是菜鸟的程序员科普一些逆向工程的基本知识，同时督促自己平时在Coding过程中的注意代码规范和安全。\n\n#知识储备\n\n想要破解app，首先自己得开发过app，至少了解一些基本的命令行操作，源代码、汇编代码和二进制码的基本定义。如果这些基本要求有某一点不满足，那么整个过程会是非常痛苦的。\n\n#工具准备\n破解Paw用到的工具主要有以下几个。\n\n+ <font color=red>homebrew</font> —— 不知道这个的估计都不好意思说自己是用Mac的程序员。\n+ [<font color=red>Hopper Disassembler</font>](http://pan.baidu.com/s/1bn94SDx) —— 反编译工具，根据可执行文件反编译出汇编码。\n+ [<font color=red>Class-dump</font>](http://stevenygard.com/projects/class-dump/) —— 逆向工程的入门级工具，导出一个App的某些信息。\n+ <font color = red>otx</font> —— 国外某位大神的博客上用的一个工具，我也说不出明确的用处。通过`brew install --HEAD homebrew/head-only/otx`命令安装。\n+ [<font color=red>Hex friend</font>](http://ridiculousfish.com/hexfiend/) —— 二进制文件编辑器，要用这个修改原来的二进制文件。\n+ <font color=red>gdb</font> —— 著名的调试器，用lldb也行。通过`brew install gdb`命令安装。\n\n#Begin cracking\n\n###找到破解点\n要破解App当然要明白自己为什么要破解它，它哪一点限制了我们，首先运行原版的Paw。可以看到如下界面:\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/real-paw-welcome.png)\n\n这个Welcome界面非常讨厌，由于它的存在，我们不能点击程序主界面。而想要关掉这个Welcome界面，只有两个方法，选择**Try Paw**按钮获得30天试用期或点击**Register License**按钮输入自己的License。\n\n因此我们的目的以及非常明确了——**<font color = red>关闭这个Welcome页面</font>**\n\n###初探Paw\n\n既然要破解这个App，免不了要去了解这个App的结构。现在我们手上只有在Applications文件夹下的Paw.app这一个文件。突破口在于**Paw.app/Contents/MacOs/Paw**这个可执行的二进制文件。我们以后的操作，绝大多数时候是与它打交道。在“**应用程序**”文件夹下，右键Paw，选择“**显示包内容**”就可以看到这个二进制文件了\n\n这时候，第一个工具——<font color = \"rgb(226,238,250)\">`class-dump`</font>出场了。由于篇幅所限，我就不介绍这个工具的具体配置方法了。可以参考这篇文章\n\n>\t[<font color = red>使用class-dump导出其他应用头文件</font>](http://www.jianshu.com/p/6a6ce18f998e)\n\n我们先用<font color = \"rgb(226,238,250)\">`class-dump`</font>导出Paw的头文件看看，在终端中执行命令：\n\n<font color = \"rgb(226,238,250)\">`class-dump -H /Applications/PawReal.app/Contents/MacOS/Paw -o /Users/你的用户名/Desktop/classdump`</font>,\n\n换上你的用户名，等运行结束之后，在桌面上可以看到一个叫<font color = \"rgb(226,238,250)\">`classdump`</font>的文件夹。不要被里面密密麻麻的文件吓到，这就是这个app所有的头文件了。\n\n###换位思考，变通思路\n\n接下来怎么找我们需要的信息呢，要想一个一个看过去，即使头文件里面只有方法和变量的定义，也是不现实的。好在<font color = \"rgb(226,238,250)\">`class-dump`</font>还有别的功能。执行命令：\n\n<font color = \"rgb(226,238,250)\">`class-dump -f license /Applications/PawReal.app/Contents/MacOS/Paw`</font>\n\n可以找到头文件中所有和license有关的部分。\n\n会什么要找license呢，这个就需要猜了。既然这个软件需要注册码，并且Welcome界面有一个**Register License**按钮，一定会有一部分代码是用来管理证书（License）相关的。让我们站在开发者的角度上想，如果要遵守命名规范，那么头文件中也许会有**License**关键字的身影。\n\n当然，这只是猜想，如果针对**License**关键字的查找结果不理想的话，我们还可以换一些关键字，比如**Register**、**Validate**等。\n\n不过好在我们通过<font color = \"rgb(226,238,250)\">`class-dump`</font>发现了一些线索，如图所示：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/class-dump-license.png)\n\n在图中，我们发现了一个比较有价值的类:<font color = \"rgb(226,238,250)\">`LMWelcomeViewController`</font>\n\n###合理猜想，趁胜追击\n\n发现<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>这个用来管理Welcome页面的类之后，我们打开头文件看看里面的函数。很“巧”地，里面有一组函数，都是以<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>开头。直觉告诉我们，这个用来显示Welcome页面的方法，很有可能就是解决问题的关键。\n\n故技重施，再看一看<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>这个函数的信息。运行：\n\n<font color = \"rgb(226,238,250)\">`class-dump -f showWelcome /Applications/PawCrack.app/Contents/MacOS/Paw`</font>\n\n可以看到这样的结果：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/class-dump-showWelcome.png)\n\n这就基本上印证了之前的猜想:<font color = \"rgb(226,238,250)\">`LMApplicationDelegate.m`</font>中的代码在程序启动时执行，通过某种方式判断用户是否已注册，**如果没有的话**，就调用<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>这个函数，同时把<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>类的实例对象作为参数，这个对象再执行自己的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法，**展示Welcome页面**\n\n当然，这样的分析很可能是错的。因为判断是否注册这个逻辑并不一定在<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>中进行，也可以放在<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>里。但无论如何，注意到黑体字部分连起来也是一段话，整个过程其实是一个**“如果……，就……”**的逻辑。\n\n记住这个逻辑，一会儿我们会根据这个逻辑做一些修改！\n\n###细看函数实现\n\n我们已经知道<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法可能是解决问题的关键，接下来我们就来看看这个方法到底是怎么实现的。\n\n打开Hopper Disassembler，把**MacOS**文件夹下的**Paw**二进制文件拖入其中，开始分析。Hopper Disassembler可以根据二进制文件反汇编成汇编代码。刚打开的时候，这个软件是这个样子：\n\n![](http://images.bestswifter.com/AppCrack/Hopper-Disassembler-introduction.png)\n\n在这个软件中看到的东西往往非常奇葩，和任何一种高级编程语言都不同。这种汇编语言给新手的阅读造成了极大的障碍，好在有一些注释，也可以生成伪代码，辅助我们阅读。我几乎不太能看懂汇编语言，所以尽量避免过多的研究他们。\n\n在左边的Labels标签下搜索我们感兴趣的内容，比如刚刚说的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法。\n\n可以分别看到在<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>和<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>中<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法的实现：\n\n![<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>](http://images.bestswifter.com/AppCrack/search-1.png)\n\n![<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>](http://images.bestswifter.com/AppCrack/search-2.png)\n\n<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>中的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法非常简单，根据绿色部分的注释可以猜到调用了参数的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法。或者我们可以选中这段汇编代码，点右上角的![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo-icon.png)图标生成伪代码。\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo1.png)\n\n<font color = \"rgb(226,238,250)\">`LMWelcomeViewController `</font>中的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法比较复杂。\n\n之前的图片上可以看到两个汇编指令分别是：<font color = \"rgb(226,238,250)\">`je `</font>和<font color = \"rgb(226,238,250)\">`ret `</font>\n\n<font color = \"rgb(226,238,250)\">`je`</font>是**\"jump euqal\"**的缩写，表示如果相等，则跳转到某个地址。所以我们可以在<font color = \"rgb(226,238,250)\">`je `</font>的上面一行看到<font color = \"rgb(226,238,250)\">`cmp `</font>指令。与<font color = \"rgb(226,238,250)\">`je `</font>相对应的就是<font color = \"rgb(226,238,250)\">`jne `</font>，表示**\"jump not euqal\"**\n\n<font color = \"rgb(226,238,250)\">`ret`</font>顾名思义就是**return的缩写了**，表示函数在这里返回。\n\n其实在这里我们已经可以大概了解这个</font>中的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法的实现了。进行了一个判断，如果城里就返回，否则就进行下面一段操作，而根据右侧绿色提示，我们看到了**“可怕”**的<font color =\"rgb(226,238,250)\">`showWindow`</font>方法，这个方法没有在头文件里面看到，估计就是一个 私有方法了。\n\n如果不放心的话还可以生成伪代码看看：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo2.png)\n\n###巧变逻辑\n\n之前分析了整个Welcome页面出现的逻辑其实是一个**“如果……，就……”**的判断，那么要想破解，也很容易。方法有两个，要么判断条件不成立，要么改变执行语句。显然，对于不熟悉汇编和逆向工程的新手而言，让判断条件不容易更加简单一些。注意到<font color = \"rgb(226,238,250)\">`je`</font>指令之前有一个数字：**00000001000cdfaf**，它表示的是这条指令在虚拟内存空间中的地址。那么这个地址有什么用呢？\n\n###梳理思路\n\n确实乍一看，获取指令的地址并没有用处。而且从开始到现在，一直在接触完全没接触过的东西，已经有点晕乎了。\n\n梳理一下到目前为止的思路，我们从**license**关键字树藤摸瓜，找到了<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法。分析出其中的关键一步是<font color = \"rgb(226,238,250)\">`je`</font>指令，最后还知道了这条指令在虚拟内存中的地址。\n\n其实我们的目的非常简单，就是把<font color = \"rgb(226,238,250)\">`je`</font>指令换成<font color = \"rgb(226,238,250)\">`jne`</font>指令。到目前为止，只剩三步。\n\n1. 算出<font color = \"rgb(226,238,250)\">`je`</font>指令的二进制码。\n2. 算出<font color = \"rgb(226,238,250)\">`jne`</font>指令的二进制码。\n3. 在二进制文件中，把算出<font color = \"rgb(226,238,250)\">`je`</font>指令的二进制码换成算出<font color = \"rgb(226,238,250)\">`jne`</font>指令的二进制码。\n\n幸好，gdb调试器能够为我们做前两步。免去了我们完全不熟悉的从汇编到二进制码转换的过程。gdb调试器有一个<font color = \"rgb(226,238,250)\">`x/x`</font>命令，可以读取给定内存地址中的数据。\n\n我们知道，程序运行的过程，简单来说其实就是二进制码从硬盘加载进内存，然后从程序入口开始运行的过程。我们不是汇编器，不善于做静态的、从汇编码到二进制码的转换工作。但是gdb调试器允许我们动态地、逆向的从内存中找到二进制码。\n\n所以，距离成功还差最后一步！\n\n###二进制文件\n\n所以，执行：\n\n<font color = \"rgb(226,238,250)\">`x/x 0x00000001000cdfaf`</font>\n\n可以得到如下的结果：\n\n<font color = \"rgb(226,238,250)\">`0x1000cdfaf <_mh_execute_header+843695>:\t0x83480774`</font>\n\n这里的**0x83480774**就是16进制格式的程序二进制码。接下来就可以打开**Hex friend**软件对二进制码进行修改了。**Hex friend**把应用程序以16进制的形式展现出了，支持查找、替换功能。\n\n按下<font color = \"rgb(226,238,250)\">`Command + F`</font>进行查找。\n\n特别需要注意点是**字节序问题（Byte Order）**，Intel处理器一般是以**小端（Little endian）**进行存储，而在硬盘上的二进制码，则是以**大端（Big endian）**存储。所谓的**大端**，就是把数字的最高位放在最前面，**小端**则是把最高位放在最后面。\n\n也就是说**0x83480774**作为一个**小端**数，它的**大端**形式应该是**74074883**,点击**Replace & Find**按钮之后，很不幸的事情出现了：这个数字不止出现了一次。\n\n解决方案很简单，用同样的方法，看看下一条指令的的二进制码就可以了。执行：\n\n<font color = \"rgb(226,238,250)\">`0x1000cdfb1 <_mh_execute_header+843695>:\t0x83480774`</font>\n\n得到：\n\n<font color = \"rgb(226,238,250)\">`0x1000cdfaf <_mh_execute_header+843695>:\t0x08c48348`</font>\n\n用大端表示就是**4883c408**，这个数字的前四位和之前的数字的后四位刚好是相同的。这个不是巧合，因为不同的指令，二进制码长度不同。而gdb的<font color = \"rgb(226,238,250)\">`x/x`</font>指令总是读取相同长度的内存中的数据。\n\n这一点并不影响破解Paw，但是如果想了解的非常透彻的话，可以用<font color = \"rgb(226,238,250)\">`otx`</font>命令查看：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/otx.png)\n\n可以看到其实<font color = \"rgb(226,238,250)\">`eq`</font>指令的实际二进制码是**7407**。\n\n现在终于确定了要被替换的数字式**74074883c408**，这里面包含了<font color = \"rgb(226,238,250)\">`eq`</font>指令的二进制码和接下来一些指令的二进制码。这些多余信息是为了唯一确定这组数的位置的。\n\n**“7407”**由**“74”**和**“07”**两部分组成，查阅相关资料或者多找几个其他的<font color = \"rgb(226,238,250)\">`je`</font>指令和<font color = \"rgb(226,238,250)\">`jne`</font>指令可以知道，<font color = \"rgb(226,238,250)\">`je`</font>指令的二进制码是**“74”**而<font color = \"rgb(226,238,250)\">`jne`</font>指令的二进制码是**“75”**。\n\n所以用来替换的数应该就是**“75074883c408”**。在**Hex friend**中填写好相关数据后选择**Replace**并保存。如图所示：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/replace.png)\n\n\n至此，整个破解的过程就完成了。其实细想一下，我们只是**把一个4换成了5**而已！\n\n###文件签名\n\n用修改过后的二进制文件替换原来文件后，打开程序总是会立刻报错。如果在命令行中运行，还可以看到**killed 9**的提示。\n\n这是因为苹果为了保证软件的安全加入了**<font color=red>代码签名（CodeSignature）</font>**机制。在**Contents**文件夹下可以找到**_CodeSignature**文件夹和其中的**CodeResources**文件。任何对二进制文件的修改，都无法通过代码签名的检查。\n\n关于代码签名的具体解释，和操作过程，可以看这篇文章：\n> [《How to re-sign Apple's applications once they've been modified》](http://forums.macnn.com/79/developer-center/355720/how-re-sign-apples-applications-once/)\n\n文章把每一步都描述得非常透彻，我就不重述了。按照文章所描述的，建立好自己的签名证书后，只要执行这条命令：\n\n\n<font color = \"rgb(226,238,250)\">`codesign -f -s 证书名 /Applications/PawCrack.app/Contents/MacOS/Paw`</font>\n\n其中证书名写自己创建的证书的名字，一切顺利的话，会得到这样的提示：\n<font color = \"rgb(226,238,250)\">`/Applications/PawCrack.app/Contents/MacOS/Paw: replacing existing signature`</font>\n\n代码重签名完成之后，就可以成功打开破解之后的App了。\n\n###尾巴\n\n打开App之后我们可以发现，**烦人**的Welcome页不见了。因为反转了判断逻辑，所以不执行<font color = \"rgb(226,238,250)\">`showWelcomeWindow`</font>方法了。\n\n不过可惜的是，发送HTTP请求的按钮依然点击无效。应该是还有判断机制。只要按照之前的步骤再来一次就可以了。\n\n#总结\n\n首先回顾一下整个破解过程。准备好工具之后，我们先从头文件里面搜索可以的方法名，再用反编译工具查看具体方法的汇编代码实现。结合基本的汇编语法和伪代码，了解整个方法的工作原理。最后修改if语句的逻辑从而完成破解。\n\n其实由于大部分针对功能的限制，都是基于<font color = \"rgb(226,238,250)\">`if else`</font>语句进行判断的，也就是说对于相当多的软件，只要我们分析出它的逻辑，只需要把一个4改成5即可破解。\n\n整个破解过程，除了巩固了操作系统的基础知识之外，我觉得对于iOS engineer来说还有一些其他的收获：\n\n1. 严格遵守**“迪米特法则”**，把不必要对外提供的在.m文件里定义、实现。这样不仅防止被class-dump扫描到，也能减轻与你合作的同事开发时的负担。\n2. 发布版本gcc编译时去掉<font color = \"rgb(226,238,250)\">`-g`</font>参数。我猜测，正是由于Paw这么做了，导致我无法用gdb调试器加断点。因为找不到函数的符号名。\n3. 对于极为核心的部分，可以做适当的代码混淆。\n\n做到以上几点非常轻松，但是足以防止数量广大，但又技术一般的tinkerer(比如作者本人)的捣鼓了。\n\n##参考资料\n1.\t[《Giving gdb permission to control other processes》](http://www.cnblogs.com/yishuiliunian/archive/2013/01/13/2858836.html)\n2.\t[《I Can Crack Your App With Just A Shell》](http://kswizz.com/2011-01-16/hacking-mac-apps)\n3.\t[《How to re-sign Apple's applications once they've been modified》](http://forums.macnn.com/79/developer-center/355720/how-re-sign-apples-applications-once/)\n4.\t[Beginning Mac Hacking](http://www.mrspeaker.net/2011/01/06/mac-hacking/)","html":"<p>在某位大神的博客里看到了Mac一款非常好用的App，叫<font color=red>Paw</font>。</p>\n\n<p>Paw可以在Mac上模拟各种HTTP请求，可视化的管理HTTP Header、Parameters、Cookies等，还有一点非常出乎意料的功能是通过下载插件可以自动生成Swfit、OC、JS等多种语言的代码。</p>\n\n<p>然而Paw巨贵（200软妹币），而且破解版不好搜。于是寻思着自己动手解决需求，于是可怜的Paw成了实验对象。<a href=\"https://luckymarmot.com/paw\">先从这里下载原版app</a>,一会儿教程中会逐步分析如何破解这个软件。</p>\n\n<p>由于在此之前我毫无逆向工程方面的经验，在看别人的介绍时各种不懂，深受折磨，所以我尽量用简单、详细的语言描述本次从零开始破解app之旅。作为参考，我用了<strong>大约七个小时</strong>的时间完成了此次破解（大量的时间浪费在找工具以及学习使用工具上，后面可以看到破解这个事情本身并不难）。在文章的最后会给出最新版Paw（2.2.6）的原版和破解版下载。</p>\n\n<p>由于水平有限，只是介绍了基本的逆向工程知识，算是自己的学习笔记，也希望向更多的和我一样还只是菜鸟的程序员科普一些逆向工程的基本知识，同时督促自己平时在Coding过程中的注意代码规范和安全。</p>\n\n<h1 id=\"\">知识储备</h1>\n\n<p>想要破解app，首先自己得开发过app，至少了解一些基本的命令行操作，源代码、汇编代码和二进制码的基本定义。如果这些基本要求有某一点不满足，那么整个过程会是非常痛苦的。</p>\n\n<h1 id=\"\">工具准备</h1>\n\n<p>破解Paw用到的工具主要有以下几个。</p>\n\n<ul>\n<li><font color=red>homebrew</font> —— 不知道这个的估计都不好意思说自己是用Mac的程序员。</li>\n<li><a href=\"http://pan.baidu.com/s/1bn94SDx\"><font color=red>Hopper Disassembler</font></a> —— 反编译工具，根据可执行文件反编译出汇编码。</li>\n<li><a href=\"http://stevenygard.com/projects/class-dump/\"><font color=red>Class-dump</font></a> —— 逆向工程的入门级工具，导出一个App的某些信息。</li>\n<li><font color = red>otx</font> —— 国外某位大神的博客上用的一个工具，我也说不出明确的用处。通过<code>brew install --HEAD homebrew/head-only/otx</code>命令安装。</li>\n<li><a href=\"http://ridiculousfish.com/hexfiend/\"><font color=red>Hex friend</font></a> —— 二进制文件编辑器，要用这个修改原来的二进制文件。</li>\n<li><font color=red>gdb</font> —— 著名的调试器，用lldb也行。通过<code>brew install gdb</code>命令安装。</li>\n</ul>\n\n<h1 id=\"begincracking\">Begin cracking</h1>\n\n<h3 id=\"\">找到破解点</h3>\n\n<p>要破解App当然要明白自己为什么要破解它，它哪一点限制了我们，首先运行原版的Paw。可以看到如下界面:</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/real-paw-welcome.png\" alt=\"\" /></p>\n\n<p>这个Welcome界面非常讨厌，由于它的存在，我们不能点击程序主界面。而想要关掉这个Welcome界面，只有两个方法，选择<strong>Try Paw</strong>按钮获得30天试用期或点击<strong>Register License</strong>按钮输入自己的License。</p>\n\n<p>因此我们的目的以及非常明确了——<strong><font color = red>关闭这个Welcome页面</font></strong></p>\n\n<h3 id=\"paw\">初探Paw</h3>\n\n<p>既然要破解这个App，免不了要去了解这个App的结构。现在我们手上只有在Applications文件夹下的Paw.app这一个文件。突破口在于<strong>Paw.app/Contents/MacOs/Paw</strong>这个可执行的二进制文件。我们以后的操作，绝大多数时候是与它打交道。在“<strong>应用程序</strong>”文件夹下，右键Paw，选择“<strong>显示包内容</strong>”就可以看到这个二进制文件了</p>\n\n<p>这时候，第一个工具——<font color = \"rgb(226,238,250)\"><code>class-dump</code></font>出场了。由于篇幅所限，我就不介绍这个工具的具体配置方法了。可以参考这篇文章</p>\n\n<blockquote>\n  <p><a href=\"http://www.jianshu.com/p/6a6ce18f998e\"><font color = red>使用class-dump导出其他应用头文件</font></a></p>\n</blockquote>\n\n<p>我们先用<font color = \"rgb(226,238,250)\"><code>class-dump</code></font>导出Paw的头文件看看，在终端中执行命令：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>class-dump -H /Applications/PawReal.app/Contents/MacOS/Paw -o /Users/你的用户名/Desktop/classdump</code></font>,</p>\n\n<p>换上你的用户名，等运行结束之后，在桌面上可以看到一个叫<font color = \"rgb(226,238,250)\"><code>classdump</code></font>的文件夹。不要被里面密密麻麻的文件吓到，这就是这个app所有的头文件了。</p>\n\n<h3 id=\"\">换位思考，变通思路</h3>\n\n<p>接下来怎么找我们需要的信息呢，要想一个一个看过去，即使头文件里面只有方法和变量的定义，也是不现实的。好在<font color = \"rgb(226,238,250)\"><code>class-dump</code></font>还有别的功能。执行命令：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>class-dump -f license /Applications/PawReal.app/Contents/MacOS/Paw</code></font></p>\n\n<p>可以找到头文件中所有和license有关的部分。</p>\n\n<p>会什么要找license呢，这个就需要猜了。既然这个软件需要注册码，并且Welcome界面有一个<strong>Register License</strong>按钮，一定会有一部分代码是用来管理证书（License）相关的。让我们站在开发者的角度上想，如果要遵守命名规范，那么头文件中也许会有<strong>License</strong>关键字的身影。</p>\n\n<p>当然，这只是猜想，如果针对<strong>License</strong>关键字的查找结果不理想的话，我们还可以换一些关键字，比如<strong>Register</strong>、<strong>Validate</strong>等。</p>\n\n<p>不过好在我们通过<font color = \"rgb(226,238,250)\"><code>class-dump</code></font>发现了一些线索，如图所示：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/class-dump-license.png\" alt=\"\" /></p>\n\n<p>在图中，我们发现了一个比较有价值的类:<font color = \"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font></p>\n\n<h3 id=\"\">合理猜想，趁胜追击</h3>\n\n<p>发现<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>这个用来管理Welcome页面的类之后，我们打开头文件看看里面的函数。很“巧”地，里面有一组函数，都是以<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>开头。直觉告诉我们，这个用来显示Welcome页面的方法，很有可能就是解决问题的关键。</p>\n\n<p>故技重施，再看一看<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>这个函数的信息。运行：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>class-dump -f showWelcome /Applications/PawCrack.app/Contents/MacOS/Paw</code></font></p>\n\n<p>可以看到这样的结果：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/class-dump-showWelcome.png\" alt=\"\" /></p>\n\n<p>这就基本上印证了之前的猜想:<font color = \"rgb(226,238,250)\"><code>LMApplicationDelegate.m</code></font>中的代码在程序启动时执行，通过某种方式判断用户是否已注册，<strong>如果没有的话</strong>，就调用<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>这个函数，同时把<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>类的实例对象作为参数，这个对象再执行自己的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法，<strong>展示Welcome页面</strong></p>\n\n<p>当然，这样的分析很可能是错的。因为判断是否注册这个逻辑并不一定在<font color = \"rgb(226,238,250)\"><code>LMApplicationDelegate</code></font>中进行，也可以放在<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>里。但无论如何，注意到黑体字部分连起来也是一段话，整个过程其实是一个<strong>“如果……，就……”</strong>的逻辑。</p>\n\n<p>记住这个逻辑，一会儿我们会根据这个逻辑做一些修改！</p>\n\n<h3 id=\"\">细看函数实现</h3>\n\n<p>我们已经知道<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法可能是解决问题的关键，接下来我们就来看看这个方法到底是怎么实现的。</p>\n\n<p>打开Hopper Disassembler，把<strong>MacOS</strong>文件夹下的<strong>Paw</strong>二进制文件拖入其中，开始分析。Hopper Disassembler可以根据二进制文件反汇编成汇编代码。刚打开的时候，这个软件是这个样子：</p>\n\n<p><img src=\"http://images.bestswifter.com/AppCrack/Hopper-Disassembler-introduction.png\" alt=\"\" /></p>\n\n<p>在这个软件中看到的东西往往非常奇葩，和任何一种高级编程语言都不同。这种汇编语言给新手的阅读造成了极大的障碍，好在有一些注释，也可以生成伪代码，辅助我们阅读。我几乎不太能看懂汇编语言，所以尽量避免过多的研究他们。</p>\n\n<p>在左边的Labels标签下搜索我们感兴趣的内容，比如刚刚说的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法。</p>\n\n<p>可以分别看到在<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>和<font color = \"rgb(226,238,250)\"><code>LMApplicationDelegate</code></font>中<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法的实现：</p>\n\n<p><img src=\"http://images.bestswifter.com/AppCrack/search-1.png\" alt=\"<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>\" /></p>\n\n<p><img src=\"http://images.bestswifter.com/AppCrack/search-2.png\" alt=\"<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>\" /></p>\n\n<p><font color = \"rgb(226,238,250)\"><code>LMApplicationDelegate</code></font>中的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法非常简单，根据绿色部分的注释可以猜到调用了参数的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法。或者我们可以选中这段汇编代码，点右上角的<img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo-icon.png\" alt=\"\" title=\"\" />图标生成伪代码。</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo1.png\" alt=\"\" /></p>\n\n<p><font color = \"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>中的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法比较复杂。</p>\n\n<p>之前的图片上可以看到两个汇编指令分别是：<font color = \"rgb(226,238,250)\"><code>je</code></font>和<font color = \"rgb(226,238,250)\"><code>ret</code></font></p>\n\n<p><font color = \"rgb(226,238,250)\"><code>je</code></font>是<strong>\"jump euqal\"</strong>的缩写，表示如果相等，则跳转到某个地址。所以我们可以在<font color = \"rgb(226,238,250)\"><code>je</code></font>的上面一行看到<font color = \"rgb(226,238,250)\"><code>cmp</code></font>指令。与<font color = \"rgb(226,238,250)\"><code>je</code></font>相对应的就是<font color = \"rgb(226,238,250)\"><code>jne</code></font>，表示<strong>\"jump not euqal\"</strong></p>\n\n<p><font color = \"rgb(226,238,250)\"><code>ret</code></font>顾名思义就是<strong>return的缩写了</strong>，表示函数在这里返回。</p>\n\n<p>其实在这里我们已经可以大概了解这个</font>中的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法的实现了。进行了一个判断，如果城里就返回，否则就进行下面一段操作，而根据右侧绿色提示，我们看到了<strong>“可怕”</strong>的<font color =\"rgb(226,238,250)\"><code>showWindow</code></font>方法，这个方法没有在头文件里面看到，估计就是一个 私有方法了。</p>\n\n<p>如果不放心的话还可以生成伪代码看看：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo2.png\" alt=\"\" /></p>\n\n<h3 id=\"\">巧变逻辑</h3>\n\n<p>之前分析了整个Welcome页面出现的逻辑其实是一个<strong>“如果……，就……”</strong>的判断，那么要想破解，也很容易。方法有两个，要么判断条件不成立，要么改变执行语句。显然，对于不熟悉汇编和逆向工程的新手而言，让判断条件不容易更加简单一些。注意到<font color = \"rgb(226,238,250)\"><code>je</code></font>指令之前有一个数字：<strong>00000001000cdfaf</strong>，它表示的是这条指令在虚拟内存空间中的地址。那么这个地址有什么用呢？</p>\n\n<h3 id=\"\">梳理思路</h3>\n\n<p>确实乍一看，获取指令的地址并没有用处。而且从开始到现在，一直在接触完全没接触过的东西，已经有点晕乎了。</p>\n\n<p>梳理一下到目前为止的思路，我们从<strong>license</strong>关键字树藤摸瓜，找到了<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法。分析出其中的关键一步是<font color = \"rgb(226,238,250)\"><code>je</code></font>指令，最后还知道了这条指令在虚拟内存中的地址。</p>\n\n<p>其实我们的目的非常简单，就是把<font color = \"rgb(226,238,250)\"><code>je</code></font>指令换成<font color = \"rgb(226,238,250)\"><code>jne</code></font>指令。到目前为止，只剩三步。</p>\n\n<ol>\n<li>算出<font color = \"rgb(226,238,250)\"><code>je</code></font>指令的二进制码。  </li>\n<li>算出<font color = \"rgb(226,238,250)\"><code>jne</code></font>指令的二进制码。  </li>\n<li>在二进制文件中，把算出<font color = \"rgb(226,238,250)\"><code>je</code></font>指令的二进制码换成算出<font color = \"rgb(226,238,250)\"><code>jne</code></font>指令的二进制码。</li>\n</ol>\n\n<p>幸好，gdb调试器能够为我们做前两步。免去了我们完全不熟悉的从汇编到二进制码转换的过程。gdb调试器有一个<font color = \"rgb(226,238,250)\"><code>x/x</code></font>命令，可以读取给定内存地址中的数据。</p>\n\n<p>我们知道，程序运行的过程，简单来说其实就是二进制码从硬盘加载进内存，然后从程序入口开始运行的过程。我们不是汇编器，不善于做静态的、从汇编码到二进制码的转换工作。但是gdb调试器允许我们动态地、逆向的从内存中找到二进制码。</p>\n\n<p>所以，距离成功还差最后一步！</p>\n\n<h3 id=\"\">二进制文件</h3>\n\n<p>所以，执行：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>x/x 0x00000001000cdfaf</code></font></p>\n\n<p>可以得到如下的结果：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>0x1000cdfaf &lt;_mh_execute_header+843695&gt;:    0x83480774</code></font></p>\n\n<p>这里的<strong>0x83480774</strong>就是16进制格式的程序二进制码。接下来就可以打开<strong>Hex friend</strong>软件对二进制码进行修改了。<strong>Hex friend</strong>把应用程序以16进制的形式展现出了，支持查找、替换功能。</p>\n\n<p>按下<font color = \"rgb(226,238,250)\"><code>Command + F</code></font>进行查找。</p>\n\n<p>特别需要注意点是<strong>字节序问题（Byte Order）</strong>，Intel处理器一般是以<strong>小端（Little endian）</strong>进行存储，而在硬盘上的二进制码，则是以<strong>大端（Big endian）</strong>存储。所谓的<strong>大端</strong>，就是把数字的最高位放在最前面，<strong>小端</strong>则是把最高位放在最后面。</p>\n\n<p>也就是说<strong>0x83480774</strong>作为一个<strong>小端</strong>数，它的<strong>大端</strong>形式应该是<strong>74074883</strong>,点击<strong>Replace &amp; Find</strong>按钮之后，很不幸的事情出现了：这个数字不止出现了一次。</p>\n\n<p>解决方案很简单，用同样的方法，看看下一条指令的的二进制码就可以了。执行：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>0x1000cdfb1 &lt;_mh_execute_header+843695&gt;:    0x83480774</code></font></p>\n\n<p>得到：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>0x1000cdfaf &lt;_mh_execute_header+843695&gt;:    0x08c48348</code></font></p>\n\n<p>用大端表示就是<strong>4883c408</strong>，这个数字的前四位和之前的数字的后四位刚好是相同的。这个不是巧合，因为不同的指令，二进制码长度不同。而gdb的<font color = \"rgb(226,238,250)\"><code>x/x</code></font>指令总是读取相同长度的内存中的数据。</p>\n\n<p>这一点并不影响破解Paw，但是如果想了解的非常透彻的话，可以用<font color = \"rgb(226,238,250)\"><code>otx</code></font>命令查看：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/otx.png\" alt=\"\" /></p>\n\n<p>可以看到其实<font color = \"rgb(226,238,250)\"><code>eq</code></font>指令的实际二进制码是<strong>7407</strong>。</p>\n\n<p>现在终于确定了要被替换的数字式<strong>74074883c408</strong>，这里面包含了<font color = \"rgb(226,238,250)\"><code>eq</code></font>指令的二进制码和接下来一些指令的二进制码。这些多余信息是为了唯一确定这组数的位置的。</p>\n\n<p><strong>“7407”</strong>由<strong>“74”</strong>和<strong>“07”</strong>两部分组成，查阅相关资料或者多找几个其他的<font color = \"rgb(226,238,250)\"><code>je</code></font>指令和<font color = \"rgb(226,238,250)\"><code>jne</code></font>指令可以知道，<font color = \"rgb(226,238,250)\"><code>je</code></font>指令的二进制码是<strong>“74”</strong>而<font color = \"rgb(226,238,250)\"><code>jne</code></font>指令的二进制码是<strong>“75”</strong>。</p>\n\n<p>所以用来替换的数应该就是<strong>“75074883c408”</strong>。在<strong>Hex friend</strong>中填写好相关数据后选择<strong>Replace</strong>并保存。如图所示：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/replace.png\" alt=\"\" /></p>\n\n<p>至此，整个破解的过程就完成了。其实细想一下，我们只是<strong>把一个4换成了5</strong>而已！</p>\n\n<h3 id=\"\">文件签名</h3>\n\n<p>用修改过后的二进制文件替换原来文件后，打开程序总是会立刻报错。如果在命令行中运行，还可以看到<strong>killed 9</strong>的提示。</p>\n\n<p>这是因为苹果为了保证软件的安全加入了<strong><font color=red>代码签名（CodeSignature）</font></strong>机制。在<strong>Contents</strong>文件夹下可以找到<strong>_CodeSignature</strong>文件夹和其中的<strong>CodeResources</strong>文件。任何对二进制文件的修改，都无法通过代码签名的检查。</p>\n\n<p>关于代码签名的具体解释，和操作过程，可以看这篇文章：</p>\n\n<blockquote>\n  <p><a href=\"http://forums.macnn.com/79/developer-center/355720/how-re-sign-apples-applications-once/\">《How to re-sign Apple's applications once they've been modified》</a></p>\n</blockquote>\n\n<p>文章把每一步都描述得非常透彻，我就不重述了。按照文章所描述的，建立好自己的签名证书后，只要执行这条命令：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>codesign -f -s 证书名 /Applications/PawCrack.app/Contents/MacOS/Paw</code></font></p>\n\n<p>其中证书名写自己创建的证书的名字，一切顺利的话，会得到这样的提示：\n<font color = \"rgb(226,238,250)\"><code>/Applications/PawCrack.app/Contents/MacOS/Paw: replacing existing signature</code></font></p>\n\n<p>代码重签名完成之后，就可以成功打开破解之后的App了。</p>\n\n<h3 id=\"\">尾巴</h3>\n\n<p>打开App之后我们可以发现，<strong>烦人</strong>的Welcome页不见了。因为反转了判断逻辑，所以不执行<font color = \"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法了。</p>\n\n<p>不过可惜的是，发送HTTP请求的按钮依然点击无效。应该是还有判断机制。只要按照之前的步骤再来一次就可以了。</p>\n\n<h1 id=\"\">总结</h1>\n\n<p>首先回顾一下整个破解过程。准备好工具之后，我们先从头文件里面搜索可以的方法名，再用反编译工具查看具体方法的汇编代码实现。结合基本的汇编语法和伪代码，了解整个方法的工作原理。最后修改if语句的逻辑从而完成破解。</p>\n\n<p>其实由于大部分针对功能的限制，都是基于<font color = \"rgb(226,238,250)\"><code>if else</code></font>语句进行判断的，也就是说对于相当多的软件，只要我们分析出它的逻辑，只需要把一个4改成5即可破解。</p>\n\n<p>整个破解过程，除了巩固了操作系统的基础知识之外，我觉得对于iOS engineer来说还有一些其他的收获：</p>\n\n<ol>\n<li>严格遵守<strong>“迪米特法则”</strong>，把不必要对外提供的在.m文件里定义、实现。这样不仅防止被class-dump扫描到，也能减轻与你合作的同事开发时的负担。  </li>\n<li>发布版本gcc编译时去掉<font color = \"rgb(226,238,250)\"><code>-g</code></font>参数。我猜测，正是由于Paw这么做了，导致我无法用gdb调试器加断点。因为找不到函数的符号名。  </li>\n<li>对于极为核心的部分，可以做适当的代码混淆。</li>\n</ol>\n\n<p>做到以上几点非常轻松，但是足以防止数量广大，但又技术一般的tinkerer(比如作者本人)的捣鼓了。</p>\n\n<h2 id=\"\">参考资料</h2>\n\n<ol>\n<li><a href=\"http://www.cnblogs.com/yishuiliunian/archive/2013/01/13/2858836.html\">《Giving gdb permission to control other processes》</a>  </li>\n<li><a href=\"http://kswizz.com/2011-01-16/hacking-mac-apps\">《I Can Crack Your App With Just A Shell》</a>  </li>\n<li><a href=\"http://forums.macnn.com/79/developer-center/355720/how-re-sign-apples-applications-once/\">《How to re-sign Apple's applications once they've been modified》</a>  </li>\n<li><a href=\"http://www.mrspeaker.net/2011/01/06/mac-hacking/\">Beginning Mac Hacking</a></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-11T13:23:58.000Z","created_by":1,"updated_at":"2016-02-29T07:49:08.000Z","updated_by":1,"published_at":"2015-11-24T07:13:00.000Z","published_by":1},{"id":16,"uuid":"619569fe-4bd1-424a-ac77-d798dce51d1f","title":"print(\"hello, world!\")","slug":"helloworld","markdown":"在进行调试的时候，我们有时会把一个变量自身，或其成员属性的值打印出来以检查是否符合我们的预期。或者干脆简单一些，直接`print`整个变量，不同于C++的`std::cout`，如果你调用`print(value)`，不管`value`是什么类型程序都不会报错，而且大多数时候你能获得比较全面的、可读的输出结果。如果这引起了你对`print`函数的好奇，接下来我们共同研究以下几个问题：\n\n1. `print(\"hello, world\")`和`print(123)`的执行原理\n2. `Streamable`和`OutputStreamType`协议\n3. `CustomStringConvertible`和`CustomDebugStringConvertible`协议\n4. 为什么字符串的初始化函数中可以传入任何类型的参数\n5. `print`和`debugPrint`函数的区别\n\n本文的demo地址在[我的github](https://github.com/bestswifter/MySampleCode/tree/master/Streamable)，读者可以下载下来自行把玩，如果觉得有收获还望给个star鼓励一下。\n\n# 字符串输出\n\n有笑话说每个程序员的第一行代码都是这样的：\n\n```swift\nprint(\"Hello, world!\")\n```\n\n先别急着笑，您还真不一定知道这行代码是怎么运行的。\n\n首先，`print`函数支持重载，Swift定义了两个版本的实现。其中简化版的`print`将输出流指定为标准输出流，我们忽略playground相关的代码，来看一下上面那一行代码中的`print`函数是怎么定义的，在不改编代码逻辑的前提下，为了方便阅读，我做了一些排版方面的修改：\n\n```swift\n// 简化版print函数，通过terminator = \"\\n\"可知print函数默认会换行\npublic func print(items: Any..., separator: String = \" \", terminator: String = \"\\n\") {\n\tvar output = _Stdout()\t\n\t_print(items, separator: separator, terminator: terminator, toStream: &output)\n}\n\n// 完整版print函数，参数中多了一个outPut参数\npublic func print<Target: OutputStreamType>(items: Any...,separator: String = \" \",\n  terminator: String = \"\\n\",\n  inout toStream output: Target) {\n  _print(items, separator: separator, terminator: terminator, toStream: &output)\n}\n```\n\n两者的区别在于完整版`print`函数需要我们提供`output`参数，而我们之前调用的显然是第一个`print`函数，在函数中创建了`output`变量。这两个版本的`print`函数都会调用内部的`_print`函数。\n\n通过这一层封装，真正的核心操作在`_print`函数中，而对外则提供了一个重载的，高度可定制的`print`函数，接下来我们看一看这个内部的`_print`函数是如何实现的，为了阅读方便我删去了读写锁相关的代码，它的核心步骤如下：\n\n```swift\ninternal func _print<Target: OutputStreamType>(\n  items: [Any],\n  separator: String = \" \",\n  terminator: String = \"\\n\",\n  inout toStream output: Target\n) {\n  var prefix = \"\"\n  for item in items {\n    output.write(prefix)\t// 每两个元素之间用separator分隔开\n    _print_unlocked(item, &output)\t// 这句话其实是核心\n    prefix = separator\n  }\n  output.write(terminator)\t// 终止符，通常是\"\\n\"\n}\n```\n\n这个函数有四个参数，显然第一个和第四个参数是关键。也就是说我们只关心要输出什么内容，以及输出到哪里，至于输出格式则是次要的。所以`_print`函数主要是处理了输出格式问题，以及把第一个参数(它是一个数组)中的每个元素，都写入到`output`中。通过目前的分析，我们已经明白文章开头的`print(\"Hello, world!\")`其实等价于：\n\n```swift\nvar output = _Stdout()\t// 这个是output的默认值\noutput.write(\"\")\t// prefix是一个空字符串\n_print_unlocked(\"Hello, world!\", &output)\n```\n\n你一定已经很好奇这个反复出现的`output`是什么了，其实在整个`print`函数的执行过程中`OutputStreamType `类型的`output`变量都是关键。另一个略显奇怪的点在于，同样是输出空字符串和`\"Hello, world!\"`，竟然调用了两个不同的方法。接下来我们首先分析`OutputStreamType `协议以及其中的`write`方法，再来研究为什么还需要`_print_unlocked`函数：\n\n```swift\npublic protocol OutputStreamType {\n  mutating func write(string: String)\n}\n\ninternal struct _Stdout : OutputStreamType {\n  mutating func write(string: String) {\n    for c in string.utf8 {\n      _swift_stdlib_putchar(Int32(c))\n    }\n  }\n}\n```\n\n简单来说，`OutputStreamType`表示了一个输出流，也就说你要把字符串输出到哪里。如果你有过C++编程经验，那你一定知道`#include <iostream>`这个库文件，以及`cout`和`cin`这两个标准输出、输入流。\n\n在`OutputStreamType `协议中定义了`write`方法，它表示这个流是如何把字符串写入的。比如标准输出流`_Stdout `的处理方法就是在字符串的UFT-8编码视图下，把每个字符转换成Int32类型，然后调用`_swift_stdlib_putchar `函数。这个函数在`LibcShims.cpp`文件中定义，可以理解为一个适配器，它内部会直接调用C语言的`putchar`函数。\n\nOk，已经分析到C语言的`putchar`函数了，再往下就不必说了(我也不懂`putchar`是怎么实现的)。现在我们把思路拉回到另一个把字符串打印到屏幕上的函数——`_print_unlocked `上，它的定义如下：\n\n```swift\ninternal func _print_unlocked<T, TargetStream : OutputStreamType>(value: T, inout _ target: TargetStream) {\n  if case let streamableObject as Streamable = value {\n    streamableObject.writeTo(&target)\n    return\n  }\n\n  if case let printableObject as CustomStringConvertible = value {\n    printableObject.description.writeTo(&target)\n    return\n  }\n\n  if case let debugPrintableObject as CustomDebugStringConvertible = value {\n    debugPrintableObject.debugDescription.writeTo(&target)\n    return\n  }\n\n  _adHocPrint(value, &target, isDebugPrint: false)\n}\n```\n\n在调用最后的`_adHocPrint`方法之前，进行了三次判断，分别判断被输出的`value`(在我们的例子中是字符串\"Hello, world!\")是否实现了指定的协议，如果是，则调用该协议下的`writeTo`方法并提前返回，而最后的`_adHocPrint`方法则用于确保，任何类型都有默认的输出。稍后我会通过一个具体的例子来解释。\n\n这里我们主要看一下`Streamable`协议，关于另外两个协议的介绍您可以参考[《第七章——字符串(字符串调试)》](http://www.jianshu.com/p/8b39e9c84462)。`Streamable`协议定义如下：\n\n```swift\n/// A source of text streaming operations.  `Streamable` instances can\n/// be written to any *output stream*.\npublic protocol Streamable {\n  func writeTo<Target : OutputStreamType>(inout target: Target)\n}\n```\n\n根据官方文档的定义，`Streamable`类型的变量可以被写入任何一个输出流中。`String`类型实现了`Streamable`协议，定义如下：\n\n```swift\nextension String : Streamable {\n  /// Write a textual representation of `self` into `target`.\n  public func writeTo<Target : OutputStreamType>(inout target: Target) {\n    target.write(self)\n  }\n}\n```\n\n看到这里，`print(\"Hello, wrold!\")`的完整流程就算全部讲完了。还留下一个小疑问，同样是输出字符串，为什么不直接调用`write`函数，而是大费周章的调用`_print_unlocked `函数？这个问题在讲解完`_adHocPrint `函数的原理后您就能理解了。\n\n需要强调一点，千万不要把`writeTo`函数和`write`函数弄混淆了。`write`函数是输出流，也就是`OutputStreamType `类型的方法，用于输出内容到屏幕上，比如`_Stdout `的`write`函数实际上会调用C语言的`putchar`函数。\n\n`writeTo`函数是可输出类型(也就是实现了`Streamable `协议)的方法，它用于将该类型的内容输出到某个流中。\n\n输出字符串的过程中，这两个函数的关系可以这样简单理解：\n\n> 内容.writeTo(输出流) = 输出流.write(内容)，一般在前者内部执行后者\n\n字符串不仅是可输出类型(Streamable)，同时自身也是输出流(OutputStreamType)，它是Swift标准库中的唯一一个输出流，定义如下：\n\n```swift\nextension String : OutputStreamType {\n  public mutating func write(other: String) {\n    self += other\n  }\n}\n```\n\n在输出字符串的过程中，我们用到的是字符串可输出的特性，至于它作为输出流的特性，会在稍后的例子中进行讲解。\n\n# 实战\n\n接下来我们通过几个例子来加深对`print`函数执行过程的理解。\n\n### 一、字符串输出\n\n还是用文章开头的例子，我们分析一下其背后的步骤：\n\n```swift\nprint(\"Hello, world!\")\n```\n\n1. 调用不带`output`参数的`print`函数，函数内部生成`_Stdout `类型的输出流，调用`_print`函数\n2. 在`_print`函数中国处理完`separator`和`terminator `等格式参数后，调用`_print_unlocked `函数处理字符串输出。\n3. 在`_print_unlocked `函数的第一个if判断中，因为字符串类型实现了`Streamable `协议，所以调用字符串的`writeTo`函数，写入到输出流中。\n4. 根据字符串的`writeTo`函数的定义，它在内部调用了输出流的`write`方法\n5. `_Stdout`在其`write`方法中，调用C语言的`putchar`函数输出字符串的每个字符\n\n### 二、标准库中其他类型输出\n\n如果要输出一个整数，似乎和输出字符串一样简单，但其实并不是这样，我们来分析一下具体的步骤：\n\n```swift\nprint(123)\n```\n\n1. 调用不带`output`参数的`print`函数，函数内部生成`_Stdout `类型的输出流，调用`_print`函数\n2. 在`_print`函数中国处理完`separator`和`terminator `等格式参数后，调用`_print_unlocked `函数处理字符串输出。\n3. 截止目前和输出字符串一致，不过Int类型(以及其他除了和字符有关的几乎所有类型)没有实现`Streamable `协议，它实现的是`CustomStringConvertible `协议，定义了自己的计算属性`description`\n4. `description`是一个字符串类型，调用字符串的`writeTo`方法此前已经讲过，就不再赘述了。\n\n\n### 三、自定义结构体输出\n\n我们简单的定义一个结构体，然后尝试使用`print`方法输出这个结构体：\n\n```swift\nstruct Person {\n    var name: String\n    private var age: Int\n    \n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n}\n\nlet kt = Person(name: \"kt\", age: 21)\nprint(kt)\t// 输出结果：PersonStruct(name: \"kt\", age: 21)\n```\n\n输出结果的可读性非常好，我们来分析一下其中的步骤：\n\n1. 调用不带`output`参数的`print`函数，函数内部生成`_Stdout `类型的输出流，调用`_print`函数\n2. 在`_print`函数中国处理完`separator`和`terminator `等格式参数后，调用`_print_unlocked `函数处理字符串输出。\n3. 在`_print_unlocked `中调用`_adHocPrint `函数\n4. switch语句匹配，参数类型是结构体，执行对应case语句中的代码\n\n前两步和输出字符串一模一样，不过由于是自定义的结构体，而且没有实现任何协议，所以在第三步骤无法满足任意一个if判断。于是调用`_adHocPrint `函数，这个函数可以确保任何类型都能在`print`方法中较好的工作。在`_adHocPrint `函数中也有switch判断，如果被输出的变量是一个结构体，则会执行对应的操作，代码如下：\n\n```swift\ninternal func _adHocPrint<T, TargetStream : OutputStreamType>(\n    value: T, inout _ target: TargetStream, isDebugPrint: Bool\n) {\n  func printTypeName(type: Any.Type) {\n    // Print type names without qualification, unless we're debugPrint'ing.\n    target.write(_typeName(type, qualified: isDebugPrint))\n  }\n\n  let mirror = _reflect(value)\n  switch mirror {\n  case is _TupleMirror:\n    // 这里定义了输出元组类型的方法\n\n  case is _StructMirror:\n    printTypeName(mirror.valueType)\n    target.write(\"(\")\n    var first = true\n    for i in 0..<mirror.count {\n      if first {\n        first = false\n      } else {\n        target.write(\", \")\n      }\n      let (label, elementMirror) = mirror[i]\n      print(label, terminator: \"\", toStream: &target)\n      target.write(\": \")\n      debugPrint(elementMirror.value, terminator: \"\", toStream: &target)\n    }\n    target.write(\")\")\n\n  case let enumMirror as _EnumMirror:\n    // 这里定义了输出枚举类型的方法\n\n  case is _MetatypeMirror:\n    // 这里定义了输出元类型的方法\n\n  default:\n    // 如果都不是就进行默认输出\n  }\n}\n```\n\n您可以仔细阅读`case is _StructMirror`这一段，它的逻辑和结构体的输出结果是一致的。如果此前定义的不是结构体而是类，那么得到的结果只是`Streamable.PersonStruct`，根据`default`段中的代码也很容易理解。\n\n正是由于`_adHocPrint `方法，不仅仅是字符串和Swift内置的类型，任何自定义类型都可以被输出。现在您应该已经明白，为什么输出`prefix`用的是`write`方法，而输出字符串`\"Hello, world!\"`要用`_print_unlocked `函数了吧？这是因为在那个时候，编译器还无法判定输出内容的类型。\n\n### 四、万能的String\n\n不知道您有没有注意到一个细节，`String`类型的初始化函数是一个没有类型约束的范型函数，也就是说任意类型都可以用来创建一个字符串，这是因为`String`类型的初始化函数有一个重载为：\n\n```swift\nextension String {\n  public init<T>(_ instance: T) {\n    self.init()\n    _print_unlocked(instance, &self)\n  }\n}\n```\n\n这里的字符串不是一个可输出类型，而是作为输出流来使用。`_print_unlocked `将`instance`输出到字符串流中。\n\n# 调试输出\n\n在`_print_unlocked`函数中，我们看到它在输出默认值之前，一共会进行三次判断。依次检验被输出的变量是否实现了`Streamable `、`CustomStringConvertible `和`CustomDebugStringConvertible `，只要实现了协议，就会进行相应的处理并提前退出函数。\n\n这三个协议的优先级依次降低，也就是如果一个类型既实现了`Streamable `协议又实现了`CustomStringConvertible `协议，那么将会优先调用`Streamable `协议中定义的`writeTo`方法。从这个优先级顺序来看，`print`函数更倾向于字符串的正常输出而非调试输出。\n\nSwift中还有一个`debugPrint`函数，它更倾向于输出字符串的调试信息。调用这个函数时，三个协议的优先级完全相反：\n\n```swift\nextension PersonDebug: CustomStringConvertible, CustomDebugStringConvertible {\n    var description: String {\n        return \"In CustomStringConvertible Protocol\"\n    }\n    \n    var debugDescription: String {\n        return \"In CustomDebugStringConvertible Protocol\"\n    }\n}\n\nlet kt = PersonDebug(name: \"kt\", age: 21)\nprint(kt)\t// \"In CustomStringConvertible Protocol\"\ndebugPrint(kt)\t//\"In CustomDebugStringConvertible Protocol\"\n```\n\n刚刚我们说到，创建字符串时可以传入任意的参数value，最后的字符串的值和调用`print(value)`的结果完全相同，这是因为两者都会调用`_print_unlocked `方法。对应到`debugPrint`函数则有：\n\n```swift\nextension String {\n  public init<T>(reflecting subject: T) {\n    self.init()\n    debugPrint(subject, terminator: \"\", toStream: &self)\n  }\n}\n```\n\n简单来说，在`_adHocPrint `函数之前，这两个输出函数的调用栈是完全平行的关系，下面这张图作为两者的比较，也是整篇文章的总结，纯手绘，美死早：\n\n![print与debugPring调用栈](http://images.bestswifter.com/print.png)\n","html":"<p>在进行调试的时候，我们有时会把一个变量自身，或其成员属性的值打印出来以检查是否符合我们的预期。或者干脆简单一些，直接<code>print</code>整个变量，不同于C++的<code>std::cout</code>，如果你调用<code>print(value)</code>，不管<code>value</code>是什么类型程序都不会报错，而且大多数时候你能获得比较全面的、可读的输出结果。如果这引起了你对<code>print</code>函数的好奇，接下来我们共同研究以下几个问题：</p>\n\n<ol>\n<li><code>print(\"hello, world\")</code>和<code>print(123)</code>的执行原理  </li>\n<li><code>Streamable</code>和<code>OutputStreamType</code>协议  </li>\n<li><code>CustomStringConvertible</code>和<code>CustomDebugStringConvertible</code>协议  </li>\n<li>为什么字符串的初始化函数中可以传入任何类型的参数  </li>\n<li><code>print</code>和<code>debugPrint</code>函数的区别</li>\n</ol>\n\n<p>本文的demo地址在<a href=\"https://github.com/bestswifter/MySampleCode/tree/master/Streamable\">我的github</a>，读者可以下载下来自行把玩，如果觉得有收获还望给个star鼓励一下。</p>\n\n<h1 id=\"\">字符串输出</h1>\n\n<p>有笑话说每个程序员的第一行代码都是这样的：</p>\n\n<pre><code class=\"language-swift\">print(\"Hello, world!\")  \n</code></pre>\n\n<p>先别急着笑，您还真不一定知道这行代码是怎么运行的。</p>\n\n<p>首先，<code>print</code>函数支持重载，Swift定义了两个版本的实现。其中简化版的<code>print</code>将输出流指定为标准输出流，我们忽略playground相关的代码，来看一下上面那一行代码中的<code>print</code>函数是怎么定义的，在不改编代码逻辑的前提下，为了方便阅读，我做了一些排版方面的修改：</p>\n\n<pre><code class=\"language-swift\">// 简化版print函数，通过terminator = \"\\n\"可知print函数默认会换行\npublic func print(items: Any..., separator: String = \" \", terminator: String = \"\\n\") {  \n    var output = _Stdout()  \n    _print(items, separator: separator, terminator: terminator, toStream: &amp;output)\n}\n\n// 完整版print函数，参数中多了一个outPut参数\npublic func print&lt;Target: OutputStreamType&gt;(items: Any...,separator: String = \" \",  \n  terminator: String = \"\\n\",\n  inout toStream output: Target) {\n  _print(items, separator: separator, terminator: terminator, toStream: &amp;output)\n}\n</code></pre>\n\n<p>两者的区别在于完整版<code>print</code>函数需要我们提供<code>output</code>参数，而我们之前调用的显然是第一个<code>print</code>函数，在函数中创建了<code>output</code>变量。这两个版本的<code>print</code>函数都会调用内部的<code>_print</code>函数。</p>\n\n<p>通过这一层封装，真正的核心操作在<code>_print</code>函数中，而对外则提供了一个重载的，高度可定制的<code>print</code>函数，接下来我们看一看这个内部的<code>_print</code>函数是如何实现的，为了阅读方便我删去了读写锁相关的代码，它的核心步骤如下：</p>\n\n<pre><code class=\"language-swift\">internal func _print&lt;Target: OutputStreamType&gt;(  \n  items: [Any],\n  separator: String = \" \",\n  terminator: String = \"\\n\",\n  inout toStream output: Target\n) {\n  var prefix = \"\"\n  for item in items {\n    output.write(prefix)    // 每两个元素之间用separator分隔开\n    _print_unlocked(item, &amp;output)    // 这句话其实是核心\n    prefix = separator\n  }\n  output.write(terminator)    // 终止符，通常是\"\\n\"\n}\n</code></pre>\n\n<p>这个函数有四个参数，显然第一个和第四个参数是关键。也就是说我们只关心要输出什么内容，以及输出到哪里，至于输出格式则是次要的。所以<code>_print</code>函数主要是处理了输出格式问题，以及把第一个参数(它是一个数组)中的每个元素，都写入到<code>output</code>中。通过目前的分析，我们已经明白文章开头的<code>print(\"Hello, world!\")</code>其实等价于：</p>\n\n<pre><code class=\"language-swift\">var output = _Stdout()    // 这个是output的默认值  \noutput.write(\"\")    // prefix是一个空字符串  \n_print_unlocked(\"Hello, world!\", &amp;output)  \n</code></pre>\n\n<p>你一定已经很好奇这个反复出现的<code>output</code>是什么了，其实在整个<code>print</code>函数的执行过程中<code>OutputStreamType</code>类型的<code>output</code>变量都是关键。另一个略显奇怪的点在于，同样是输出空字符串和<code>\"Hello, world!\"</code>，竟然调用了两个不同的方法。接下来我们首先分析<code>OutputStreamType</code>协议以及其中的<code>write</code>方法，再来研究为什么还需要<code>_print_unlocked</code>函数：</p>\n\n<pre><code class=\"language-swift\">public protocol OutputStreamType {  \n  mutating func write(string: String)\n}\n\ninternal struct _Stdout : OutputStreamType {  \n  mutating func write(string: String) {\n    for c in string.utf8 {\n      _swift_stdlib_putchar(Int32(c))\n    }\n  }\n}\n</code></pre>\n\n<p>简单来说，<code>OutputStreamType</code>表示了一个输出流，也就说你要把字符串输出到哪里。如果你有过C++编程经验，那你一定知道<code>#include &lt;iostream&gt;</code>这个库文件，以及<code>cout</code>和<code>cin</code>这两个标准输出、输入流。</p>\n\n<p>在<code>OutputStreamType</code>协议中定义了<code>write</code>方法，它表示这个流是如何把字符串写入的。比如标准输出流<code>_Stdout</code>的处理方法就是在字符串的UFT-8编码视图下，把每个字符转换成Int32类型，然后调用<code>_swift_stdlib_putchar</code>函数。这个函数在<code>LibcShims.cpp</code>文件中定义，可以理解为一个适配器，它内部会直接调用C语言的<code>putchar</code>函数。</p>\n\n<p>Ok，已经分析到C语言的<code>putchar</code>函数了，再往下就不必说了(我也不懂<code>putchar</code>是怎么实现的)。现在我们把思路拉回到另一个把字符串打印到屏幕上的函数——<code>_print_unlocked</code>上，它的定义如下：</p>\n\n<pre><code class=\"language-swift\">internal func _print_unlocked&lt;T, TargetStream : OutputStreamType&gt;(value: T, inout _ target: TargetStream) {  \n  if case let streamableObject as Streamable = value {\n    streamableObject.writeTo(&amp;target)\n    return\n  }\n\n  if case let printableObject as CustomStringConvertible = value {\n    printableObject.description.writeTo(&amp;target)\n    return\n  }\n\n  if case let debugPrintableObject as CustomDebugStringConvertible = value {\n    debugPrintableObject.debugDescription.writeTo(&amp;target)\n    return\n  }\n\n  _adHocPrint(value, &amp;target, isDebugPrint: false)\n}\n</code></pre>\n\n<p>在调用最后的<code>_adHocPrint</code>方法之前，进行了三次判断，分别判断被输出的<code>value</code>(在我们的例子中是字符串\"Hello, world!\")是否实现了指定的协议，如果是，则调用该协议下的<code>writeTo</code>方法并提前返回，而最后的<code>_adHocPrint</code>方法则用于确保，任何类型都有默认的输出。稍后我会通过一个具体的例子来解释。</p>\n\n<p>这里我们主要看一下<code>Streamable</code>协议，关于另外两个协议的介绍您可以参考<a href=\"http://www.jianshu.com/p/8b39e9c84462\">《第七章——字符串(字符串调试)》</a>。<code>Streamable</code>协议定义如下：</p>\n\n<pre><code class=\"language-swift\">/// A source of text streaming operations.  `Streamable` instances can\n/// be written to any *output stream*.\npublic protocol Streamable {  \n  func writeTo&lt;Target : OutputStreamType&gt;(inout target: Target)\n}\n</code></pre>\n\n<p>根据官方文档的定义，<code>Streamable</code>类型的变量可以被写入任何一个输出流中。<code>String</code>类型实现了<code>Streamable</code>协议，定义如下：</p>\n\n<pre><code class=\"language-swift\">extension String : Streamable {  \n  /// Write a textual representation of `self` into `target`.\n  public func writeTo&lt;Target : OutputStreamType&gt;(inout target: Target) {\n    target.write(self)\n  }\n}\n</code></pre>\n\n<p>看到这里，<code>print(\"Hello, wrold!\")</code>的完整流程就算全部讲完了。还留下一个小疑问，同样是输出字符串，为什么不直接调用<code>write</code>函数，而是大费周章的调用<code>_print_unlocked</code>函数？这个问题在讲解完<code>_adHocPrint</code>函数的原理后您就能理解了。</p>\n\n<p>需要强调一点，千万不要把<code>writeTo</code>函数和<code>write</code>函数弄混淆了。<code>write</code>函数是输出流，也就是<code>OutputStreamType</code>类型的方法，用于输出内容到屏幕上，比如<code>_Stdout</code>的<code>write</code>函数实际上会调用C语言的<code>putchar</code>函数。</p>\n\n<p><code>writeTo</code>函数是可输出类型(也就是实现了<code>Streamable</code>协议)的方法，它用于将该类型的内容输出到某个流中。</p>\n\n<p>输出字符串的过程中，这两个函数的关系可以这样简单理解：</p>\n\n<blockquote>\n  <p>内容.writeTo(输出流) = 输出流.write(内容)，一般在前者内部执行后者</p>\n</blockquote>\n\n<p>字符串不仅是可输出类型(Streamable)，同时自身也是输出流(OutputStreamType)，它是Swift标准库中的唯一一个输出流，定义如下：</p>\n\n<pre><code class=\"language-swift\">extension String : OutputStreamType {  \n  public mutating func write(other: String) {\n    self += other\n  }\n}\n</code></pre>\n\n<p>在输出字符串的过程中，我们用到的是字符串可输出的特性，至于它作为输出流的特性，会在稍后的例子中进行讲解。</p>\n\n<h1 id=\"\">实战</h1>\n\n<p>接下来我们通过几个例子来加深对<code>print</code>函数执行过程的理解。</p>\n\n<h3 id=\"\">一、字符串输出</h3>\n\n<p>还是用文章开头的例子，我们分析一下其背后的步骤：</p>\n\n<pre><code class=\"language-swift\">print(\"Hello, world!\")  \n</code></pre>\n\n<ol>\n<li>调用不带<code>output</code>参数的<code>print</code>函数，函数内部生成<code>_Stdout</code>类型的输出流，调用<code>_print</code>函数  </li>\n<li>在<code>_print</code>函数中国处理完<code>separator</code>和<code>terminator</code>等格式参数后，调用<code>_print_unlocked</code>函数处理字符串输出。  </li>\n<li>在<code>_print_unlocked</code>函数的第一个if判断中，因为字符串类型实现了<code>Streamable</code>协议，所以调用字符串的<code>writeTo</code>函数，写入到输出流中。  </li>\n<li>根据字符串的<code>writeTo</code>函数的定义，它在内部调用了输出流的<code>write</code>方法  </li>\n<li><code>_Stdout</code>在其<code>write</code>方法中，调用C语言的<code>putchar</code>函数输出字符串的每个字符</li>\n</ol>\n\n<h3 id=\"\">二、标准库中其他类型输出</h3>\n\n<p>如果要输出一个整数，似乎和输出字符串一样简单，但其实并不是这样，我们来分析一下具体的步骤：</p>\n\n<pre><code class=\"language-swift\">print(123)  \n</code></pre>\n\n<ol>\n<li>调用不带<code>output</code>参数的<code>print</code>函数，函数内部生成<code>_Stdout</code>类型的输出流，调用<code>_print</code>函数  </li>\n<li>在<code>_print</code>函数中国处理完<code>separator</code>和<code>terminator</code>等格式参数后，调用<code>_print_unlocked</code>函数处理字符串输出。  </li>\n<li>截止目前和输出字符串一致，不过Int类型(以及其他除了和字符有关的几乎所有类型)没有实现<code>Streamable</code>协议，它实现的是<code>CustomStringConvertible</code>协议，定义了自己的计算属性<code>description</code>  </li>\n<li><code>description</code>是一个字符串类型，调用字符串的<code>writeTo</code>方法此前已经讲过，就不再赘述了。</li>\n</ol>\n\n<h3 id=\"\">三、自定义结构体输出</h3>\n\n<p>我们简单的定义一个结构体，然后尝试使用<code>print</code>方法输出这个结构体：</p>\n\n<pre><code class=\"language-swift\">struct Person {  \n    var name: String\n    private var age: Int\n\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n}\n\nlet kt = Person(name: \"kt\", age: 21)  \nprint(kt)    // 输出结果：PersonStruct(name: \"kt\", age: 21)  \n</code></pre>\n\n<p>输出结果的可读性非常好，我们来分析一下其中的步骤：</p>\n\n<ol>\n<li>调用不带<code>output</code>参数的<code>print</code>函数，函数内部生成<code>_Stdout</code>类型的输出流，调用<code>_print</code>函数  </li>\n<li>在<code>_print</code>函数中国处理完<code>separator</code>和<code>terminator</code>等格式参数后，调用<code>_print_unlocked</code>函数处理字符串输出。  </li>\n<li>在<code>_print_unlocked</code>中调用<code>_adHocPrint</code>函数  </li>\n<li>switch语句匹配，参数类型是结构体，执行对应case语句中的代码</li>\n</ol>\n\n<p>前两步和输出字符串一模一样，不过由于是自定义的结构体，而且没有实现任何协议，所以在第三步骤无法满足任意一个if判断。于是调用<code>_adHocPrint</code>函数，这个函数可以确保任何类型都能在<code>print</code>方法中较好的工作。在<code>_adHocPrint</code>函数中也有switch判断，如果被输出的变量是一个结构体，则会执行对应的操作，代码如下：</p>\n\n<pre><code class=\"language-swift\">internal func _adHocPrint&lt;T, TargetStream : OutputStreamType&gt;(  \n    value: T, inout _ target: TargetStream, isDebugPrint: Bool\n) {\n  func printTypeName(type: Any.Type) {\n    // Print type names without qualification, unless we're debugPrint'ing.\n    target.write(_typeName(type, qualified: isDebugPrint))\n  }\n\n  let mirror = _reflect(value)\n  switch mirror {\n  case is _TupleMirror:\n    // 这里定义了输出元组类型的方法\n\n  case is _StructMirror:\n    printTypeName(mirror.valueType)\n    target.write(\"(\")\n    var first = true\n    for i in 0..&lt;mirror.count {\n      if first {\n        first = false\n      } else {\n        target.write(\", \")\n      }\n      let (label, elementMirror) = mirror[i]\n      print(label, terminator: \"\", toStream: &amp;target)\n      target.write(\": \")\n      debugPrint(elementMirror.value, terminator: \"\", toStream: &amp;target)\n    }\n    target.write(\")\")\n\n  case let enumMirror as _EnumMirror:\n    // 这里定义了输出枚举类型的方法\n\n  case is _MetatypeMirror:\n    // 这里定义了输出元类型的方法\n\n  default:\n    // 如果都不是就进行默认输出\n  }\n}\n</code></pre>\n\n<p>您可以仔细阅读<code>case is _StructMirror</code>这一段，它的逻辑和结构体的输出结果是一致的。如果此前定义的不是结构体而是类，那么得到的结果只是<code>Streamable.PersonStruct</code>，根据<code>default</code>段中的代码也很容易理解。</p>\n\n<p>正是由于<code>_adHocPrint</code>方法，不仅仅是字符串和Swift内置的类型，任何自定义类型都可以被输出。现在您应该已经明白，为什么输出<code>prefix</code>用的是<code>write</code>方法，而输出字符串<code>\"Hello, world!\"</code>要用<code>_print_unlocked</code>函数了吧？这是因为在那个时候，编译器还无法判定输出内容的类型。</p>\n\n<h3 id=\"string\">四、万能的String</h3>\n\n<p>不知道您有没有注意到一个细节，<code>String</code>类型的初始化函数是一个没有类型约束的范型函数，也就是说任意类型都可以用来创建一个字符串，这是因为<code>String</code>类型的初始化函数有一个重载为：</p>\n\n<pre><code class=\"language-swift\">extension String {  \n  public init&lt;T&gt;(_ instance: T) {\n    self.init()\n    _print_unlocked(instance, &amp;self)\n  }\n}\n</code></pre>\n\n<p>这里的字符串不是一个可输出类型，而是作为输出流来使用。<code>_print_unlocked</code>将<code>instance</code>输出到字符串流中。</p>\n\n<h1 id=\"\">调试输出</h1>\n\n<p>在<code>_print_unlocked</code>函数中，我们看到它在输出默认值之前，一共会进行三次判断。依次检验被输出的变量是否实现了<code>Streamable</code>、<code>CustomStringConvertible</code>和<code>CustomDebugStringConvertible</code>，只要实现了协议，就会进行相应的处理并提前退出函数。</p>\n\n<p>这三个协议的优先级依次降低，也就是如果一个类型既实现了<code>Streamable</code>协议又实现了<code>CustomStringConvertible</code>协议，那么将会优先调用<code>Streamable</code>协议中定义的<code>writeTo</code>方法。从这个优先级顺序来看，<code>print</code>函数更倾向于字符串的正常输出而非调试输出。</p>\n\n<p>Swift中还有一个<code>debugPrint</code>函数，它更倾向于输出字符串的调试信息。调用这个函数时，三个协议的优先级完全相反：</p>\n\n<pre><code class=\"language-swift\">extension PersonDebug: CustomStringConvertible, CustomDebugStringConvertible {  \n    var description: String {\n        return \"In CustomStringConvertible Protocol\"\n    }\n\n    var debugDescription: String {\n        return \"In CustomDebugStringConvertible Protocol\"\n    }\n}\n\nlet kt = PersonDebug(name: \"kt\", age: 21)  \nprint(kt)    // \"In CustomStringConvertible Protocol\"  \ndebugPrint(kt)    //\"In CustomDebugStringConvertible Protocol\"  \n</code></pre>\n\n<p>刚刚我们说到，创建字符串时可以传入任意的参数value，最后的字符串的值和调用<code>print(value)</code>的结果完全相同，这是因为两者都会调用<code>_print_unlocked</code>方法。对应到<code>debugPrint</code>函数则有：</p>\n\n<pre><code class=\"language-swift\">extension String {  \n  public init&lt;T&gt;(reflecting subject: T) {\n    self.init()\n    debugPrint(subject, terminator: \"\", toStream: &amp;self)\n  }\n}\n</code></pre>\n\n<p>简单来说，在<code>_adHocPrint</code>函数之前，这两个输出函数的调用栈是完全平行的关系，下面这张图作为两者的比较，也是整篇文章的总结，纯手绘，美死早：</p>\n\n<p><img src=\"http://images.bestswifter.com/print.png\" alt=\"print与debugPring调用栈\" /></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-26T14:19:04.000Z","created_by":1,"updated_at":"2016-01-28T16:30:51.000Z","updated_by":1,"published_at":"2016-01-26T14:19:51.000Z","published_by":1},{"id":5,"uuid":"99a782b0-98ac-44a9-a328-17b2430e4a67","title":"iOS多线程编程——GCD与NSOperation总结","slug":"multithreadconclusion","markdown":"很长时间以来，我个人（可能还有很多同学），对多线程编程都存在一些误解。一个很明显的表现是，很多人有这样的看法：\n> 新开一个线程，能提高速度，避免阻塞主线程\n\n毕竟多线程嘛，几个线程一起跑任务，速度快，还不阻塞主线程，简直完美。\n\n在某些场合，我们还见过另一个“高深”的名词——“异步”。这东西好像和多线程挺类似，经过一番百度（阅读了很多质量层次不齐的文章）之后，很多人也没能真正搞懂何为“异步”。\n\n于是，带着对“多线程”和“异步”的懵懂，很多人又开开心心踏上了多线程编程之旅，比如文章待会儿会提到的GCD。\n\n## 何为多线程\n\n其实，如果**不考虑其他任何因素和技术**，多线程有百害而无一利，只能浪费时间，降低程序效率。\n\n是的，我很清醒的写下这句话。\n\n试想一下，一个任务由十个子任务组成。现在有两种方式完成这个任务：\n1. 建十个线程，把每个子任务放在对应的线程中执行。执行完一个线程中的任务就切换到另一个线程。\n2. 把十个任务放在一个线程里，按顺序执行。\n\n操作系统的基础知识告诉我们，线程，是执行程序最基本的单元，它有自己栈和寄存器。说得再具体一些，线程就是**“一个CPU执行的一条无分叉的命令列”**。\n\n对于第一种方法，在十个线程之间来回切换，就意味着有十组栈和寄存器中的值需要不断地被备份、替换。\n而对于对于第二种方法，只有一组寄存器和栈存在，显然效率完胜前者。\n\n### 并发与并行\n\n通过刚刚的分析我们看到，多线程本身会带来效率上的损失。准确来说，在处理并发任务时，多线程不仅不能提高效率，反而还会降低程序效率。\n\n所谓的“**并发**”，英文翻译是concurrent。要注意和**“并行（parallelism）”**的区别。\n\n> **并发**指的是一种现象，一种经常出现，无可避免的现象。它描述的是“多个任务同时发生，需要被处理”这一现象。它的侧重点在于“发生”。\n\n比如有很多人排队等待检票，这一现象就可以理解为并发。\n\n> **并行**指的是一种技术，一个同时处理多个任务的技术。它描述了一种能够同时处理多个任务的能力，侧重点在于“运行”。\n\n比如景点开放了多个检票窗口，同一时间内能服务多个游客。这种情况可以理解为并行。\n\n并行的反义词就是串行，表示任务必须按顺序来，一个一个执行，前一个执行完了才能执行后一个。\n\n我们经常挂在嘴边的“多线程”，正是采用了并行技术，从而提高了执行效率。因为有多个线程，所以计算机的多个CPU可以同时工作，同时处理不同线程内的指令。\n\n并发是一种现象，面对这一现象，我们首先创建多个线程，真正加快程序运行速度的，是并行技术。也就是让多个CPU同时工作。而多线程，是为了让多个CPU同时工作成为可能。\n\n### 同步与异步\n同步方法就是我们平时调用的哪些方法。因为任何有编程经验的人都知道，比如在第一行调用<font color = \"rgb(226,238,250)\">`foo()`</font>方法，那么程序运行到第二行的时候，foo方法肯定是执行完了。\n\n所谓的异步，就是允许在执行某一个任务时，函数立刻返回，但是真正要执行的任务稍后完成。\n\n比如我们在点击保存按钮之后，要先把数据写到磁盘，然后更新UI。同步方法就是等到数据保存完再更新UI，而异步则是立刻从保存数据的方法返回并向后执行代码，同时真正用来保存数据的指令将在稍后执行。\n\n### 区别和联系\n\n假设现在有三个任务需要处理。假设单个CPU处理它们分别需要3、1、1秒。\n\n并行与串行，其实讨论的是处理这三个任务的速度问题。如果三个CPU并行处理，那么一共只需要3秒。相比于串行处理，节约了两秒。\n\n而同步/异步，其实描述的是任务之间先后顺序问题。假设需要三秒的那个是保存数据的任务，而另外两个是UI相关的任务。那么通过异步执行第一个任务，我们省去了三秒钟的卡顿时间。\n\n对于同步执行的三个任务来说，系统**倾向于**在同一个线程里执行它们。因为即使开了三个线程，也得等他们分别在各自的线程中完成。并不能减少总的处理时间，反而徒增了线程切换（这就是文章开头举的例子）\n\n对于异步执行的三个任务来说，系统**倾向于**在三个新的线程里执行他们。因为这样可以最大程度的利用CPU性能，提升程序运行效率。\n\n### 总结\n\n于是我们可以得出结论，在需要同时处理IO和UI的情况下，真正起作用的是异步，而不是多线程。可以不用多线程（因为处理UI非常快），但不能不用异步（否则的话至少要等IO结束）。\n\n注意到我把“倾向于”这三个加粗了，也就是说异步方法并不一定永远在新线程里面执行，反之亦然。在接下来关于GCD的部分会对此做出解释。\n\n## GCD简介\n\nGCD以block为基本单位，一个block中的代码可以为一个任务。下文中提到任务，可以理解为执行某个block\n\n同时，GCD中有两大最重要的概念，分别是“队列”和“执行方式”。\n\n使用block的过程，概括来说就是把block放进合适的队列，并选择合适的执行方式去执行block的过程。\n\n#### 三种队列：\n\n2. 串行队列（先进入队列的任务先出队列，每次只执行一个任务）\n3. 并行队列（依然是“先入先出”，不过可以形成多个任务并发）\n4. 主队列（这是一个特殊的串行队列，而且队列中的任务一定会在主线程中执行）\n\n#### 两种执行方式：\n\n1. 同步执行\n2. 异步执行\n\n关于同步异步、串行并行和线程的关系，下面通过一个表格来总结\n\n![](http://7xonij.com1.z0.glb.clouddn.com/Tables/ralationship.jpg)\n\n可以看到，同步方法不一定在本线程，异步方法方法也不一定新开线程（考虑主队列）。\n\n然而事实上，在本文一开始就揭开了“多线程”的神秘面纱，所以我们在编程时，更应该考虑的是：\n\n> 同步 Or 异步\n\n以及\n\n> 串行 Or 并行\n\n而非仅仅考虑是否新开线程。\n\n当然，了解任务运行在那个线程中也是为了更加深入的理解整个程序的运行情况，尤其是接下来要讨论的死锁问题。\n\n## GCD的死锁问题\n\n在使用GCD的过程中，如果**向当前串行队列中同步派发一个任务**，就会导致死锁。\n\n这句话有点绕，我们首先举个例子看看：\n\n```swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    let mainQueue = dispatch_get_main_queue()\n    let block = { ()  in\n    \tprint(NSThread.currentThread())\n\t}    \n\tdispatch_sync(mainQueue, block)\n}\n\n```\n\n这段代码就会导致死锁，因为我们目前在主队列中，又将要同步地添加一个`block `到主队列(串行)中。\n\n###理论分析\n\n我们知道`dispatch_sync `表示同步的执行任务，也就是说执行`dispatch_sync `后，当前队列会阻塞。而`dispatch_sync `中的block如果要在当前队列中执行，就得等待当前队列程执行完成。\n\n在上面这个例子中，主队列在执行`dispatch_sync `，随后队列中新增一个任务`block`。因为主队列是同步队列，所以`block`要等`dispatch_sync`执行完才能执行，但是`dispatch_sync`是同步派发，要等`block`执行完才算是结束。在主队列中的两个任务互相等待，导致了死锁。\n\n###解决方案\n\n其实在通常情况下我们不必要用`dispatch_sync `，因为`dispatch_async `能够更好的利用CPU，提升程序运行速度。\n\n只有当我们需要保证队列中的任务必须顺序执行时，才考虑使用`dispatch_sync `。在使用`dispatch_sync `的时候应该分析当前处于哪个队列，以及任务会提交到哪个队列。\n\n### GCD任务组\n\n了解完队列之后，很自然的会有一个想法：我们怎么知道所有任务都已经执行完了呢？\n\n在单个串行队列中，这个不是问题，因为只要把回调block添加到队列末尾即可。\n\n但是对于并行队列，以及多个串行、并行队列混合的情况，就需要使用<font color = \"rgb(226,238,250)\">`dispatch_group `</font>了。\n\n``` swift\nlet group = dispatch_group_create()\n\ndispatch_group_async(group, serialQueue, { () -> Void in\n\tfor _ in 0..<2 {\n\t\tprint(\"group-serial \\(NSThread.currentThread())\")\n\t}\n})\n        \ndispatch_group_async(group, serialQueue, { () -> Void in\n\tfor _ in 0..<3 {\n\t\tNSLog(\"group-02 - %@\", NSThread.currentThread())\n\t}\n})\n        \ndispatch_group_notify(group, serialQueue, { () -> Void in\n\tprint(\"完成 - \\(NSThread.currentThread())\")\n})\n```\n\n首先我们要通过<font color = \"rgb(226,238,250)\">`dispatch_group_create() `</font>方法生成一个组。\n\n接下来，我们把<font color = \"rgb(226,238,250)\">`dispatch_async `</font>方法换成<font color = \"rgb(226,238,250)\">`dispatch_group_async `</font>。这个方法多了一个参数，第一个参数填刚刚创建的分组。\n\n想问<font color = \"rgb(226,238,250)\">`dispatch_sync `</font>对应的分组方法是什么的童鞋面壁思过三秒钟，思考一下group出现的目的和<font color = \"rgb(226,238,250)\">`dispatch_sync `</font>的特点。\n\n最后调用<font color = \"rgb(226,238,250)\">`dispatch_group_create `</font>方法。这个方法表示把第三个参数block传入第二个参数队列中去。而且可以保证第三个参数block执行时，group中的所有任务已经全部完成。\n\n### dispatch\\_group\n\n<font color = \"rgb(226,238,250)\">`dispatch_group_wait `</font>方法是一个很有用的方法，它的完整定义如下：\n\n<font color = \"rgb(226,238,250)\">`dispatch_group_wait(group: dispatch_group_t, _ timeout: dispatch_time_t) -> Int `</font>\n\n第一个参数表示要等待的group，第二个则表示等待时间。返回值表示经过指定的等待时间，属于这个group的任务是否已经全部执行完，如果是则返回0，否则返回非0。\n\n第二个<font color = \"rgb(226,238,250)\">`dispatch_time_t `</font>类型的参数还有两个特殊值：<font color = \"rgb(226,238,250)\">`DISPATCH_TIME_NOW `</font>和<font color = \"rgb(226,238,250)\">`DISPATCH_TIME_FOREVER `</font>。\n\n前者表示立刻检查属于这个group的任务是否已经完成，后者则表示一直等到属于这个group的任务全部完成。\n\n### dispatch\\_after方法\n\n通过GCD还可以进行简单的定时操作，比如在1秒后执行某个block。代码如下：\n\n``` swift\nlet mainQueue = dispatch_get_main_queue()\nlet time = dispatch_time(DISPATCH_TIME_NOW, Int64(3) * Int64(NSEC_PER_SEC))\nNSLog(\"%@\",NSThread.currentThread())\ndispatch_after(time, mainQueue, {() in NSLog(\"%@\",NSThread.currentThread())})\n```\n\n</font>和<font color = \"rgb(226,238,250)\">`dispatch_after `</font>方法有三个参数。第一个表示时间，也就是从现在起往后三秒钟。第二三个参数分别表示要提交的任务和提交到哪个队列。\n\n需要注意的是</font>和<font color = \"rgb(226,238,250)\">`dispatch_after `</font>仅表示在指定时间后提交任务，而非执行任务。如果任务提交到主队列，它将在main runloop中执行，对于每隔1/60秒执行一次的RunLoop，任务最多有可能在3+1/60秒后执行。\n\n## NSOperation\n\n<font color = \"rgb(226,238,250)\">`NSOperation`</font>和<font color = \"rgb(226,238,250)\">`NSOperationQueue`</font>主要涉及这几个方面：\n\n1. <font color = \"rgb(226,238,250)\">`NSOperation`</font>和</font>和<font color = \"rgb(226,238,250)\">`NSOperationQueue`</font>用法介绍\n2. <font color = \"rgb(226,238,250)\">`NSOperation`</font>的暂停、恢复和取消\n3. 通过KVO对<font color = \"rgb(226,238,250)\">`NSOperation`</font>的状态进行检测\n3. 多个<font color = \"rgb(226,238,250)\">`NSOperation`</font>的之间的依赖关系\n\n从简单意义上来说，<font color = \"rgb(226,238,250)\">`NSOperation`</font>是对GCD中的block进行的封装，它也表示一个要被执行的任务。\n\n与GCD中的block类似，<font color = \"rgb(226,238,250)\">`NSOperation`</font>对象有一个<font color = \"rgb(226,238,250)\">`start()`</font>方法表示开始执行这个任务。\n\n不仅如此，<font color = \"rgb(226,238,250)\">`NSOperation`</font>表示的任务还可以被取消。它还有三种状态<font color = \"rgb(226,238,250)\">`isExecuted`</font>、<font color = \"rgb(226,238,250)\">`isFinished`</font>和<font color = \"rgb(226,238,250)\">`isCancelled`</font>以方便我们通过KVC对它的状态进行监听。\n\n想要开始执行一个任务可以这么写：\n\n```swift\nlet operation = NSBlockOperation { () -> Void in\n\tprint(NSThread.currentThread())\n}\noperation.addExecutionBlock { () -> Void in\n\tprint(\"execution block1 -- \\(NSThread.currentThread())\")\n}\noperation.start()\n```\n\n以上代码会得到这样的执行结果：\n\n```swift\n<NSThread: 0x7f89b1c070f0>{number = 1, name = main}\nexecution block1 -- <NSThread: 0x7f89b1e17030>{number = 2, name = (null)}\n```\n\n首先我们创建了一个<font color = \"rgb(226,238,250)\">`NSBlockOperation `</font>，并且设置好它的block，也就是将要执行的任务。这个任务会在主线程中执行。\n\n用<font color = \"rgb(226,238,250)\">`NSBlockOperation `</font>是因为<font color = \"rgb(226,238,250)\">`NSOperation `</font>是一个基类，不应该直接生成<font color = \"rgb(226,238,250)\">`NSOperation `</font>对象，而是应该用它的子类。<font color = \"rgb(226,238,250)\">`NSBlockOperation `</font>是苹果预定义的子类，它可以用来封装一个或多个block，后面会介绍如何自己创建<font color = \"rgb(226,238,250)\">`NSOperation `</font>的子类。\n\n同时，还可以调用<font color = \"rgb(226,238,250)\">`addExecutionBlock `</font>方法追加几个任务，这些任务会并行执行（也就是说很有可能运行在别的线程里）。\n\n最后，调用<font color = \"rgb(226,238,250)\">`start `</font>方法让<font color = \"rgb(226,238,250)\">`NSOperation `</font>方法运行起来。<font color = \"rgb(226,238,250)\">`start `</font>是一个**同步**方法。\n\n## NSOperationQueue\n\n刚刚我们知道，默认的<font color = \"rgb(226,238,250)\">`NSOperation `</font>是同步执行的。简单的看一下<font color = \"rgb(226,238,250)\">`NSOperation `</font>类的定义会发现它有一个只读属性<font color = \"rgb(226,238,250)\">`asynchronous `</font>\n\n这意味着如果想要异步执行，就需要自定义<font color = \"rgb(226,238,250)\">`NSOperation `</font>的子类。或者使用<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>\n\n<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>类似于GCD中的队列。我们知道GCD中的队列有三种：**主队列**、**串行队列**和**并行队列**。<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>更简单，只有两种：**主队列**和**非主队列**。\n\n我们自己生成的<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>对象都是非主队列，主队列可以用<font color = \"rgb(226,238,250)\">`NSOperationQueue.mainQueue `</font>取得。\n\n<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>的主队列是串行队列，而且其中所有<font color = \"rgb(226,238,250)\">`NSOperation `</font>都会在主线程中执行。\n\n对于非主队列来说，一旦一个<font color = \"rgb(226,238,250)\">`NSOperation `</font>被放入其中，那这个<font color = \"rgb(226,238,250)\">`NSOperation `</font>一定是并发执行的。因为<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>会为每一个<font color = \"rgb(226,238,250)\">`NSOperation `</font>创建线程并调用它的<font color = \"rgb(226,238,250)\">`start `</font>方法。\n\n<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>有一个属性叫<font color = \"rgb(226,238,250)\">`maxConcurrentOperationCount `</font>，它表示最多支持多少个<font color = \"rgb(226,238,250)\">`NSOperation `</font>并发执行。如果<font color = \"rgb(226,238,250)\">`maxConcurrentOperationCount `</font>被设为1，就以为这个队列是串行队列。\n\n因此，<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>和GCD中的队列有这样的对应关系：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/Tables/relationship2.jpg)\n\n回到开头的问题，如何利用<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>实现异步操作呢，代码如下：\n\n```swift\nlet operationQueue = NSOperationQueue()\nlet operation = NSBlockOperation { () -> Void in\n\tprint(NSThread.currentThread())\n}\n\toperation.addExecutionBlock { () -> Void in\n\tprint(\"execution block1 -- \\(NSThread.currentThread())\")\n}\noperationQueue.addOperation(operation)\nprint(\"操作结束\")\n```\n\n得到运行结果如下：\n\n```swift\n操作结束\n<NSThread: 0x7fd51d2111b0>{number = 2, name = (null)}\nexecution block1 -- <NSThread: 0x7fd51d21bd50>{number = 3, name = (null)}\n\n```\n\n使用<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>来执行任务与之前的区别在于，首先创建一个非主队列。然后用<font color = \"rgb(226,238,250)\">`addOperation `</font>方法替换之前的<font color = \"rgb(226,238,250)\">`start `</font>方法。刚刚已经说过，<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>会为每一个<font color = \"rgb(226,238,250)\">`NSOperation `</font>建立线程并调用他们的<font color = \"rgb(226,238,250)\">`start `</font>方法。\n\n观察一下运行结果，所有的<font color = \"rgb(226,238,250)\">`NSOperation `</font>都没有在主线程执行，从而成功的实现了异步、并行处理。\n\n## NSOperation新特性\n\n在学习<font color = \"rgb(226,238,250)\">`NSOperation`</font>的时候，我们总是用GCD的概念去解释。但是<font color = \"rgb(226,238,250)\">`NSOperation`</font>作为对GCD更高层次的封装，它有着一些GCD无法实现（或者至少说很难实现）的特性。由于<font color = \"rgb(226,238,250)\">`NSOperation`</font>和<font color = \"rgb(226,238,250)\">`NSOperationQueue`</font>良好的封装，这些新特性的使用都非常简单。\n\n### 取消任务\n如果我们有两次网络请求，第二次请求会用到第一次的数据。如果此时网络情况不好，第一次请求超时了，那么第二次请求也没有必要发送了。当然，用户也有可能人为地取消某个<font color = \"rgb(226,238,250)\">`NSOperation`</font>。\n\n当某个<font color = \"rgb(226,238,250)\">`NSOperation`</font>被取消时，我们应该尽可能的清除<font color = \"rgb(226,238,250)\">`NSOperation`</font>内部的数据并且把<font color = \"rgb(226,238,250)\">`cancelled`</font>和<font color = \"rgb(226,238,250)\">`finished`</font>设为<font color = \"rgb(226,238,250)\">`true`</font>，把<font color = \"rgb(226,238,250)\">`executing`</font>设为<font color = \"rgb(226,238,250)\">`false`</font>。\n\n```swift\n//取消某个NSOperation\noperation1.cancel()\n\n//取消某个NSOperationQueue剩余的NSOperation\nqueue.cencelAllOperations()\n\n```\n\n### 设置依赖\n依然考虑刚刚所说的两次网络请求的例子。因为第二次请求会用到第一次的数据，所以我们要保证发出第二次请求的时候第一个请求已经执行完。但是我们同时还希望利用到<font color = \"rgb(226,238,250)\">`NSOperationQueue`</font>的并发特性（因为可能不止这两个任务）。\n\n这时候我们可以设置<font color = \"rgb(226,238,250)\">`NSOperation`</font>之间的依赖关系。语法非常简洁：\n\n```swift\noperation2.addDependency(operation1)\n```\n\n需要注意的是<font color = \"rgb(226,238,250)\">`NSOperation`</font>之间的相互依赖会导致死锁\n\n### NSOperationQueue暂停与恢复\n\n这个更加简单，只要修改<font color = \"rgb(226,238,250)\">`suspended`</font>属性即可\n\n```swift\nqueue.suspended = true //暂停queue中所有operation\nqueue.suspended = false //恢复queue中所有operation\n```\n\n### NSOperation优先级\n\nGCD中，任务（block）是没有优先级的，而队列具有优先级。和GCD相反，我们一般考虑<font color = \"rgb(226,238,250)\">`NSOperation`</font>的优先级\n\n\n<font color = \"rgb(226,238,250)\">`NSOperation`</font>有一个<font color = \"rgb(226,238,250)\">`NSOperationQueuePriority `</font>枚举类型的属性<font color = \"rgb(226,238,250)\">`queuePriority`</font>\n\n```swift\npublic enum NSOperationQueuePriority : Int {\n    case VeryLow\n    case Low\n    case Normal\n    case High\n    case VeryHigh\n}\n```\n\n需要注意的是，<font color = \"rgb(226,238,250)\">`NSOperationQueue`</font>也不能完全保证优先级高的任务一定先执行。\n\n## NSOperation和GCD如何选择\n\n其实经过这两篇文章的分析，我们大概对<font color = \"rgb(226,238,250)\">`NSOperation`</font>和<font color = \"rgb(226,238,250)\">`GCD`</font>都有了比较详细的了解，同时在亲自运用这两者的过程中有了自己的理解。\n\nGCD以block为单位，代码简洁。同时GCD中的队列、组、信号量、source、barriers都是组成并行编程的基本原语。对于一次性的计算，或是仅仅为了加快现有方法的运行速度，选择轻量化的GCD就更加方便。\n\n而<font color = \"rgb(226,238,250)\">`NSOperation`</font>可以用来规划一组任务之间的依赖关系，设置它们的优先级，任务能被取消。队列可以暂停、恢复。<font color = \"rgb(226,238,250)\">`NSOperation`</font>还可以被子类化。这些都是GCD所不具备的。\n\n所以我们要记住的是：\n> **<font color = \"rgb(226,238,250)\">`NSOperation`</font>和GCD并不是互斥的，有效地结合两者可以开发出更棒的应用**\n\n## GCD进阶\n\n`NSOperation`有自己独特的优势，`GCD`也有一些强大的特性。接下来我们由浅入深，讨论以下几个部分：\n\n* <font color =\"rgb(226,238,250)\">`dispatch_suspend`</font>和<font color =\"rgb(226,238,250)\">`dispatch_resume`</font>\n* <font color =\"rgb(226,238,250)\">`dispathc_once`</font>\n* <font color =\"rgb(226,238,250)\">`dispatch_barrier_async`</font>\n* <font color =\"rgb(226,238,250)\">`dispatch_semaphore`</font>\n\n### dispatch\\_suspend和dispatch\\_resume\n\n我们知道<font color =\"rgb(226,238,250)\">`NSOperationQueue `</font>有暂停(suspend)和恢复(resume)。其实GCD中的队列也有类似的功能。用法也非常简单：\n\n```swift\ndispatch_suspend(queue) //暂停某个队列\ndispatch_resume(queue)  //恢复某个队列\n```\n\n这些函数不会影响到队列中已经执行的任务，队列暂停后，已经添加到队列中但还没有执行的任务不会执行，直到队列被恢复。\n\n### dispathc_once\n\n首先我们来看一下最简单的`dispathc_once`函数，这在单例模式中被广泛使用。\n\n* <font color =\"rgb(226,238,250)\">`dispathc_once`</font>函数可以确保某个block在应用程序执行的过程中只被处理一次，而且它是线程安全的。所以单例模式可以很简单的实现，以OC中Manager类为例\n\n```objective-c\n+ (Manager *)sharedInstance {\n\tstatic Manager *sharedManagerInstance = nil;\n\tstatic dispatch_once_t once;\n\t\n\tdispatch_once($once, ^{\n\t\tsharedManagerInstance = [[Manager alloc] init];\n\t});\n\t\n\treturn sharedManagerInstance;\n}\n```\n\n这段代码中我们创建一个值为nil的<font color =\"rgb(226,238,250)\">`sharedManagerInstance `</font>静态对象，然后把它的初始化代码放到<font color =\"rgb(226,238,250)\">`dispatch_once`</font>中完成。\n\n这样，只有第一次调用<font color =\"rgb(226,238,250)\">`sharedInstance`</font>方法时才会进行对象的初始化，以后每次只是返回<font color =\"rgb(226,238,250)\">`sharedManagerInstance `</font>而已。\n\n### dispatch\\_barrier_async\n\n我们知道数据在写入时，不能在其他线程读取或写入。但是多个线程同时读取数据是没有问题的。所以我们可以把读取任务放入并行队列，把写入任务放入串行队列，并且保证写入任务执行过程中没有读取任务可以执行。\n\n这样的需求比较常见，GCD提供了一个非常简单的解决办法——<font color =\"rgb(226,238,250)\">`dispatch_barrier_async`</font>\n\n假设我们有四个读取任务，在第二三个任务之间有一个写入任务，代码大概是这样：\n\n```swift\nlet queue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_CONCURRENT)\n\ndispatch_async(queue, block1_for_reading)\ndispatch_async(queue, block2_for_reading)\n\n/*\n\t这里插入写入任务，比如：\n\tdispatch_async(queue, block_for_writing)\n*/\n\ndispatch_async(queue, block3_for_reading)\ndispatch_async(queue, block4_for_reading)\n\n```\n\n如果代码这样写，由于这几个block是并发执行，就有可能在前两个block中读取到已经修改了的数据。如果是有多写入任务，那问题更严重，可能会有数据竞争。\n\n如果使用<font color =\"rgb(226,238,250)\">`dispatch_barrier_async`</font>函数，代码就可以这么写：\n\n```swift\ndispatch_async(queue, block1_for_reading)\ndispatch_async(queue, block2_for_reading)\n\ndispatch_barrier_async(queue, block_for_writing)\n\ndispatch_async(queue, block3_for_reading)\ndispatch_async(queue, block4_for_reading)\n```\n\n<font color =\"rgb(226,238,250)\">`dispatch_barrier_async`</font>会把并行队列的运行周期分为这三个过程：\n\n1. 首先等目前追加到并行队列中所有任务都执行完成\n2. 开始执行<font color =\"rgb(226,238,250)\">`dispatch_barrier_async`</font>中的任务，这时候即使向并行队列提交任务，也不会执行\n3. <font color =\"rgb(226,238,250)\">`dispatch_barrier_async`</font>中的任务执行完成后，并行队列恢复正常。\n\n总的来说，<font color =\"rgb(226,238,250)\">`dispatch_barrier_async`</font>起到了“**承上启下**”的作用。它保证此前的任务都先于自己执行，此后的任务也迟于自己执行。正如barrier的含义一样，它起到了一个栅栏、或是分水岭的作用。\n\n这样一来，使用并行队列和<font color =\"rgb(226,238,250)\">`dispatc_barrier_async`</font>方法，就可以高效的进行数据和文件读写了。\n\n\n### dispatch_semaphore\n\n首先介绍一下信号量(semaphore)的概念。信号量是持有计数的信号，不过这么解释等于没解释。我们举个生活中的例子来看看。\n\n假设有一个房子，它对应进程的概念，房子里的人就对应着线程。一个进程可以包括多个线程。这个房子(进程)有很多资源，比如花园、客厅等，是所有人(线程)共享的。\n\n但是有些地方，比如卧室，最多只有两个人能进去睡觉。怎么办呢，在卧室门口挂上两把钥匙。进去的人(线程)拿着钥匙进去，没有钥匙就不能进去，出来的时候把钥匙放回门口。\n\n这时候，门口的钥匙数量就称为**信号量(Semaphore)**。很明显，信号量为0时需要等待，信号量不为零时，减去1而且不等待。\n\n在GCD中，创建信号量的语法如下：\n\n```swift\nvar semaphore = dispatch_semaphore_create(2)\n```\n\n这句代码通过<font color =\"rgb(226,238,250)\">`dispatch_semaphore_create `</font>方法创建一个信号量并设置初始值为2。然后就可以调用<font color =\"rgb(226,238,250)\">`dispatch_semaphore_wait`</font>方法了。\n\n```swift\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)\n```\n\n<font color =\"rgb(226,238,250)\">`dispatch_semaphore_wait`</font>方法表示一直等待直到信号量的值大于等于一，当这个方法执行后，会把第一个信号量参数的值减1。\n\n第二个参数是一个<font color =\"rgb(226,238,250)\">`dispatch_time_t`</font>类型的时间，它表示这个方法最大的等待时间。这在第一章中已经讲过，比如\n<font color =\"rgb(226,238,250)\">`DISPATCH_TIME_FOREVER `</font>表示永久等待。\n\n返回值也和<font color =\"rgb(226,238,250)\">`dispatch_group_wait`</font>方法一样，返回0表示在规定的等待时间内第一个参数信号量的值已经大于等于1，否则表示已超过规定等待时间，但信号量的值还是0。\n\n<font color =\"rgb(226,238,250)\">`dispatch_semaphore_wait`</font>方法返回0，因为此时的信号量的值大于等于一，任务获得了可以执行的权限。这时候我们就可以安全的执行需要进行排他控制的任务了。\n\n任务结束时还需要调用\n<font color =\"rgb(226,238,250)\">`dispatch_semaphore_signal()`</font>方法，将信号量的值加1。这类似于之前所说的，从卧室出来要把锁放回门上，否则后来的人就无法进入了。\n\n我们来看一个完整的例子：\n\n```swift\nvar semaphore = dispatch_semaphore_create(1)\nlet queue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_CONCURRENT)\nvar array: [Int] = []\n\nfor i in 1...100000 {\n\tdispatch_async(queue, { () -> Void in\n\t\t/*\n\t\t\t某个线程执行到这里，如果信号量值为1，那么wait方法返回1，开始执行接下来的操作。\n\t\t\t与此同时，因为信号量变为0，其它执行到这里的线程都必须等待\n\t\t*/\n\t\tdispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)\n                \n\t\t/*\n\t\t\t执行了wait方法后，信号量的值变成了0。可以进行接下来的操作。\n\t\t\t这时候其它线程都得等待wait方法返回。\n\t\t\t可以对array修改的线程在任意时刻都只有一个，可以安全的修改array\n\t\t*/\n\t\tarray.append(i)\n                \n\t\t/*\n\t\t\t排他操作执行结束，记得要调用signal方法，把信号量的值加1。\n\t\t\t这样，如果有别的线程在等待wait函数返回，就由最先等待的线程执行。\n\t\t*/\n\t\tdispatch_semaphore_signal(semaphore)\n\t})\n}\n```\n\n如果你想知道不用信号量会出什么问题，可以看我的另一篇文章[Swift数组append方法研究](http://115.159.123.174/swiftarrayappend/)","html":"<p>很长时间以来，我个人（可能还有很多同学），对多线程编程都存在一些误解。一个很明显的表现是，很多人有这样的看法：</p>\n\n<blockquote>\n  <p>新开一个线程，能提高速度，避免阻塞主线程</p>\n</blockquote>\n\n<p>毕竟多线程嘛，几个线程一起跑任务，速度快，还不阻塞主线程，简直完美。</p>\n\n<p>在某些场合，我们还见过另一个“高深”的名词——“异步”。这东西好像和多线程挺类似，经过一番百度（阅读了很多质量层次不齐的文章）之后，很多人也没能真正搞懂何为“异步”。</p>\n\n<p>于是，带着对“多线程”和“异步”的懵懂，很多人又开开心心踏上了多线程编程之旅，比如文章待会儿会提到的GCD。</p>\n\n<h2 id=\"\">何为多线程</h2>\n\n<p>其实，如果<strong>不考虑其他任何因素和技术</strong>，多线程有百害而无一利，只能浪费时间，降低程序效率。</p>\n\n<p>是的，我很清醒的写下这句话。</p>\n\n<p>试想一下，一个任务由十个子任务组成。现在有两种方式完成这个任务：\n1. 建十个线程，把每个子任务放在对应的线程中执行。执行完一个线程中的任务就切换到另一个线程。 <br />\n2. 把十个任务放在一个线程里，按顺序执行。</p>\n\n<p>操作系统的基础知识告诉我们，线程，是执行程序最基本的单元，它有自己栈和寄存器。说得再具体一些，线程就是<strong>“一个CPU执行的一条无分叉的命令列”</strong>。</p>\n\n<p>对于第一种方法，在十个线程之间来回切换，就意味着有十组栈和寄存器中的值需要不断地被备份、替换。\n而对于对于第二种方法，只有一组寄存器和栈存在，显然效率完胜前者。</p>\n\n<h3 id=\"\">并发与并行</h3>\n\n<p>通过刚刚的分析我们看到，多线程本身会带来效率上的损失。准确来说，在处理并发任务时，多线程不仅不能提高效率，反而还会降低程序效率。</p>\n\n<p>所谓的“<strong>并发</strong>”，英文翻译是concurrent。要注意和<strong>“并行（parallelism）”</strong>的区别。</p>\n\n<blockquote>\n  <p><strong>并发</strong>指的是一种现象，一种经常出现，无可避免的现象。它描述的是“多个任务同时发生，需要被处理”这一现象。它的侧重点在于“发生”。</p>\n</blockquote>\n\n<p>比如有很多人排队等待检票，这一现象就可以理解为并发。</p>\n\n<blockquote>\n  <p><strong>并行</strong>指的是一种技术，一个同时处理多个任务的技术。它描述了一种能够同时处理多个任务的能力，侧重点在于“运行”。</p>\n</blockquote>\n\n<p>比如景点开放了多个检票窗口，同一时间内能服务多个游客。这种情况可以理解为并行。</p>\n\n<p>并行的反义词就是串行，表示任务必须按顺序来，一个一个执行，前一个执行完了才能执行后一个。</p>\n\n<p>我们经常挂在嘴边的“多线程”，正是采用了并行技术，从而提高了执行效率。因为有多个线程，所以计算机的多个CPU可以同时工作，同时处理不同线程内的指令。</p>\n\n<p>并发是一种现象，面对这一现象，我们首先创建多个线程，真正加快程序运行速度的，是并行技术。也就是让多个CPU同时工作。而多线程，是为了让多个CPU同时工作成为可能。</p>\n\n<h3 id=\"\">同步与异步</h3>\n\n<p>同步方法就是我们平时调用的哪些方法。因为任何有编程经验的人都知道，比如在第一行调用<font color = \"rgb(226,238,250)\"><code>foo()</code></font>方法，那么程序运行到第二行的时候，foo方法肯定是执行完了。</p>\n\n<p>所谓的异步，就是允许在执行某一个任务时，函数立刻返回，但是真正要执行的任务稍后完成。</p>\n\n<p>比如我们在点击保存按钮之后，要先把数据写到磁盘，然后更新UI。同步方法就是等到数据保存完再更新UI，而异步则是立刻从保存数据的方法返回并向后执行代码，同时真正用来保存数据的指令将在稍后执行。</p>\n\n<h3 id=\"\">区别和联系</h3>\n\n<p>假设现在有三个任务需要处理。假设单个CPU处理它们分别需要3、1、1秒。</p>\n\n<p>并行与串行，其实讨论的是处理这三个任务的速度问题。如果三个CPU并行处理，那么一共只需要3秒。相比于串行处理，节约了两秒。</p>\n\n<p>而同步/异步，其实描述的是任务之间先后顺序问题。假设需要三秒的那个是保存数据的任务，而另外两个是UI相关的任务。那么通过异步执行第一个任务，我们省去了三秒钟的卡顿时间。</p>\n\n<p>对于同步执行的三个任务来说，系统<strong>倾向于</strong>在同一个线程里执行它们。因为即使开了三个线程，也得等他们分别在各自的线程中完成。并不能减少总的处理时间，反而徒增了线程切换（这就是文章开头举的例子）</p>\n\n<p>对于异步执行的三个任务来说，系统<strong>倾向于</strong>在三个新的线程里执行他们。因为这样可以最大程度的利用CPU性能，提升程序运行效率。</p>\n\n<h3 id=\"\">总结</h3>\n\n<p>于是我们可以得出结论，在需要同时处理IO和UI的情况下，真正起作用的是异步，而不是多线程。可以不用多线程（因为处理UI非常快），但不能不用异步（否则的话至少要等IO结束）。</p>\n\n<p>注意到我把“倾向于”这三个加粗了，也就是说异步方法并不一定永远在新线程里面执行，反之亦然。在接下来关于GCD的部分会对此做出解释。</p>\n\n<h2 id=\"gcd\">GCD简介</h2>\n\n<p>GCD以block为基本单位，一个block中的代码可以为一个任务。下文中提到任务，可以理解为执行某个block</p>\n\n<p>同时，GCD中有两大最重要的概念，分别是“队列”和“执行方式”。</p>\n\n<p>使用block的过程，概括来说就是把block放进合适的队列，并选择合适的执行方式去执行block的过程。</p>\n\n<h4 id=\"\">三种队列：</h4>\n\n<ol>\n<li>串行队列（先进入队列的任务先出队列，每次只执行一个任务）  </li>\n<li>并行队列（依然是“先入先出”，不过可以形成多个任务并发）  </li>\n<li>主队列（这是一个特殊的串行队列，而且队列中的任务一定会在主线程中执行）</li>\n</ol>\n\n<h4 id=\"\">两种执行方式：</h4>\n\n<ol>\n<li>同步执行  </li>\n<li>异步执行</li>\n</ol>\n\n<p>关于同步异步、串行并行和线程的关系，下面通过一个表格来总结</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Tables/ralationship.jpg\" alt=\"\" /></p>\n\n<p>可以看到，同步方法不一定在本线程，异步方法方法也不一定新开线程（考虑主队列）。</p>\n\n<p>然而事实上，在本文一开始就揭开了“多线程”的神秘面纱，所以我们在编程时，更应该考虑的是：</p>\n\n<blockquote>\n  <p>同步 Or 异步</p>\n</blockquote>\n\n<p>以及</p>\n\n<blockquote>\n  <p>串行 Or 并行</p>\n</blockquote>\n\n<p>而非仅仅考虑是否新开线程。</p>\n\n<p>当然，了解任务运行在那个线程中也是为了更加深入的理解整个程序的运行情况，尤其是接下来要讨论的死锁问题。</p>\n\n<h2 id=\"gcd\">GCD的死锁问题</h2>\n\n<p>在使用GCD的过程中，如果<strong>向当前串行队列中同步派发一个任务</strong>，就会导致死锁。</p>\n\n<p>这句话有点绕，我们首先举个例子看看：</p>\n\n<pre><code class=\"language-swift\">override func viewDidLoad() {  \n    super.viewDidLoad()\n    let mainQueue = dispatch_get_main_queue()\n    let block = { ()  in\n        print(NSThread.currentThread())\n    }    \n    dispatch_sync(mainQueue, block)\n}\n</code></pre>\n\n<p>这段代码就会导致死锁，因为我们目前在主队列中，又将要同步地添加一个<code>block</code>到主队列(串行)中。</p>\n\n<h3 id=\"\">理论分析</h3>\n\n<p>我们知道<code>dispatch_sync</code>表示同步的执行任务，也就是说执行<code>dispatch_sync</code>后，当前队列会阻塞。而<code>dispatch_sync</code>中的block如果要在当前队列中执行，就得等待当前队列程执行完成。</p>\n\n<p>在上面这个例子中，主队列在执行<code>dispatch_sync</code>，随后队列中新增一个任务<code>block</code>。因为主队列是同步队列，所以<code>block</code>要等<code>dispatch_sync</code>执行完才能执行，但是<code>dispatch_sync</code>是同步派发，要等<code>block</code>执行完才算是结束。在主队列中的两个任务互相等待，导致了死锁。</p>\n\n<h3 id=\"\">解决方案</h3>\n\n<p>其实在通常情况下我们不必要用<code>dispatch_sync</code>，因为<code>dispatch_async</code>能够更好的利用CPU，提升程序运行速度。</p>\n\n<p>只有当我们需要保证队列中的任务必须顺序执行时，才考虑使用<code>dispatch_sync</code>。在使用<code>dispatch_sync</code>的时候应该分析当前处于哪个队列，以及任务会提交到哪个队列。</p>\n\n<h3 id=\"gcd\">GCD任务组</h3>\n\n<p>了解完队列之后，很自然的会有一个想法：我们怎么知道所有任务都已经执行完了呢？</p>\n\n<p>在单个串行队列中，这个不是问题，因为只要把回调block添加到队列末尾即可。</p>\n\n<p>但是对于并行队列，以及多个串行、并行队列混合的情况，就需要使用<font color = \"rgb(226,238,250)\"><code>dispatch_group</code></font>了。</p>\n\n<pre><code class=\"language- swift\">let group = dispatch_group_create()\n\ndispatch_group_async(group, serialQueue, { () -&gt; Void in  \n    for _ in 0..&lt;2 {\n        print(\"group-serial \\(NSThread.currentThread())\")\n    }\n})\n\ndispatch_group_async(group, serialQueue, { () -&gt; Void in  \n    for _ in 0..&lt;3 {\n        NSLog(\"group-02 - %@\", NSThread.currentThread())\n    }\n})\n\ndispatch_group_notify(group, serialQueue, { () -&gt; Void in  \n    print(\"完成 - \\(NSThread.currentThread())\")\n})\n</code></pre>\n\n<p>首先我们要通过<font color = \"rgb(226,238,250)\"><code>dispatch_group_create()</code></font>方法生成一个组。</p>\n\n<p>接下来，我们把<font color = \"rgb(226,238,250)\"><code>dispatch_async</code></font>方法换成<font color = \"rgb(226,238,250)\"><code>dispatch_group_async</code></font>。这个方法多了一个参数，第一个参数填刚刚创建的分组。</p>\n\n<p>想问<font color = \"rgb(226,238,250)\"><code>dispatch_sync</code></font>对应的分组方法是什么的童鞋面壁思过三秒钟，思考一下group出现的目的和<font color = \"rgb(226,238,250)\"><code>dispatch_sync</code></font>的特点。</p>\n\n<p>最后调用<font color = \"rgb(226,238,250)\"><code>dispatch_group_create</code></font>方法。这个方法表示把第三个参数block传入第二个参数队列中去。而且可以保证第三个参数block执行时，group中的所有任务已经全部完成。</p>\n\n<h3 id=\"dispatch_group\">dispatch_group</h3>\n\n<p><font color = \"rgb(226,238,250)\"><code>dispatch_group_wait</code></font>方法是一个很有用的方法，它的完整定义如下：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>dispatch_group_wait(group: dispatch_group_t, _ timeout: dispatch_time_t) -&gt; Int</code></font></p>\n\n<p>第一个参数表示要等待的group，第二个则表示等待时间。返回值表示经过指定的等待时间，属于这个group的任务是否已经全部执行完，如果是则返回0，否则返回非0。</p>\n\n<p>第二个<font color = \"rgb(226,238,250)\"><code>dispatch_time_t</code></font>类型的参数还有两个特殊值：<font color = \"rgb(226,238,250)\"><code>DISPATCH_TIME_NOW</code></font>和<font color = \"rgb(226,238,250)\"><code>DISPATCH_TIME_FOREVER</code></font>。</p>\n\n<p>前者表示立刻检查属于这个group的任务是否已经完成，后者则表示一直等到属于这个group的任务全部完成。</p>\n\n<h3 id=\"dispatch_after\">dispatch_after方法</h3>\n\n<p>通过GCD还可以进行简单的定时操作，比如在1秒后执行某个block。代码如下：</p>\n\n<pre><code class=\"language- swift\">let mainQueue = dispatch_get_main_queue()  \nlet time = dispatch_time(DISPATCH_TIME_NOW, Int64(3) * Int64(NSEC_PER_SEC))  \nNSLog(\"%@\",NSThread.currentThread())  \ndispatch_after(time, mainQueue, {() in NSLog(\"%@\",NSThread.currentThread())})  \n</code></pre>\n\n<p></font>和<font color = \"rgb(226,238,250)\"><code>dispatch_after</code></font>方法有三个参数。第一个表示时间，也就是从现在起往后三秒钟。第二三个参数分别表示要提交的任务和提交到哪个队列。</p>\n\n<p>需要注意的是</font>和<font color = \"rgb(226,238,250)\"><code>dispatch_after</code></font>仅表示在指定时间后提交任务，而非执行任务。如果任务提交到主队列，它将在main runloop中执行，对于每隔1/60秒执行一次的RunLoop，任务最多有可能在3+1/60秒后执行。</p>\n\n<h2 id=\"nsoperation\">NSOperation</h2>\n\n<p><font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>和<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>主要涉及这几个方面：</p>\n\n<ol>\n<li><font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>和</font>和<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>用法介绍  </li>\n<li><font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>的暂停、恢复和取消  </li>\n<li>通过KVO对<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>的状态进行检测  </li>\n<li>多个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>的之间的依赖关系</li>\n</ol>\n\n<p>从简单意义上来说，<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>是对GCD中的block进行的封装，它也表示一个要被执行的任务。</p>\n\n<p>与GCD中的block类似，<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>对象有一个<font color = \"rgb(226,238,250)\"><code>start()</code></font>方法表示开始执行这个任务。</p>\n\n<p>不仅如此，<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>表示的任务还可以被取消。它还有三种状态<font color = \"rgb(226,238,250)\"><code>isExecuted</code></font>、<font color = \"rgb(226,238,250)\"><code>isFinished</code></font>和<font color = \"rgb(226,238,250)\"><code>isCancelled</code></font>以方便我们通过KVC对它的状态进行监听。</p>\n\n<p>想要开始执行一个任务可以这么写：</p>\n\n<pre><code class=\"language-swift\">let operation = NSBlockOperation { () -&gt; Void in  \n    print(NSThread.currentThread())\n}\noperation.addExecutionBlock { () -&gt; Void in  \n    print(\"execution block1 -- \\(NSThread.currentThread())\")\n}\noperation.start()  \n</code></pre>\n\n<p>以上代码会得到这样的执行结果：</p>\n\n<pre><code class=\"language-swift\">&lt;NSThread: 0x7f89b1c070f0&gt;{number = 1, name = main}  \nexecution block1 -- &lt;NSThread: 0x7f89b1e17030&gt;{number = 2, name = (null)}  \n</code></pre>\n\n<p>首先我们创建了一个<font color = \"rgb(226,238,250)\"><code>NSBlockOperation</code></font>，并且设置好它的block，也就是将要执行的任务。这个任务会在主线程中执行。</p>\n\n<p>用<font color = \"rgb(226,238,250)\"><code>NSBlockOperation</code></font>是因为<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>是一个基类，不应该直接生成<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>对象，而是应该用它的子类。<font color = \"rgb(226,238,250)\"><code>NSBlockOperation</code></font>是苹果预定义的子类，它可以用来封装一个或多个block，后面会介绍如何自己创建<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>的子类。</p>\n\n<p>同时，还可以调用<font color = \"rgb(226,238,250)\"><code>addExecutionBlock</code></font>方法追加几个任务，这些任务会并行执行（也就是说很有可能运行在别的线程里）。</p>\n\n<p>最后，调用<font color = \"rgb(226,238,250)\"><code>start</code></font>方法让<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>方法运行起来。<font color = \"rgb(226,238,250)\"><code>start</code></font>是一个<strong>同步</strong>方法。</p>\n\n<h2 id=\"nsoperationqueue\">NSOperationQueue</h2>\n\n<p>刚刚我们知道，默认的<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>是同步执行的。简单的看一下<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>类的定义会发现它有一个只读属性<font color = \"rgb(226,238,250)\"><code>asynchronous</code></font></p>\n\n<p>这意味着如果想要异步执行，就需要自定义<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>的子类。或者使用<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font></p>\n\n<p><font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>类似于GCD中的队列。我们知道GCD中的队列有三种：<strong>主队列</strong>、<strong>串行队列</strong>和<strong>并行队列</strong>。<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>更简单，只有两种：<strong>主队列</strong>和<strong>非主队列</strong>。</p>\n\n<p>我们自己生成的<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>对象都是非主队列，主队列可以用<font color = \"rgb(226,238,250)\"><code>NSOperationQueue.mainQueue</code></font>取得。</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>的主队列是串行队列，而且其中所有<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>都会在主线程中执行。</p>\n\n<p>对于非主队列来说，一旦一个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>被放入其中，那这个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>一定是并发执行的。因为<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>会为每一个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>创建线程并调用它的<font color = \"rgb(226,238,250)\"><code>start</code></font>方法。</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>有一个属性叫<font color = \"rgb(226,238,250)\"><code>maxConcurrentOperationCount</code></font>，它表示最多支持多少个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>并发执行。如果<font color = \"rgb(226,238,250)\"><code>maxConcurrentOperationCount</code></font>被设为1，就以为这个队列是串行队列。</p>\n\n<p>因此，<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>和GCD中的队列有这样的对应关系：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Tables/relationship2.jpg\" alt=\"\" /></p>\n\n<p>回到开头的问题，如何利用<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>实现异步操作呢，代码如下：</p>\n\n<pre><code class=\"language-swift\">let operationQueue = NSOperationQueue()  \nlet operation = NSBlockOperation { () -&gt; Void in  \n    print(NSThread.currentThread())\n}\n    operation.addExecutionBlock { () -&gt; Void in\n    print(\"execution block1 -- \\(NSThread.currentThread())\")\n}\noperationQueue.addOperation(operation)  \nprint(\"操作结束\")  \n</code></pre>\n\n<p>得到运行结果如下：</p>\n\n<pre><code class=\"language-swift\">操作结束\n&lt;NSThread: 0x7fd51d2111b0&gt;{number = 2, name = (null)}  \nexecution block1 -- &lt;NSThread: 0x7fd51d21bd50&gt;{number = 3, name = (null)}\n</code></pre>\n\n<p>使用<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>来执行任务与之前的区别在于，首先创建一个非主队列。然后用<font color = \"rgb(226,238,250)\"><code>addOperation</code></font>方法替换之前的<font color = \"rgb(226,238,250)\"><code>start</code></font>方法。刚刚已经说过，<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>会为每一个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>建立线程并调用他们的<font color = \"rgb(226,238,250)\"><code>start</code></font>方法。</p>\n\n<p>观察一下运行结果，所有的<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>都没有在主线程执行，从而成功的实现了异步、并行处理。</p>\n\n<h2 id=\"nsoperation\">NSOperation新特性</h2>\n\n<p>在学习<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>的时候，我们总是用GCD的概念去解释。但是<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>作为对GCD更高层次的封装，它有着一些GCD无法实现（或者至少说很难实现）的特性。由于<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>和<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>良好的封装，这些新特性的使用都非常简单。</p>\n\n<h3 id=\"\">取消任务</h3>\n\n<p>如果我们有两次网络请求，第二次请求会用到第一次的数据。如果此时网络情况不好，第一次请求超时了，那么第二次请求也没有必要发送了。当然，用户也有可能人为地取消某个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>。</p>\n\n<p>当某个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>被取消时，我们应该尽可能的清除<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>内部的数据并且把<font color = \"rgb(226,238,250)\"><code>cancelled</code></font>和<font color = \"rgb(226,238,250)\"><code>finished</code></font>设为<font color = \"rgb(226,238,250)\"><code>true</code></font>，把<font color = \"rgb(226,238,250)\"><code>executing</code></font>设为<font color = \"rgb(226,238,250)\"><code>false</code></font>。</p>\n\n<pre><code class=\"language-swift\">//取消某个NSOperation\noperation1.cancel()\n\n//取消某个NSOperationQueue剩余的NSOperation\nqueue.cencelAllOperations()\n</code></pre>\n\n<h3 id=\"\">设置依赖</h3>\n\n<p>依然考虑刚刚所说的两次网络请求的例子。因为第二次请求会用到第一次的数据，所以我们要保证发出第二次请求的时候第一个请求已经执行完。但是我们同时还希望利用到<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>的并发特性（因为可能不止这两个任务）。</p>\n\n<p>这时候我们可以设置<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>之间的依赖关系。语法非常简洁：</p>\n\n<pre><code class=\"language-swift\">operation2.addDependency(operation1)  \n</code></pre>\n\n<p>需要注意的是<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>之间的相互依赖会导致死锁</p>\n\n<h3 id=\"nsoperationqueue\">NSOperationQueue暂停与恢复</h3>\n\n<p>这个更加简单，只要修改<font color = \"rgb(226,238,250)\"><code>suspended</code></font>属性即可</p>\n\n<pre><code class=\"language-swift\">queue.suspended = true //暂停queue中所有operation  \nqueue.suspended = false //恢复queue中所有operation  \n</code></pre>\n\n<h3 id=\"nsoperation\">NSOperation优先级</h3>\n\n<p>GCD中，任务（block）是没有优先级的，而队列具有优先级。和GCD相反，我们一般考虑<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>的优先级</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>有一个<font color = \"rgb(226,238,250)\"><code>NSOperationQueuePriority</code></font>枚举类型的属性<font color = \"rgb(226,238,250)\"><code>queuePriority</code></font></p>\n\n<pre><code class=\"language-swift\">public enum NSOperationQueuePriority : Int {  \n    case VeryLow\n    case Low\n    case Normal\n    case High\n    case VeryHigh\n}\n</code></pre>\n\n<p>需要注意的是，<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>也不能完全保证优先级高的任务一定先执行。</p>\n\n<h2 id=\"nsoperationgcd\">NSOperation和GCD如何选择</h2>\n\n<p>其实经过这两篇文章的分析，我们大概对<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>和<font color = \"rgb(226,238,250)\"><code>GCD</code></font>都有了比较详细的了解，同时在亲自运用这两者的过程中有了自己的理解。</p>\n\n<p>GCD以block为单位，代码简洁。同时GCD中的队列、组、信号量、source、barriers都是组成并行编程的基本原语。对于一次性的计算，或是仅仅为了加快现有方法的运行速度，选择轻量化的GCD就更加方便。</p>\n\n<p>而<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>可以用来规划一组任务之间的依赖关系，设置它们的优先级，任务能被取消。队列可以暂停、恢复。<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>还可以被子类化。这些都是GCD所不具备的。</p>\n\n<p>所以我们要记住的是：</p>\n\n<blockquote>\n  <p><strong><font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>和GCD并不是互斥的，有效地结合两者可以开发出更棒的应用</strong></p>\n</blockquote>\n\n<h2 id=\"gcd\">GCD进阶</h2>\n\n<p><code>NSOperation</code>有自己独特的优势，<code>GCD</code>也有一些强大的特性。接下来我们由浅入深，讨论以下几个部分：</p>\n\n<ul>\n<li><font color =\"rgb(226,238,250)\"><code>dispatch_suspend</code></font>和<font color =\"rgb(226,238,250)\"><code>dispatch_resume</code></font></li>\n<li><font color =\"rgb(226,238,250)\"><code>dispathc_once</code></font></li>\n<li><font color =\"rgb(226,238,250)\"><code>dispatch_barrier_async</code></font></li>\n<li><font color =\"rgb(226,238,250)\"><code>dispatch_semaphore</code></font></li>\n</ul>\n\n<h3 id=\"dispatch_suspenddispatch_resume\">dispatch_suspend和dispatch_resume</h3>\n\n<p>我们知道<font color =\"rgb(226,238,250)\"><code>NSOperationQueue</code></font>有暂停(suspend)和恢复(resume)。其实GCD中的队列也有类似的功能。用法也非常简单：</p>\n\n<pre><code class=\"language-swift\">dispatch_suspend(queue) //暂停某个队列  \ndispatch_resume(queue)  //恢复某个队列  \n</code></pre>\n\n<p>这些函数不会影响到队列中已经执行的任务，队列暂停后，已经添加到队列中但还没有执行的任务不会执行，直到队列被恢复。</p>\n\n<h3 id=\"dispathc_once\">dispathc_once</h3>\n\n<p>首先我们来看一下最简单的<code>dispathc_once</code>函数，这在单例模式中被广泛使用。</p>\n\n<ul>\n<li><font color =\"rgb(226,238,250)\"><code>dispathc_once</code></font>函数可以确保某个block在应用程序执行的过程中只被处理一次，而且它是线程安全的。所以单例模式可以很简单的实现，以OC中Manager类为例</li>\n</ul>\n\n<pre><code class=\"language-objective-c\">+ (Manager *)sharedInstance {\n    static Manager *sharedManagerInstance = nil;\n    static dispatch_once_t once;\n\n    dispatch_once($once, ^{\n        sharedManagerInstance = [[Manager alloc] init];\n    });\n\n    return sharedManagerInstance;\n}\n</code></pre>\n\n<p>这段代码中我们创建一个值为nil的<font color =\"rgb(226,238,250)\"><code>sharedManagerInstance</code></font>静态对象，然后把它的初始化代码放到<font color =\"rgb(226,238,250)\"><code>dispatch_once</code></font>中完成。</p>\n\n<p>这样，只有第一次调用<font color =\"rgb(226,238,250)\"><code>sharedInstance</code></font>方法时才会进行对象的初始化，以后每次只是返回<font color =\"rgb(226,238,250)\"><code>sharedManagerInstance</code></font>而已。</p>\n\n<h3 id=\"dispatch_barrier_async\">dispatch_barrier_async</h3>\n\n<p>我们知道数据在写入时，不能在其他线程读取或写入。但是多个线程同时读取数据是没有问题的。所以我们可以把读取任务放入并行队列，把写入任务放入串行队列，并且保证写入任务执行过程中没有读取任务可以执行。</p>\n\n<p>这样的需求比较常见，GCD提供了一个非常简单的解决办法——<font color =\"rgb(226,238,250)\"><code>dispatch_barrier_async</code></font></p>\n\n<p>假设我们有四个读取任务，在第二三个任务之间有一个写入任务，代码大概是这样：</p>\n\n<pre><code class=\"language-swift\">let queue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_CONCURRENT)\n\ndispatch_async(queue, block1_for_reading)  \ndispatch_async(queue, block2_for_reading)\n\n/*\n    这里插入写入任务，比如：\n    dispatch_async(queue, block_for_writing)\n*/\n\ndispatch_async(queue, block3_for_reading)  \ndispatch_async(queue, block4_for_reading)\n</code></pre>\n\n<p>如果代码这样写，由于这几个block是并发执行，就有可能在前两个block中读取到已经修改了的数据。如果是有多写入任务，那问题更严重，可能会有数据竞争。</p>\n\n<p>如果使用<font color =\"rgb(226,238,250)\"><code>dispatch_barrier_async</code></font>函数，代码就可以这么写：</p>\n\n<pre><code class=\"language-swift\">dispatch_async(queue, block1_for_reading)  \ndispatch_async(queue, block2_for_reading)\n\ndispatch_barrier_async(queue, block_for_writing)\n\ndispatch_async(queue, block3_for_reading)  \ndispatch_async(queue, block4_for_reading)  \n</code></pre>\n\n<p><font color =\"rgb(226,238,250)\"><code>dispatch_barrier_async</code></font>会把并行队列的运行周期分为这三个过程：</p>\n\n<ol>\n<li>首先等目前追加到并行队列中所有任务都执行完成  </li>\n<li>开始执行<font color =\"rgb(226,238,250)\"><code>dispatch_barrier_async</code></font>中的任务，这时候即使向并行队列提交任务，也不会执行  </li>\n<li><font color =\"rgb(226,238,250)\"><code>dispatch_barrier_async</code></font>中的任务执行完成后，并行队列恢复正常。</li>\n</ol>\n\n<p>总的来说，<font color =\"rgb(226,238,250)\"><code>dispatch_barrier_async</code></font>起到了“<strong>承上启下</strong>”的作用。它保证此前的任务都先于自己执行，此后的任务也迟于自己执行。正如barrier的含义一样，它起到了一个栅栏、或是分水岭的作用。</p>\n\n<p>这样一来，使用并行队列和<font color =\"rgb(226,238,250)\"><code>dispatc_barrier_async</code></font>方法，就可以高效的进行数据和文件读写了。</p>\n\n<h3 id=\"dispatch_semaphore\">dispatch_semaphore</h3>\n\n<p>首先介绍一下信号量(semaphore)的概念。信号量是持有计数的信号，不过这么解释等于没解释。我们举个生活中的例子来看看。</p>\n\n<p>假设有一个房子，它对应进程的概念，房子里的人就对应着线程。一个进程可以包括多个线程。这个房子(进程)有很多资源，比如花园、客厅等，是所有人(线程)共享的。</p>\n\n<p>但是有些地方，比如卧室，最多只有两个人能进去睡觉。怎么办呢，在卧室门口挂上两把钥匙。进去的人(线程)拿着钥匙进去，没有钥匙就不能进去，出来的时候把钥匙放回门口。</p>\n\n<p>这时候，门口的钥匙数量就称为<strong>信号量(Semaphore)</strong>。很明显，信号量为0时需要等待，信号量不为零时，减去1而且不等待。</p>\n\n<p>在GCD中，创建信号量的语法如下：</p>\n\n<pre><code class=\"language-swift\">var semaphore = dispatch_semaphore_create(2)  \n</code></pre>\n\n<p>这句代码通过<font color =\"rgb(226,238,250)\"><code>dispatch_semaphore_create</code></font>方法创建一个信号量并设置初始值为2。然后就可以调用<font color =\"rgb(226,238,250)\"><code>dispatch_semaphore_wait</code></font>方法了。</p>\n\n<pre><code class=\"language-swift\">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)  \n</code></pre>\n\n<p><font color =\"rgb(226,238,250)\"><code>dispatch_semaphore_wait</code></font>方法表示一直等待直到信号量的值大于等于一，当这个方法执行后，会把第一个信号量参数的值减1。</p>\n\n<p>第二个参数是一个<font color =\"rgb(226,238,250)\"><code>dispatch_time_t</code></font>类型的时间，它表示这个方法最大的等待时间。这在第一章中已经讲过，比如\n<font color =\"rgb(226,238,250)\"><code>DISPATCH_TIME_FOREVER</code></font>表示永久等待。</p>\n\n<p>返回值也和<font color =\"rgb(226,238,250)\"><code>dispatch_group_wait</code></font>方法一样，返回0表示在规定的等待时间内第一个参数信号量的值已经大于等于1，否则表示已超过规定等待时间，但信号量的值还是0。</p>\n\n<p><font color =\"rgb(226,238,250)\"><code>dispatch_semaphore_wait</code></font>方法返回0，因为此时的信号量的值大于等于一，任务获得了可以执行的权限。这时候我们就可以安全的执行需要进行排他控制的任务了。</p>\n\n<p>任务结束时还需要调用\n<font color =\"rgb(226,238,250)\"><code>dispatch_semaphore_signal()</code></font>方法，将信号量的值加1。这类似于之前所说的，从卧室出来要把锁放回门上，否则后来的人就无法进入了。</p>\n\n<p>我们来看一个完整的例子：</p>\n\n<pre><code class=\"language-swift\">var semaphore = dispatch_semaphore_create(1)  \nlet queue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_CONCURRENT)  \nvar array: [Int] = []\n\nfor i in 1...100000 {  \n    dispatch_async(queue, { () -&gt; Void in\n        /*\n            某个线程执行到这里，如果信号量值为1，那么wait方法返回1，开始执行接下来的操作。\n            与此同时，因为信号量变为0，其它执行到这里的线程都必须等待\n        */\n        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)\n\n        /*\n            执行了wait方法后，信号量的值变成了0。可以进行接下来的操作。\n            这时候其它线程都得等待wait方法返回。\n            可以对array修改的线程在任意时刻都只有一个，可以安全的修改array\n        */\n        array.append(i)\n\n        /*\n            排他操作执行结束，记得要调用signal方法，把信号量的值加1。\n            这样，如果有别的线程在等待wait函数返回，就由最先等待的线程执行。\n        */\n        dispatch_semaphore_signal(semaphore)\n    })\n}\n</code></pre>\n\n<p>如果你想知道不用信号量会出什么问题，可以看我的另一篇文章<a href=\"http://115.159.123.174/swiftarrayappend/\">Swift数组append方法研究</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T07:16:14.000Z","created_by":1,"updated_at":"2016-02-14T11:27:46.000Z","updated_by":1,"published_at":"2015-12-06T07:35:00.000Z","published_by":1},{"id":4,"uuid":"f33ab947-dc99-42d3-b104-f1427e37a08e","title":"找数组中出现次数超过一半的数字","slug":"arrayoccurmorethanhalf","markdown":"数组中有一个数字出现次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组`{1,2,3,2,2,2,5,4,2}`。\n\n由于数字2在数组中出现了5次，超过数组长度一半，因此输出2\n\n#问题分析\n\n首先想到的是，可以维护一个数据结构用来存储每个数字对应的出现次数。没遇到一个新的数字就去找这个数字是否出现过，如果出现过就加1.这种思路最简单，但是时间复杂度是O(n^2)。\n\n稍做优化，可以把数组排序，然后中位数一定是要找的数。这样的时间复杂度是O(nlogn)\n\n还可以再试着优化，第一种方法之所以需要O(n^2)的时间复杂度是因为找一个数是否已经出现过，需要O（n）的时间复杂度，拿能不能用Hash呢。很不幸的是也不行，因为不知道数字的取值范围，无法构造hash函数。否则的话，也不用hash，直接基数排序就解决问题了。\n\n似乎最快的算法就是排序的O（nlogn）了。如果还想优化，关键在于利用“**出现次数超过一半**”这个条件的数学性质。\n\n#理论基础\n\n为了后面的解释，我们首先定义：\n\n> 对于数组A，出现次数超过一半的数记为H(A)\n\n还是以之前的数组A`{1,2,3,2,2,2,5,4,2}`为例,首先有H(A) = 2，我们观察一下这个2的特点：\n\n如果把前两个数`1`和`2`去掉，剩下的数组A'是`{3,2,2,2,5,4,2}`，H(A')依然为2！\n\n更进一步，我们可以这么想，既然前两个数去掉之后不影响找出现次数超过数组长度的一半的数字，那么任意去掉相邻的两个数字也不影响呢。\n\n也就是说对于任意数组A和A去掉两个相邻数字的子数组A'是否都有:`H(A) = H(A')`\n\n很不幸，这个结论也不成立，因为如果在刚刚的数组A中去掉连续的两个2，就不对了。但是只要稍稍把结论修改一下就是成立的：\n\n> 对于任意数组A，去掉A中任意两个相邻但不相等的数，得到数组A',总有`H(A) = H(A')`\n\n结论很好证明：设H(A) = p,去掉的两个数中最多有一个p，由于p原来出现的次数大于n/2，现在p-1自然一定大于(n-2)/2。所以`H（A'）= p`。\n\n#编程实现\n\n有了刚刚的结论，再看这个数组就简单多了。只要把数组从头到尾遍历一遍，剔除相邻的不同的数就可以。比如数组中有一段是`{1，2，3，4}`，可以预见到，有可能是`{2，3}`先被比较，然后被剔除，接着是`{1，4}`变成相邻的，接着被剔除。\n\n为了避免反复循环，在一个循环里解决问题，自然而然的想到了一个数据结构——“栈”。\n\n只要对于数组中的每一个元素，如果栈为空或这个元素与栈顶元素相同，则这个元素入栈，否则栈顶元素出栈即可。这样一来，不相同的数即使不相邻，迟早也会一起出栈（可以把用来和栈顶做比较元素想象为先入栈再出栈）。\n\n所以这样一来，代码会非常简洁优雅：\n\n\n```C++\nint findNumber(std::vector<int> v){\n    std::stack<int> stack = std::stack<int>();\n    for (int i = 0; i < v.size(); ++i) {\n        if (stack.empty() || stack.top() == v[i]) {\n            stack.push(v[i]);\n        }\n        else{\n            stack.pop();\n        }\n    }\n    return stack.top();\n}\n```\n\n#正确性证明\n\n对于H(A)这个数来说，它想要出栈的唯一可能是遇到一个和它不同的数（之前说过，如果把H(A)和与它不同栈顶元素比较，可以理解为H(A)先进栈再出栈）。\n\n而在数组A中，剩下所有的数出现次数的和一定小于H(A)出现的次数。所以最终的栈里一定只剩下若干个H(A)。\n\n#拓展1——判断是否存在这样的数\n\n之前我们都是基于题干所说的，出现次数超过一半的数是存在的，这一前提进行分析。如果把题干改为：\n> 判断出现次数超过一半的数是否存在，如果存在则找出这个数\n\n这时候，我们依然用同样的方法先得到之前所说的栈。这个栈如果为空，则H(A)不存在（因为已经证明H(A)存在的话栈中的数都等于H(A)）。如果不为空，也只有可能有一种数字，不妨记为x。\n\nx不一定是要找的H(A)，因为H(A)不一定存在。我们只能说如果H(A)存在的话，`x = H(A)`。所以只要重新遍历数组，看看x的出现次数是否超过n/2即可。\n\n#拓展2——不少于一半\n\n看到一个非常有意思的问题，即把题干改为找到出现次数不少于一半的数。其实非常简单的方法是判断数组的第一个元素是否满足要求。如果不满足的话，剩下的n-1个数构成数组A'，则H(A')就是要找的数。相当于划归为了之前已经解决的问题。","html":"<p>数组中有一个数字出现次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组<code>{1,2,3,2,2,2,5,4,2}</code>。</p>\n\n<p>由于数字2在数组中出现了5次，超过数组长度一半，因此输出2</p>\n\n<h1 id=\"\">问题分析</h1>\n\n<p>首先想到的是，可以维护一个数据结构用来存储每个数字对应的出现次数。没遇到一个新的数字就去找这个数字是否出现过，如果出现过就加1.这种思路最简单，但是时间复杂度是O(n^2)。</p>\n\n<p>稍做优化，可以把数组排序，然后中位数一定是要找的数。这样的时间复杂度是O(nlogn)</p>\n\n<p>还可以再试着优化，第一种方法之所以需要O(n^2)的时间复杂度是因为找一个数是否已经出现过，需要O（n）的时间复杂度，拿能不能用Hash呢。很不幸的是也不行，因为不知道数字的取值范围，无法构造hash函数。否则的话，也不用hash，直接基数排序就解决问题了。</p>\n\n<p>似乎最快的算法就是排序的O（nlogn）了。如果还想优化，关键在于利用“<strong>出现次数超过一半</strong>”这个条件的数学性质。</p>\n\n<h1 id=\"\">理论基础</h1>\n\n<p>为了后面的解释，我们首先定义：</p>\n\n<blockquote>\n  <p>对于数组A，出现次数超过一半的数记为H(A)</p>\n</blockquote>\n\n<p>还是以之前的数组A<code>{1,2,3,2,2,2,5,4,2}</code>为例,首先有H(A) = 2，我们观察一下这个2的特点：</p>\n\n<p>如果把前两个数<code>1</code>和<code>2</code>去掉，剩下的数组A'是<code>{3,2,2,2,5,4,2}</code>，H(A')依然为2！</p>\n\n<p>更进一步，我们可以这么想，既然前两个数去掉之后不影响找出现次数超过数组长度的一半的数字，那么任意去掉相邻的两个数字也不影响呢。</p>\n\n<p>也就是说对于任意数组A和A去掉两个相邻数字的子数组A'是否都有:<code>H(A) = H(A')</code></p>\n\n<p>很不幸，这个结论也不成立，因为如果在刚刚的数组A中去掉连续的两个2，就不对了。但是只要稍稍把结论修改一下就是成立的：</p>\n\n<blockquote>\n  <p>对于任意数组A，去掉A中任意两个相邻但不相等的数，得到数组A',总有<code>H(A) = H(A')</code></p>\n</blockquote>\n\n<p>结论很好证明：设H(A) = p,去掉的两个数中最多有一个p，由于p原来出现的次数大于n/2，现在p-1自然一定大于(n-2)/2。所以<code>H（A'）= p</code>。</p>\n\n<h1 id=\"\">编程实现</h1>\n\n<p>有了刚刚的结论，再看这个数组就简单多了。只要把数组从头到尾遍历一遍，剔除相邻的不同的数就可以。比如数组中有一段是<code>{1，2，3，4}</code>，可以预见到，有可能是<code>{2，3}</code>先被比较，然后被剔除，接着是<code>{1，4}</code>变成相邻的，接着被剔除。</p>\n\n<p>为了避免反复循环，在一个循环里解决问题，自然而然的想到了一个数据结构——“栈”。</p>\n\n<p>只要对于数组中的每一个元素，如果栈为空或这个元素与栈顶元素相同，则这个元素入栈，否则栈顶元素出栈即可。这样一来，不相同的数即使不相邻，迟早也会一起出栈（可以把用来和栈顶做比较元素想象为先入栈再出栈）。</p>\n\n<p>所以这样一来，代码会非常简洁优雅：</p>\n\n<pre><code class=\"language-C++\">int findNumber(std::vector&lt;int&gt; v){  \n    std::stack&lt;int&gt; stack = std::stack&lt;int&gt;();\n    for (int i = 0; i &lt; v.size(); ++i) {\n        if (stack.empty() || stack.top() == v[i]) {\n            stack.push(v[i]);\n        }\n        else{\n            stack.pop();\n        }\n    }\n    return stack.top();\n}\n</code></pre>\n\n<h1 id=\"\">正确性证明</h1>\n\n<p>对于H(A)这个数来说，它想要出栈的唯一可能是遇到一个和它不同的数（之前说过，如果把H(A)和与它不同栈顶元素比较，可以理解为H(A)先进栈再出栈）。</p>\n\n<p>而在数组A中，剩下所有的数出现次数的和一定小于H(A)出现的次数。所以最终的栈里一定只剩下若干个H(A)。</p>\n\n<h1 id=\"1\">拓展1——判断是否存在这样的数</h1>\n\n<p>之前我们都是基于题干所说的，出现次数超过一半的数是存在的，这一前提进行分析。如果把题干改为：</p>\n\n<blockquote>\n  <p>判断出现次数超过一半的数是否存在，如果存在则找出这个数</p>\n</blockquote>\n\n<p>这时候，我们依然用同样的方法先得到之前所说的栈。这个栈如果为空，则H(A)不存在（因为已经证明H(A)存在的话栈中的数都等于H(A)）。如果不为空，也只有可能有一种数字，不妨记为x。</p>\n\n<p>x不一定是要找的H(A)，因为H(A)不一定存在。我们只能说如果H(A)存在的话，<code>x = H(A)</code>。所以只要重新遍历数组，看看x的出现次数是否超过n/2即可。</p>\n\n<h1 id=\"2\">拓展2——不少于一半</h1>\n\n<p>看到一个非常有意思的问题，即把题干改为找到出现次数不少于一半的数。其实非常简单的方法是判断数组的第一个元素是否满足要求。如果不满足的话，剩下的n-1个数构成数组A'，则H(A')就是要找的数。相当于划归为了之前已经解决的问题。</p>","image":"http://7xonij.com1.z0.glb.clouddn.com/ghost/1/e3/7161ecc907a4ee5f13214f2cac9d4.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-11T15:08:45.000Z","created_by":1,"updated_at":"2016-01-14T07:59:53.000Z","updated_by":1,"published_at":"2015-11-28T15:09:00.000Z","published_by":1},{"id":15,"uuid":"e3f2eac1-8735-45ca-ade5-c307f5d9dd08","title":"UIKit性能调优实战讲解","slug":"uikitxing-neng-diao-you-shi-zhan-jiang-jie","markdown":"在使用UIKit的过程中，性能优化是永恒的话题。很多人都看过分析优化滑动性能的文章，但其中不少文章只介绍了优化方法却对背后的原理避而不谈，或者是晦涩难懂而且读者缺乏实践体验的机会。不妨思考一下下面的问题自己是否有一个清晰的认识：\n\n1. 为什么要把控件尽量设置成不透明的，如果是透明的会有什么影响，如何检测这种影响？\n2. 为什么cell中的图片，尽可能要使用正确的大小、格式，如果错误会有什么影响，如何检测这种影响？\n3. 为什么设置阴影和圆角有可能影响滑动时流畅度？\n4. `shouldRasterize`和离屏渲染的关系是什么，何时应该使用？\n\n本文会结合Instrument分析影响性能的因素，提出优化方案并解释背后的原理，项目初始demo的下载地址在[我的Github](https://github.com/bestswifter/MySampleCode/tree/master/GraphicsPerformance-Starter)，强烈建议每一位读者下载下来随着我一步一步调试、优化。如果觉得对自己有帮助，可以给一个Star表示支持。后面的图片较多，流量党慎入。\n\n# 基本概念\n\n打开项目后，只要CustomTableCell.swift文件即可，它实现了自定义的`UITableViewCell`以及内部的UI布局，因为重点在于性能优化，代码实现的就比较随意。\n\n首先按下`Command + I`打开Instrument，本文主要用到的是Core Animation工具：\n\n![打开Core Animation调试](http://images.bestswifter.com/UIKitPerformance/Instrument.png)\n\n注意这个调试必须使用真机，点击左上角的红色圆圈就会开始录制。新手可能不太熟悉，这里简单介绍一下调试界面：\n\n![调试界面](http://images.bestswifter.com/UIKitPerformance/Introduce.png)\n\n我们需要了解两个两个区域：\n\n1. 这里记录了实时的fps数值，有些地方是0是因为屏幕没有滑动\n2. 这是重中之重，接下来我会带大家逐个理解、体验这些调试选项\n\n有过游戏经验的人也许对**fps**这个概念比较熟悉。我们知道任何屏幕总是有一个刷新率，比如iphone推荐的刷新率是60Hz，也就是说GPU每秒钟刷新屏幕60次，因此两次刷新之间的间隔为16.67ms。这段时间内屏幕内容保持不变，称为**一帧(frame)**，fps表示**frames per second**，也就是每秒钟显示多少帧画面。对于静止不变的内容，我们不需要考虑它的刷新率，但在执行动画或滑动时，fps的值直接反映出滑动的流畅程度。\n\n# 调试、优化\n\n### 图层混合\n\n首先我们要明白像素的概念，屏幕上每一个点都是一个像素，像素有R、G、B三种颜色构成(有时候还带有alpha值)。如果某一块区域上覆盖了多个layer,最后的显示效果受到这些layer的共同影响。举个例子，上层是蓝色(RGB=0,0,1),透明度为50%，下层是红色(RGB=1,0,0)。那么最终的显示效果是紫色(RGB=0.5,0,0.5)。这种颜色的混合(blending)需要消耗一定的GPU资源，因为实际上可能不止只有两层。如果只想显示最上层的蓝色，可以把它的透明度设置为100%，这样GPU会忽略下面所有的layer，从而节约了很多不必要的运算。\n\n第一个调试选项\"Color Blended Layers\"正是用于检测哪里发生了图层混合，并用红色标记出来。因此我们需要尽可能减少看到的红色区域。一旦发现应该想法设法消除它。开始调试后勾选这个选项，我们在手机上可以看到如下的场景：\n\n![Color Blended Layers](http://images.bestswifter.com/UIKitPerformance/blendedlayer.png)\n\n很多文章里说把控件设置为`opaque = true`，其原理就是希望避免图层混合，然而这种调优一般情况下用处不大。因为`UIView`的`opaque`属性默认值就是`true`，也就是说只要不是人为设置成透明，都不会出现图层混合。比如demo中就没有任何透明的控件。\n\n对于`UIImageView`来说，不仅它自身需要是不透明的，它的图片也不能含有alpha通道，这就是为什么图中第三个图片是绿色，而前两个图片是红色的原因。由于本人对PS和图像几乎一窍不通，恕我不能演示如何消除这些图片的红色。我从网上找了一个美女的头像来说明，图像自身的性质可能会对结果有影响，因此如果你确定自己的代码没有问题，而且出现了图层混合，请联系美工或后台解决。\n\n个人认为比`opaque`属性更重要的是`backgroundColor`属性，如果不设置这个属性，控件依然被认为是透明的，所以我们做的第一个优化是在`CustomTableCell`类的`init`方法中添加一行代码：\n\n```\nlabel.backgroundColor = UIColor.whiteColor()\n```\n\n虽然在白色背景下，这行代码无法肉眼看到效果，但重新调试后我们可以发现label的红色消失了。也正是因为对背景颜色的不重视，它成了影响滑动性能的第一个杀手。\n\nPS：如果label文字有中文，依然会出现图层混合，这是因为此时label多了一个`sublayer`，如果有好的解决办法欢迎告诉我。\n\n### 光栅化\n\n光栅化是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样比较消耗资源的静态内容进行缓存，可以得到一定幅度的性能提升。demo中的这一行代码表示将label的layer光栅化：\n\n```swift\nlabel.layer.shouldRasterize = true\n```\n\nInstrument中，第二个调试选项是“Color Hits Green and Misses Red”，它表示如果命中缓存则显示为绿色，否则显示为红色，显然绿色越多越好，红色越少越好。勾选这个选项后我们看到如下的场景：\n\n![Color Hits Green and Misses Red](http://images.bestswifter.com/UIKitPerformance/rasterize.png)\n\n光栅化的核心在于缓存的思想。我们自己动手把玩一下，可以发现以下几个有意思的现象：\n\n1. 上下微小幅度滑动时，一直是绿色\n2. 上下较大幅度滑动，新出现的label一开始是红色，随后变成绿色\n3. 如果静止一秒钟，刚开始滑动时会变红。\n\n这是因为layer进行光栅化后渲染成位图放在缓存中。当屏幕出现滑动时，我们直接从缓存中读取而不必渲染，所以会看到绿色。当新的label出现时，缓存中没有个这个label的位图，所以会变成红色。第三点比较关键，缓存中的对象有效期只有100ms，即如果在0.1s内没有被使用就会自动从缓存中清理出去。这就是为什么停留一会儿再滑动就会看到红色。\n\n光栅化的缓存机制是一把双刃剑，先写入缓存再读取有可能消耗较多的时间。因此光栅化仅适用于较复杂的、静态的效果。通过Instrument的调试发现，这里使用光栅化经常出现未命中缓存的情况，如果没有特殊需要则可以关闭光栅化，所以我们做的第二个优化是注释掉下面这行代码：\n\n```swift\n//\tlabel.layer.shouldRasterize = true\n```\n\n光栅化会导致离屏渲染，这一点待会儿会讲。\n\n### 颜色格式\n\n像素在内存中的布局和它在磁盘中的存储方式并不相同。考虑一种简单的情况：每个像素有R、G、B和alpha四个值，每个值占用1字节，因此每个像素占用4字节的内存空间。一张1920*1080的照片(iPhone6 Plus的分辨率)一共有2,073,600个像素，因此占用了超过8Mb的内存。但是一张同样分辨率的PNG格式或JPEG格式的图片一般情况下不会有这么大。这是因为JPEG将像素数据进行了一种非常复杂且可逆的转化。\n\n当我们打开JPEG格式的图片时，CPU会进行一系列运算，将JPEG图片解压成像素数据。显然这个工作会消耗不少时间，所以不应该在滑动时进行，我们应该预先处理好图片。借用WWDC上的一页PPT来说明：\n\n![显示流程](http://images.bestswifter.com/UIKitPerformance/pipeline.png)\n\nCommit Transaction和Decode在同一帧内进行，如果这两个操作的耗时超过16.67s，Draw Calls就会延迟到下一帧，从而导致fps值的降低。下面是Commit Transaction的详细流程：\n\n![解码与转换](http://images.bestswifter.com/UIKitPerformance/commit.png)\n\n在第三步的Prepare中，CPU主要处理两件事：\n\n1. 把图片从PNG或JPEG等格式中解压出来，得到像素数据\n2. 如果GPU不支持这种颜色各式，CPU需要进行格式转换\n\n比如应用中有一些从网络下载的图片，而GPU恰好不支持这个格式，这就需要CPU预先进行格式转化。第三个选项“Color Copied Images”就用来检测这种实时的格式转化，如果有则会将图片标记为蓝色。\n\n遗憾的是由于我对图片格式不太了解，也不会使用相关工具，并没有能模拟出触发这个选项的场景。我们要记住的是，如果调试时发现有图片被标记为蓝色，说明图片格式出现了一些问题。\n\n### 图片大小\n\n第四个选项的使用场景不多，我们直接看一下第五个选项“Color Misaligned Images”。它表示如果图片需要缩放则标记为黄色，如果没有像素对齐则标记为紫色。勾选上这个选项并进行调试，可以看到如下场景：\n\n![图片缩放](http://images.bestswifter.com/UIKitPerformance/scale.png)\n\n在demo中，每个`UIImageView`的大小都是180x180，而只有第二张图片的像素大小是360x360。因此除了第二张图片，其他的图片都需要被缩放。图片的缩放需要占用时间，因此我们要尽可能保证无论是本地图片还是从网络或取得图片的大小，都与其frame保持一致。\n\n第三个优化是调整所有图片的像素大小以避免不必要的缩放。\n\n### 离屏渲染\n\n离屏渲染表示渲染发生在屏幕之外，你可能认为这是一句废话。为了真正解释清楚什么是离屏渲染，我们先来看一下正常的渲染通道(Render-Pass)：\n\n![正常渲染通道](http://images.bestswifter.com/UIKitPerformance/renderpass.png)\n\n首先，OpenGL提交一个命令到Command Buffer，随后GPU开始渲染，渲染结果放到Render Buffer中，这是正常的渲染流程。但是有一些复杂的效果无法直接渲染出结果，它需要分步渲染最后再组合起来，比如添加一个蒙版(mask)：\n\n![离屏渲染](http://images.bestswifter.com/UIKitPerformance/offscreenpass.png)\n\n在前两个渲染通道中，GPU分别得到了纹理(texture，也就是那个相机图标)和layer(蓝色的蒙版)的渲染结果。但这两个渲染结果没有直接放入Render Buffer中，也就表示这是离屏渲染。直到第三个渲染通道，才把两者组合起来放入Render Buffer中。离屏渲染意味着把渲染结果临时保存，等用到时再取出，因此相对于普通渲染更占用资源。\n\n第六个选项“Color Offscreen-Rendered Yellow”会把需要离屏渲染的地方标记为黄色，大部分情况下我们需要尽可能避免黄色的出现。离屏渲染可能会自动触发，也可以手动触发。以下情况可能会导致触发离屏渲染：\n\n> 1. 重写drawRect方法\n> 2. 有mask或者是阴影(layer.masksToBounds, layer.shadow*)，模糊效果也是一种mask\n> 3. layer.shouldRasterize = true\n\n前两者会自动触发离屏渲染，第三种方法是手动开启离屏渲染。\n\n开始调试并勾选“Color Offscreen-Rendered Yellow”，会看到这样的场景：\n\n![离屏渲染](http://images.bestswifter.com/UIKitPerformance/offscreenrender.png)\n\n如果没有进行第二步优化，你会发现label也是黄色。可以看到tabbar和statusBar也是黄色，这是因为它们使用了模糊效果。图片也是黄色，这说明它也进行了离屏渲染，观察源码后发现主要原因是它使用了阴影，接下来我们进行第四个优化，在设置阴影效果的四行代码下面添加一行：\n\n```swift\nimgView.layer.shadowPath = UIBezierPath(rect: imgView.bounds).CGPath\n```\n\n这行代码制定了阴影路径，如果没有手动指定，Core Animation会去自动计算，这就会触发离屏渲染。如果人为指定了阴影路径，就可以免去计算，从而避免产生离屏渲染。\n\n设置`cornerRadius`本身并不会导致离屏渲染，但很多时候它还需要配合`layer.masksToBounds = true`使用。根据之前的总结，设置`masksToBounds`会导致离屏渲染。解决方案是尽可能在滑动时避免设置圆角，如果必须设置圆角，可以使用光栅化技术将圆角缓存起来：\n\n```swift\n// 设置圆角\nlabel.layer.masksToBounds = true\nlabel.layer.cornerRadius = 8\nlabel.layer.shouldRasterize = true\nlabel.layer.rasterizationScale = layer.contentsScale\n```\n\n### 快速路径\n\n还记得之前将离屏渲染和渲染路径时的示意图么，离屏渲染的最后一步是把此前的多个路径组合起来。如果这个组合过程能由CPU完成，就会大量减少GPU的工作。这种技术在绘制地图中可能用到。\n\n第七个选项“Color Compositing Fast-Path Blue”用于标记由硬件绘制的路径，蓝色越多越好。\n\n### 变化区域\n\n刷新视图时，我们应该把需要重绘的区域尽可能缩小。对于未发生变化的内容则不应该重绘，第八个选项“Flash updated Regions”用于标记发生重绘的区域。一个典型的例子是系统的时钟应用，绝大多数时候只有显示秒针的区域需要重绘：\n\n![重绘区域](http://images.bestswifter.com/UIKitPerformance/flash.png)\n\n# 总结\n\n如果你一步一步做到了这里，我想一定会有不少收益。不过，学而不思则罔，思而不学则殆。动手实践后还是应该总结提炼，优化滑动性能主要涉及三个方面：\n\n### 避免图层混合\n\n1. 确保控件的`opaque`属性设置为`true`，确保`backgroundColor`和父视图颜色一致且不透明\n2. 如无特殊需要，不要设置低于1的`alpha`值\n3. 确保`UIImage`没有alpha通道\n\n### 避免临时转换\n\n1. 确保图片大小和`frame`一致，不要在滑动时缩放图片\n2. 确保图片颜色格式被GPU支持，避免劳烦CPU转换\n\n### 慎用离屏渲染\n\n1. 绝大多数时候离屏渲染会影响性能\n2. 重写`drawRect`方法，设置圆角、阴影、模糊效果，光栅化都会导致离屏渲染\n3. 设置阴影效果是加上阴影路径\n4. 滑动时若需要圆角效果，开启光栅化","html":"<p>在使用UIKit的过程中，性能优化是永恒的话题。很多人都看过分析优化滑动性能的文章，但其中不少文章只介绍了优化方法却对背后的原理避而不谈，或者是晦涩难懂而且读者缺乏实践体验的机会。不妨思考一下下面的问题自己是否有一个清晰的认识：</p>\n\n<ol>\n<li>为什么要把控件尽量设置成不透明的，如果是透明的会有什么影响，如何检测这种影响？  </li>\n<li>为什么cell中的图片，尽可能要使用正确的大小、格式，如果错误会有什么影响，如何检测这种影响？  </li>\n<li>为什么设置阴影和圆角有可能影响滑动时流畅度？  </li>\n<li><code>shouldRasterize</code>和离屏渲染的关系是什么，何时应该使用？</li>\n</ol>\n\n<p>本文会结合Instrument分析影响性能的因素，提出优化方案并解释背后的原理，项目初始demo的下载地址在<a href=\"https://github.com/bestswifter/MySampleCode/tree/master/GraphicsPerformance-Starter\">我的Github</a>，强烈建议每一位读者下载下来随着我一步一步调试、优化。如果觉得对自己有帮助，可以给一个Star表示支持。后面的图片较多，流量党慎入。</p>\n\n<h1 id=\"\">基本概念</h1>\n\n<p>打开项目后，只要CustomTableCell.swift文件即可，它实现了自定义的<code>UITableViewCell</code>以及内部的UI布局，因为重点在于性能优化，代码实现的就比较随意。</p>\n\n<p>首先按下<code>Command + I</code>打开Instrument，本文主要用到的是Core Animation工具：</p>\n\n<p><img src=\"http://images.bestswifter.com/UIKitPerformance/Instrument.png\" alt=\"打开Core Animation调试\" /></p>\n\n<p>注意这个调试必须使用真机，点击左上角的红色圆圈就会开始录制。新手可能不太熟悉，这里简单介绍一下调试界面：</p>\n\n<p><img src=\"http://images.bestswifter.com/UIKitPerformance/Introduce.png\" alt=\"调试界面\" /></p>\n\n<p>我们需要了解两个两个区域：</p>\n\n<ol>\n<li>这里记录了实时的fps数值，有些地方是0是因为屏幕没有滑动  </li>\n<li>这是重中之重，接下来我会带大家逐个理解、体验这些调试选项</li>\n</ol>\n\n<p>有过游戏经验的人也许对<strong>fps</strong>这个概念比较熟悉。我们知道任何屏幕总是有一个刷新率，比如iphone推荐的刷新率是60Hz，也就是说GPU每秒钟刷新屏幕60次，因此两次刷新之间的间隔为16.67ms。这段时间内屏幕内容保持不变，称为<strong>一帧(frame)</strong>，fps表示<strong>frames per second</strong>，也就是每秒钟显示多少帧画面。对于静止不变的内容，我们不需要考虑它的刷新率，但在执行动画或滑动时，fps的值直接反映出滑动的流畅程度。</p>\n\n<h1 id=\"\">调试、优化</h1>\n\n<h3 id=\"\">图层混合</h3>\n\n<p>首先我们要明白像素的概念，屏幕上每一个点都是一个像素，像素有R、G、B三种颜色构成(有时候还带有alpha值)。如果某一块区域上覆盖了多个layer,最后的显示效果受到这些layer的共同影响。举个例子，上层是蓝色(RGB=0,0,1),透明度为50%，下层是红色(RGB=1,0,0)。那么最终的显示效果是紫色(RGB=0.5,0,0.5)。这种颜色的混合(blending)需要消耗一定的GPU资源，因为实际上可能不止只有两层。如果只想显示最上层的蓝色，可以把它的透明度设置为100%，这样GPU会忽略下面所有的layer，从而节约了很多不必要的运算。</p>\n\n<p>第一个调试选项\"Color Blended Layers\"正是用于检测哪里发生了图层混合，并用红色标记出来。因此我们需要尽可能减少看到的红色区域。一旦发现应该想法设法消除它。开始调试后勾选这个选项，我们在手机上可以看到如下的场景：</p>\n\n<p><img src=\"http://images.bestswifter.com/UIKitPerformance/blendedlayer.png\" alt=\"Color Blended Layers\" /></p>\n\n<p>很多文章里说把控件设置为<code>opaque = true</code>，其原理就是希望避免图层混合，然而这种调优一般情况下用处不大。因为<code>UIView</code>的<code>opaque</code>属性默认值就是<code>true</code>，也就是说只要不是人为设置成透明，都不会出现图层混合。比如demo中就没有任何透明的控件。</p>\n\n<p>对于<code>UIImageView</code>来说，不仅它自身需要是不透明的，它的图片也不能含有alpha通道，这就是为什么图中第三个图片是绿色，而前两个图片是红色的原因。由于本人对PS和图像几乎一窍不通，恕我不能演示如何消除这些图片的红色。我从网上找了一个美女的头像来说明，图像自身的性质可能会对结果有影响，因此如果你确定自己的代码没有问题，而且出现了图层混合，请联系美工或后台解决。</p>\n\n<p>个人认为比<code>opaque</code>属性更重要的是<code>backgroundColor</code>属性，如果不设置这个属性，控件依然被认为是透明的，所以我们做的第一个优化是在<code>CustomTableCell</code>类的<code>init</code>方法中添加一行代码：</p>\n\n<pre><code>label.backgroundColor = UIColor.whiteColor()  \n</code></pre>\n\n<p>虽然在白色背景下，这行代码无法肉眼看到效果，但重新调试后我们可以发现label的红色消失了。也正是因为对背景颜色的不重视，它成了影响滑动性能的第一个杀手。</p>\n\n<p>PS：如果label文字有中文，依然会出现图层混合，这是因为此时label多了一个<code>sublayer</code>，如果有好的解决办法欢迎告诉我。</p>\n\n<h3 id=\"\">光栅化</h3>\n\n<p>光栅化是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样比较消耗资源的静态内容进行缓存，可以得到一定幅度的性能提升。demo中的这一行代码表示将label的layer光栅化：</p>\n\n<pre><code class=\"language-swift\">label.layer.shouldRasterize = true  \n</code></pre>\n\n<p>Instrument中，第二个调试选项是“Color Hits Green and Misses Red”，它表示如果命中缓存则显示为绿色，否则显示为红色，显然绿色越多越好，红色越少越好。勾选这个选项后我们看到如下的场景：</p>\n\n<p><img src=\"http://images.bestswifter.com/UIKitPerformance/rasterize.png\" alt=\"Color Hits Green and Misses Red\" /></p>\n\n<p>光栅化的核心在于缓存的思想。我们自己动手把玩一下，可以发现以下几个有意思的现象：</p>\n\n<ol>\n<li>上下微小幅度滑动时，一直是绿色  </li>\n<li>上下较大幅度滑动，新出现的label一开始是红色，随后变成绿色  </li>\n<li>如果静止一秒钟，刚开始滑动时会变红。</li>\n</ol>\n\n<p>这是因为layer进行光栅化后渲染成位图放在缓存中。当屏幕出现滑动时，我们直接从缓存中读取而不必渲染，所以会看到绿色。当新的label出现时，缓存中没有个这个label的位图，所以会变成红色。第三点比较关键，缓存中的对象有效期只有100ms，即如果在0.1s内没有被使用就会自动从缓存中清理出去。这就是为什么停留一会儿再滑动就会看到红色。</p>\n\n<p>光栅化的缓存机制是一把双刃剑，先写入缓存再读取有可能消耗较多的时间。因此光栅化仅适用于较复杂的、静态的效果。通过Instrument的调试发现，这里使用光栅化经常出现未命中缓存的情况，如果没有特殊需要则可以关闭光栅化，所以我们做的第二个优化是注释掉下面这行代码：</p>\n\n<pre><code class=\"language-swift\">//    label.layer.shouldRasterize = true\n</code></pre>\n\n<p>光栅化会导致离屏渲染，这一点待会儿会讲。</p>\n\n<h3 id=\"\">颜色格式</h3>\n\n<p>像素在内存中的布局和它在磁盘中的存储方式并不相同。考虑一种简单的情况：每个像素有R、G、B和alpha四个值，每个值占用1字节，因此每个像素占用4字节的内存空间。一张1920*1080的照片(iPhone6 Plus的分辨率)一共有2,073,600个像素，因此占用了超过8Mb的内存。但是一张同样分辨率的PNG格式或JPEG格式的图片一般情况下不会有这么大。这是因为JPEG将像素数据进行了一种非常复杂且可逆的转化。</p>\n\n<p>当我们打开JPEG格式的图片时，CPU会进行一系列运算，将JPEG图片解压成像素数据。显然这个工作会消耗不少时间，所以不应该在滑动时进行，我们应该预先处理好图片。借用WWDC上的一页PPT来说明：</p>\n\n<p><img src=\"http://images.bestswifter.com/UIKitPerformance/pipeline.png\" alt=\"显示流程\" /></p>\n\n<p>Commit Transaction和Decode在同一帧内进行，如果这两个操作的耗时超过16.67s，Draw Calls就会延迟到下一帧，从而导致fps值的降低。下面是Commit Transaction的详细流程：</p>\n\n<p><img src=\"http://images.bestswifter.com/UIKitPerformance/commit.png\" alt=\"解码与转换\" /></p>\n\n<p>在第三步的Prepare中，CPU主要处理两件事：</p>\n\n<ol>\n<li>把图片从PNG或JPEG等格式中解压出来，得到像素数据  </li>\n<li>如果GPU不支持这种颜色各式，CPU需要进行格式转换</li>\n</ol>\n\n<p>比如应用中有一些从网络下载的图片，而GPU恰好不支持这个格式，这就需要CPU预先进行格式转化。第三个选项“Color Copied Images”就用来检测这种实时的格式转化，如果有则会将图片标记为蓝色。</p>\n\n<p>遗憾的是由于我对图片格式不太了解，也不会使用相关工具，并没有能模拟出触发这个选项的场景。我们要记住的是，如果调试时发现有图片被标记为蓝色，说明图片格式出现了一些问题。</p>\n\n<h3 id=\"\">图片大小</h3>\n\n<p>第四个选项的使用场景不多，我们直接看一下第五个选项“Color Misaligned Images”。它表示如果图片需要缩放则标记为黄色，如果没有像素对齐则标记为紫色。勾选上这个选项并进行调试，可以看到如下场景：</p>\n\n<p><img src=\"http://images.bestswifter.com/UIKitPerformance/scale.png\" alt=\"图片缩放\" /></p>\n\n<p>在demo中，每个<code>UIImageView</code>的大小都是180x180，而只有第二张图片的像素大小是360x360。因此除了第二张图片，其他的图片都需要被缩放。图片的缩放需要占用时间，因此我们要尽可能保证无论是本地图片还是从网络或取得图片的大小，都与其frame保持一致。</p>\n\n<p>第三个优化是调整所有图片的像素大小以避免不必要的缩放。</p>\n\n<h3 id=\"\">离屏渲染</h3>\n\n<p>离屏渲染表示渲染发生在屏幕之外，你可能认为这是一句废话。为了真正解释清楚什么是离屏渲染，我们先来看一下正常的渲染通道(Render-Pass)：</p>\n\n<p><img src=\"http://images.bestswifter.com/UIKitPerformance/renderpass.png\" alt=\"正常渲染通道\" /></p>\n\n<p>首先，OpenGL提交一个命令到Command Buffer，随后GPU开始渲染，渲染结果放到Render Buffer中，这是正常的渲染流程。但是有一些复杂的效果无法直接渲染出结果，它需要分步渲染最后再组合起来，比如添加一个蒙版(mask)：</p>\n\n<p><img src=\"http://images.bestswifter.com/UIKitPerformance/offscreenpass.png\" alt=\"离屏渲染\" /></p>\n\n<p>在前两个渲染通道中，GPU分别得到了纹理(texture，也就是那个相机图标)和layer(蓝色的蒙版)的渲染结果。但这两个渲染结果没有直接放入Render Buffer中，也就表示这是离屏渲染。直到第三个渲染通道，才把两者组合起来放入Render Buffer中。离屏渲染意味着把渲染结果临时保存，等用到时再取出，因此相对于普通渲染更占用资源。</p>\n\n<p>第六个选项“Color Offscreen-Rendered Yellow”会把需要离屏渲染的地方标记为黄色，大部分情况下我们需要尽可能避免黄色的出现。离屏渲染可能会自动触发，也可以手动触发。以下情况可能会导致触发离屏渲染：</p>\n\n<blockquote>\n  <ol>\n  <li>重写drawRect方法</li>\n  <li>有mask或者是阴影(layer.masksToBounds, layer.shadow*)，模糊效果也是一种mask</li>\n  <li>layer.shouldRasterize = true</li>\n  </ol>\n</blockquote>\n\n<p>前两者会自动触发离屏渲染，第三种方法是手动开启离屏渲染。</p>\n\n<p>开始调试并勾选“Color Offscreen-Rendered Yellow”，会看到这样的场景：</p>\n\n<p><img src=\"http://images.bestswifter.com/UIKitPerformance/offscreenrender.png\" alt=\"离屏渲染\" /></p>\n\n<p>如果没有进行第二步优化，你会发现label也是黄色。可以看到tabbar和statusBar也是黄色，这是因为它们使用了模糊效果。图片也是黄色，这说明它也进行了离屏渲染，观察源码后发现主要原因是它使用了阴影，接下来我们进行第四个优化，在设置阴影效果的四行代码下面添加一行：</p>\n\n<pre><code class=\"language-swift\">imgView.layer.shadowPath = UIBezierPath(rect: imgView.bounds).CGPath  \n</code></pre>\n\n<p>这行代码制定了阴影路径，如果没有手动指定，Core Animation会去自动计算，这就会触发离屏渲染。如果人为指定了阴影路径，就可以免去计算，从而避免产生离屏渲染。</p>\n\n<p>设置<code>cornerRadius</code>本身并不会导致离屏渲染，但很多时候它还需要配合<code>layer.masksToBounds = true</code>使用。根据之前的总结，设置<code>masksToBounds</code>会导致离屏渲染。解决方案是尽可能在滑动时避免设置圆角，如果必须设置圆角，可以使用光栅化技术将圆角缓存起来：</p>\n\n<pre><code class=\"language-swift\">// 设置圆角\nlabel.layer.masksToBounds = true  \nlabel.layer.cornerRadius = 8  \nlabel.layer.shouldRasterize = true  \nlabel.layer.rasterizationScale = layer.contentsScale  \n</code></pre>\n\n<h3 id=\"\">快速路径</h3>\n\n<p>还记得之前将离屏渲染和渲染路径时的示意图么，离屏渲染的最后一步是把此前的多个路径组合起来。如果这个组合过程能由CPU完成，就会大量减少GPU的工作。这种技术在绘制地图中可能用到。</p>\n\n<p>第七个选项“Color Compositing Fast-Path Blue”用于标记由硬件绘制的路径，蓝色越多越好。</p>\n\n<h3 id=\"\">变化区域</h3>\n\n<p>刷新视图时，我们应该把需要重绘的区域尽可能缩小。对于未发生变化的内容则不应该重绘，第八个选项“Flash updated Regions”用于标记发生重绘的区域。一个典型的例子是系统的时钟应用，绝大多数时候只有显示秒针的区域需要重绘：</p>\n\n<p><img src=\"http://images.bestswifter.com/UIKitPerformance/flash.png\" alt=\"重绘区域\" /></p>\n\n<h1 id=\"\">总结</h1>\n\n<p>如果你一步一步做到了这里，我想一定会有不少收益。不过，学而不思则罔，思而不学则殆。动手实践后还是应该总结提炼，优化滑动性能主要涉及三个方面：</p>\n\n<h3 id=\"\">避免图层混合</h3>\n\n<ol>\n<li>确保控件的<code>opaque</code>属性设置为<code>true</code>，确保<code>backgroundColor</code>和父视图颜色一致且不透明  </li>\n<li>如无特殊需要，不要设置低于1的<code>alpha</code>值  </li>\n<li>确保<code>UIImage</code>没有alpha通道</li>\n</ol>\n\n<h3 id=\"\">避免临时转换</h3>\n\n<ol>\n<li>确保图片大小和<code>frame</code>一致，不要在滑动时缩放图片  </li>\n<li>确保图片颜色格式被GPU支持，避免劳烦CPU转换</li>\n</ol>\n\n<h3 id=\"\">慎用离屏渲染</h3>\n\n<ol>\n<li>绝大多数时候离屏渲染会影响性能  </li>\n<li>重写<code>drawRect</code>方法，设置圆角、阴影、模糊效果，光栅化都会导致离屏渲染  </li>\n<li>设置阴影效果是加上阴影路径  </li>\n<li>滑动时若需要圆角效果，开启光栅化</li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-22T06:58:24.000Z","created_by":1,"updated_at":"2016-01-28T16:31:02.000Z","updated_by":1,"published_at":"2016-01-22T06:58:46.000Z","published_by":1},{"id":6,"uuid":"ecc94650-1518-4557-8462-23d908e21a1e","title":"Swift数组扩容原理","slug":"swiftarrayappend","markdown":"#结论\n\n首先把结论写在文章开头，因为接下来的分析会有些啰嗦、复杂，如果不愿意深究的话只要记住Swift中数组扩容的原理是：\n\n> Swift2中创建一个空数组，默认容量为2，当长度和容量相等，且还需要再添加元素时，创建一个两倍长度于旧数组的新数组，把旧数组的元素拷贝过来，再把元素插入到新数组中。\n\n\n#引子\n\n下面这段代码希望通过多线程技术，加速向数组中添加数字这个过程，我们来看看它有什么问题：\n\n```swift\nvar array: [Int] = []\nlet concurrentQueue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_CONCURRENT)\n\nfor i in 1...10000 {\n\tdispatch_async(concurrentQueue, { () -> Void in\n\t\tarray.append(i)\n\t})\n}\n```\n\n代码很简短，看上去问题不大。不过如果你运行完这段代码而且程序没有崩溃，我强烈建议买一份彩票，因为你的运气已经好到逆天了。\n\n<!--more-->\n\n通常情况下，你会遇到这样的报错\n> fatal error: UnsafeMutablePointer.destroy with negative count\n\n#Append方法实现\n\n程序会断在`array.append(i)`这一行。也就是<font color = \"rgb(226,238,250)\">`append `</font>方法出了问题。我们知道Swift里的数组不像C语言，不需要提前定义好长度，更像是C++的<font color = \"rgb(226,238,250)\">`vector`</font>和OC的<font color = \"rgb(226,238,250)\">`NSMutableArray`</font>。\n\n所以，会不会是数组的可变性，导致了<font color = \"rgb(226,238,250)\">`append`</font>方法是线程不安全的呢，带着这样的猜想，我们来研究一下Swift是如何实现Append方法的。\n\nSwift已经开源了，github上[相关源码](https://github.com/apple/apple)已经可以下载。\n\n虽然明知道有些文件夹不会包含append方法的实现源码，但真想找到也不容易。如果你试着搜索\"append\"的话，相关文件非常多，因为\"append\"本身就是一个非常常用的单词。我采取的办法是搜索完整的函数定义，而函数定义是我们很容易看到的。\n\n当我们搜索\"mutating func append(newElement: Element)\"后，就只有六个相关文件了。如图所示:\n\n![搜索结果](http://7xonij.com1.z0.glb.clouddn.com/Swift_append/search_result.png)\n\n前三个文件无法直接打开，暂时先不管。其实第三个一看也知道是单元测试文件。第六个是字符串，也不是我们感兴趣的。所以我们依次打开\"ArrayType.swift\"和\"RangeReplaceableCollectionType.swift\"这两个文件。\n\n> 提示：这两个文件的目录都是\"/swift/stdlib/public/core\"\n\n遗憾的是，ArrayType.swift文件中没有找到相关函数，RangeReplaceableCollectionType.swift文件倒是有一个<font color = \"rgb(226,238,250)\">`append`</font>方法，不过参数类型对不上。于是我想到第一个文件——\"Arrays.swift.gyb\"，去掉gyb后缀后果然可以打开了。并且成功的找到了我们感兴趣的<font color = \"rgb(226,238,250)\">`append`</font>方法：\n\n\n```swift\npublic mutating func append(newElement: Element) {\n\t_makeUniqueAndReserveCapacityIfNotUnique()\n\tlet oldCount = _getCount()\n\t_reserveCapacityAssumingUniqueBuffer(oldCount)\n\t_appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)\n}\n```\n\n#源码分析\n\n代码不长，我们逐行看一下\n\n* 第一行的函数，看名字表示，如果这个数组不是惟一的，就把它变成惟一的，而且保留数组容量。在Xcode里面搜索一下这个函数：\n\n```swift\ninternal mutating func _makeUniqueAndReserveCapacityIfNotUnique() {\n\tif _slowPath(!_buffer.isMutableAndUniquelyReferenced()) {\n\t\t_copyToNewBuffer(_buffer.count)\n\t}\n}\n```\n\n这个函数会进行一个判断判断——如果数组不是被唯一引用的，就会复制一份新的。这其实就是“**写时赋值(copy-on-write)**”技术。如果你想了解它的具体使用，可以参考我的这篇文章——[《\b第二章——集合（数组与可变性）》](http://www.jianshu.com/p/21d518da46ed)\n\n不过对于文章开头那个例子的数组来说，它肯定是唯一引用的。所以<font color = \"rgb(226,238,250)\">`_copyToNewBuffer `</font>函数不会调用，我们先记下这个方法。然后回到<font color = \"rgb(226,238,250)\">`append `</font>方法继续研究。\n\n* 第二行用一个变量<font color = \"rgb(226,238,250)\">`oldCount`</font>保存数组当前长度。\n\n* 第三行的函数表示，在假设当前数组是唯一引用的前提下，保留数组容量。之所以做出这样的假设，是因为此前已经调用过<font color = \"rgb(226,238,250)\">`_makeUniqueAndReserveCapacityIfNotUnique `</font>方法，即使这个数组不是唯一引用，也被复制了一份新的。我们来看看<font color = \"rgb(226,238,250)\">`_reserveCapacityAssumingUniqueBuffer `</font>方法的实现：\n\n```swift\ninternal mutating func _reserveCapacityAssumingUniqueBuffer(oldCount : Int) {\n\t_sanityCheck(_buffer.isMutableAndUniquelyReferenced())\n\n\tif _slowPath(oldCount + 1 > _buffer.capacity) {\n\t\t_copyToNewBuffer(oldCount)\n\t}\n}\n```\n\n\t\n第一行有一个<font color = \"rgb(226,238,250)\">`_sanityCheck `</font>来判断数组是否可变且唯一引用。\"sanity\"说明这个判断是符合常理的，虽然它很有可能并没有效果，但也是为了确保万无一失。\n\n下面还有一个判断，检查当前数组长度加一后是否大于数组容量。如果判断成立，说明`oldCount == _buffer.capacity`，在实际编程中，就意味着数组需要扩容了。可以看到又会执行刚刚提到过的<font color = \"rgb(226,238,250)\">`_copyToNewBuffer `</font>函数。我们还是先把这个函数放一放，接着往后看。\n\n\n* 最后一行的函数表示，假设数组是唯一引用的，且数组容量也设置正确，把新的元素添加到数组中。这其实是真正执行了“append”操作的地方。它的实现如下：\n\n```swift\ninternal mutating func _appendElementAssumeUniqueAndCapacity(\n    oldCount : Int,\n    newElement : Element) {\n    \n\t_sanityCheck(_buffer.isMutableAndUniquelyReferenced())\n\t_sanityCheck(_buffer.capacity >= _buffer.count + 1)\n\n\t_buffer.count = oldCount + 1\n\t(_buffer.firstElementAddress + oldCount).initialize(newElement)\n}\n```\n\n首先是两个基本判断，然后把<font color = \"rgb(226,238,250)\">`count `</font>属性加一，最后获取到将要添加的位置的地址，用一个新的值初始化它。\n\n\nOK，<font color = \"rgb(226,238,250)\">`append`</font>方法的结构基本上了解了，首先会保证数组是唯一引用的，然后处理数组的容量问题，最后把待插入的元素放到指定位置上。其中最关键，也是目前还没有彻底明白的一步，就是之前所说的<font color = \"rgb(226,238,250)\">`_copyToNewBuffer `</font>函数了\n\n#copyToNewBuffer\n\n先来看看<font color = \"rgb(226,238,250)\">`copyToNewBuffer`</font>函数的实现：\n\n```swift\ninternal mutating func _copyToNewBuffer(oldCount: Int) {\n\tlet newCount = oldCount + 1\n\tvar newBuffer = Optional(\n\t_forceCreateUniqueMutableBuffer(\n\t\t&_buffer, countForNewBuffer: oldCount, minNewCapacity: newCount))\n\t_arrayOutOfPlaceUpdate(\n\t\t&_buffer, &newBuffer, oldCount, 0, _IgnorePointer())\n\t}\n```\n\n这个方法又分为两步，<font color = \"rgb(226,238,250)\">`_forceCreateUniqueMutableBuffer `</font>和<font color = \"rgb(226,238,250)\">`_arrayOutOfPlaceUpdate `</font>。前者实现了新存储区域的创建，而后者完成了数据的复制工作。\n\n为了简单起见，我们先看看<font color = \"rgb(226,238,250)\">`_arrayOutOfPlaceUpdate `</font>函数,这个函数的实现太长了，不过好在有注释：\n\n```swift\n/// Initialize the elements of dest by copying the first headCount\n/// items from source, calling initializeNewElements on the next\n/// uninitialized element, and finally by copying the last N items\n/// from source into the N remaining uninitialized elements of dest.\n///\n/// As an optimization, may move elements out of source rather than\n/// copying when it isUniquelyReferenced.\n```\n\n大意是说，源数组中已存在的元素会被复制到目标数组中，如果新数组比较长，空缺部分会调用<font color = \"rgb(226,238,250)\">`initializeNewElements `</font>方法来初始化。为了优化性能，被唯一引用的元素可能会直接从源数组移到新数组而不是复制。其实就是换了一个指针指向那个元素，从而避免了复制。\n\n接下来我们再研究一下比较关键的<font color = \"rgb(226,238,250)\">`_forceCreateUniqueMutableBuffer `</font>部分，也就是数组是怎样扩容的：\n\n```swift\n@inline(never)\nfunc _forceCreateUniqueMutableBuffer<_Buffer : _ArrayBufferType>(\n\tinout source: _Buffer,  countForNewBuffer: Int,  minNewCapacity: Int\n\t) -> _ContiguousArrayBuffer<_Buffer.Element> {\n\t\n\t//其实什么也没干，多加了一个参数就转发给 _forceCreateUniqueMutableBufferImpl了\n  \treturn _forceCreateUniqueMutableBufferImpl(\n\t\t&source, countForBuffer: countForNewBuffer, minNewCapacity: minNewCapacity,\n\t\trequiredCapacity: minNewCapacity)\n}\n\ninternal func _forceCreateUniqueMutableBufferImpl<_Buffer : _ArrayBufferType>(\n  inout source: _Buffer,  countForBuffer: Int, minNewCapacity: Int,\n  requiredCapacity: Int\n) -> _ContiguousArrayBuffer<_Buffer.Element> {\n\t_sanityCheck(countForBuffer >= 0)\n  \t_sanityCheck(requiredCapacity >= countForBuffer)\n  \t_sanityCheck(minNewCapacity >= countForBuffer)\n\n  \tlet minimumCapacity = max(\n\trequiredCapacity, minNewCapacity > source.capacity\n\t\t? _growArrayCapacity(source.capacity) : source.capacity)\n\n\treturn _ContiguousArrayBuffer(\n\t\tcount: countForBuffer, minimumCapacity: minimumCapacity)\n}\n```\n\n<font color = \"rgb(226,238,250)\">`_forceCreateUniqueMutableBufferImpl `</font>函数刚开始的三个检查读者可以自行理解，关键部分在于<font color = \"rgb(226,238,250)\">`minimumCapacity `</font>的计算。因为它会作为容量参数被传到用于创建新的Buffer的函数中。\n\n这个函数有四个参数，第一个参数buffer可以理解为数组中真正用于数据存放的那个部分。对于最后两个参数，意思有点像，我们不妨考虑一个实际的、需要进行数组扩容的情况，向一个容量为3，长度为3的数组新增一个元素1，此时函数的调用顺序如下：\n\n\n1. <font color = \"rgb(226,238,250)\">`append(1)`</font>\n2. <font color = \"rgb(226,238,250)\">`_reserveCapacityAssumingUniqueBuffer(3)`</font>\n3. <font color = \"rgb(226,238,250)\">`_copyToNewBuffer(3)`</font>\n4. <font color = \"rgb(226,238,250)\">`_forceCreateUniqueMutableBuffer(&_buffer, countForNewBuffer: 3, minNewCapacity: 4)`</font>\n5. <font color = \"rgb(226,238,250)\">`_forceCreateUniqueMutableBufferImpl(&_buffer, countForBuffer: 3, minNewCapacity: 4, requiredCapacity: 4)`</font>\n        \n还记得<font color = \"rgb(226,238,250)\">`_copyToNewBuffer()`</font>方法里的`let newCount = oldCount + 1`么，所以<font color = \"rgb(226,238,250)\">`oldCount(=3)`</font>作为<font color = \"rgb(226,238,250)\">`minNewCapacity `</font>，而<font color = \"rgb(226,238,250)\">`newCount(=4)`</font>作为<font color = \"rgb(226,238,250)\">`requiredCapacity `</font>参数被传入<font color = \"rgb(226,238,250)\">`_forceCreateUniqueMutableBufferImpl `</font>方法。\n\n此时，<font color = \"rgb(226,238,250)\">`minimumCapacity`</font>的计算，其实就是以下表达式的值：\n\n```swift\nmax(4, 4 > 3 ? _growArrayCapacity(3) : 3)\n```\n\n我们知道，如果数组需要扩容，<font color = \"rgb(226,238,250)\">`source.capacity`</font>总是等于<font color = \"rgb(226,238,250)\">`minNewCapacity `</font>的。也就是说上式可以写为：\n\n```swift\nmax(length+1, length+1 > length ? _growArrayCapacity(length) : length)\n\n//等价于\nmax(length+1, _growArrayCapacity(length))\n```\n\n可以看到<font color = \"rgb(226,238,250)\">`_growArrayCapacity `</font>返回值是传入参数的两倍：\n\n```swift\n@warn_unused_result\ninternal func _growArrayCapacity(capacity: Int) -> Int {\n  return capacity * 2\n}\n```\n\n所以<font color = \"rgb(226,238,250)\">`minimumCapacity`</font> = <font color = \"rgb(226,238,250)\">`max(length+1, 2 * length)`</font> = <font color = \"rgb(226,238,250)\">`2 * length`</font>。也就是新扩容的数组长度其实翻倍了。\n\n#线程安全\n\n现在我们可以理解为什么<font color = \"rgb(226,238,250)\">`append`</font>方法不是线程安全的了。如果在某一个线程中插入新元素，导致了数组扩容，那么Swift会创建一个新的数组（意味着地址完全不同）。然后ARC会为我们自动释放旧的数组，但这时候可能另一个线程还在访问旧的数组对象。\n\n#验证\n\n说了这么多，我们来证明一下Swift数组扩容的工作原理：\n\n```swift\nlet semaphore = dispatch_semaphore_create(1)\nvar array: [Int] = []\nfor i in 1...100000 {\n\tarray.append(i)\n\tlet arrayPtr = UnsafeMutableBufferPointer<Int>(start: &array, count: array.count)\n\tprint(arrayPtr)\n}\n```\n\n运行结果如下，可以验证文章开头的结论：“初始容量为2，扩容时容量翻倍”\n\n![容量翻倍](http://7xonij.com1.z0.glb.clouddn.com/Swift_append/double.png)","html":"<h1 id=\"\">结论</h1>\n\n<p>首先把结论写在文章开头，因为接下来的分析会有些啰嗦、复杂，如果不愿意深究的话只要记住Swift中数组扩容的原理是：</p>\n\n<blockquote>\n  <p>Swift2中创建一个空数组，默认容量为2，当长度和容量相等，且还需要再添加元素时，创建一个两倍长度于旧数组的新数组，把旧数组的元素拷贝过来，再把元素插入到新数组中。</p>\n</blockquote>\n\n<h1 id=\"\">引子</h1>\n\n<p>下面这段代码希望通过多线程技术，加速向数组中添加数字这个过程，我们来看看它有什么问题：</p>\n\n<pre><code class=\"language-swift\">var array: [Int] = []  \nlet concurrentQueue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_CONCURRENT)\n\nfor i in 1...10000 {  \n    dispatch_async(concurrentQueue, { () -&gt; Void in\n        array.append(i)\n    })\n}\n</code></pre>\n\n<p>代码很简短，看上去问题不大。不过如果你运行完这段代码而且程序没有崩溃，我强烈建议买一份彩票，因为你的运气已经好到逆天了。</p>\n\n<!--more-->\n\n<p>通常情况下，你会遇到这样的报错</p>\n\n<blockquote>\n  <p>fatal error: UnsafeMutablePointer.destroy with negative count</p>\n</blockquote>\n\n<h1 id=\"append\">Append方法实现</h1>\n\n<p>程序会断在<code>array.append(i)</code>这一行。也就是<font color = \"rgb(226,238,250)\"><code>append</code></font>方法出了问题。我们知道Swift里的数组不像C语言，不需要提前定义好长度，更像是C++的<font color = \"rgb(226,238,250)\"><code>vector</code></font>和OC的<font color = \"rgb(226,238,250)\"><code>NSMutableArray</code></font>。</p>\n\n<p>所以，会不会是数组的可变性，导致了<font color = \"rgb(226,238,250)\"><code>append</code></font>方法是线程不安全的呢，带着这样的猜想，我们来研究一下Swift是如何实现Append方法的。</p>\n\n<p>Swift已经开源了，github上<a href=\"https://github.com/apple/apple\">相关源码</a>已经可以下载。</p>\n\n<p>虽然明知道有些文件夹不会包含append方法的实现源码，但真想找到也不容易。如果你试着搜索\"append\"的话，相关文件非常多，因为\"append\"本身就是一个非常常用的单词。我采取的办法是搜索完整的函数定义，而函数定义是我们很容易看到的。</p>\n\n<p>当我们搜索\"mutating func append(newElement: Element)\"后，就只有六个相关文件了。如图所示:</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Swift_append/search_result.png\" alt=\"搜索结果\" /></p>\n\n<p>前三个文件无法直接打开，暂时先不管。其实第三个一看也知道是单元测试文件。第六个是字符串，也不是我们感兴趣的。所以我们依次打开\"ArrayType.swift\"和\"RangeReplaceableCollectionType.swift\"这两个文件。</p>\n\n<blockquote>\n  <p>提示：这两个文件的目录都是\"/swift/stdlib/public/core\"</p>\n</blockquote>\n\n<p>遗憾的是，ArrayType.swift文件中没有找到相关函数，RangeReplaceableCollectionType.swift文件倒是有一个<font color = \"rgb(226,238,250)\"><code>append</code></font>方法，不过参数类型对不上。于是我想到第一个文件——\"Arrays.swift.gyb\"，去掉gyb后缀后果然可以打开了。并且成功的找到了我们感兴趣的<font color = \"rgb(226,238,250)\"><code>append</code></font>方法：</p>\n\n<pre><code class=\"language-swift\">public mutating func append(newElement: Element) {  \n    _makeUniqueAndReserveCapacityIfNotUnique()\n    let oldCount = _getCount()\n    _reserveCapacityAssumingUniqueBuffer(oldCount)\n    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)\n}\n</code></pre>\n\n<h1 id=\"\">源码分析</h1>\n\n<p>代码不长，我们逐行看一下</p>\n\n<ul>\n<li>第一行的函数，看名字表示，如果这个数组不是惟一的，就把它变成惟一的，而且保留数组容量。在Xcode里面搜索一下这个函数：</li>\n</ul>\n\n<pre><code class=\"language-swift\">internal mutating func _makeUniqueAndReserveCapacityIfNotUnique() {  \n    if _slowPath(!_buffer.isMutableAndUniquelyReferenced()) {\n        _copyToNewBuffer(_buffer.count)\n    }\n}\n</code></pre>\n\n<p>这个函数会进行一个判断判断——如果数组不是被唯一引用的，就会复制一份新的。这其实就是“<strong>写时赋值(copy-on-write)</strong>”技术。如果你想了解它的具体使用，可以参考我的这篇文章——<a href=\"http://www.jianshu.com/p/21d518da46ed\">《\b第二章——集合（数组与可变性）》</a></p>\n\n<p>不过对于文章开头那个例子的数组来说，它肯定是唯一引用的。所以<font color = \"rgb(226,238,250)\"><code>_copyToNewBuffer</code></font>函数不会调用，我们先记下这个方法。然后回到<font color = \"rgb(226,238,250)\"><code>append</code></font>方法继续研究。</p>\n\n<ul>\n<li><p>第二行用一个变量<font color = \"rgb(226,238,250)\"><code>oldCount</code></font>保存数组当前长度。</p></li>\n<li><p>第三行的函数表示，在假设当前数组是唯一引用的前提下，保留数组容量。之所以做出这样的假设，是因为此前已经调用过<font color = \"rgb(226,238,250)\"><code>_makeUniqueAndReserveCapacityIfNotUnique</code></font>方法，即使这个数组不是唯一引用，也被复制了一份新的。我们来看看<font color = \"rgb(226,238,250)\"><code>_reserveCapacityAssumingUniqueBuffer</code></font>方法的实现：</p></li>\n</ul>\n\n<pre><code class=\"language-swift\">internal mutating func _reserveCapacityAssumingUniqueBuffer(oldCount : Int) {  \n    _sanityCheck(_buffer.isMutableAndUniquelyReferenced())\n\n    if _slowPath(oldCount + 1 &gt; _buffer.capacity) {\n        _copyToNewBuffer(oldCount)\n    }\n}\n</code></pre>\n\n<p>第一行有一个<font color = \"rgb(226,238,250)\"><code>_sanityCheck</code></font>来判断数组是否可变且唯一引用。\"sanity\"说明这个判断是符合常理的，虽然它很有可能并没有效果，但也是为了确保万无一失。</p>\n\n<p>下面还有一个判断，检查当前数组长度加一后是否大于数组容量。如果判断成立，说明<code>oldCount == _buffer.capacity</code>，在实际编程中，就意味着数组需要扩容了。可以看到又会执行刚刚提到过的<font color = \"rgb(226,238,250)\"><code>_copyToNewBuffer</code></font>函数。我们还是先把这个函数放一放，接着往后看。</p>\n\n<ul>\n<li>最后一行的函数表示，假设数组是唯一引用的，且数组容量也设置正确，把新的元素添加到数组中。这其实是真正执行了“append”操作的地方。它的实现如下：</li>\n</ul>\n\n<pre><code class=\"language-swift\">internal mutating func _appendElementAssumeUniqueAndCapacity(  \n    oldCount : Int,\n    newElement : Element) {\n\n    _sanityCheck(_buffer.isMutableAndUniquelyReferenced())\n    _sanityCheck(_buffer.capacity &gt;= _buffer.count + 1)\n\n    _buffer.count = oldCount + 1\n    (_buffer.firstElementAddress + oldCount).initialize(newElement)\n}\n</code></pre>\n\n<p>首先是两个基本判断，然后把<font color = \"rgb(226,238,250)\"><code>count</code></font>属性加一，最后获取到将要添加的位置的地址，用一个新的值初始化它。</p>\n\n<p>OK，<font color = \"rgb(226,238,250)\"><code>append</code></font>方法的结构基本上了解了，首先会保证数组是唯一引用的，然后处理数组的容量问题，最后把待插入的元素放到指定位置上。其中最关键，也是目前还没有彻底明白的一步，就是之前所说的<font color = \"rgb(226,238,250)\"><code>_copyToNewBuffer</code></font>函数了</p>\n\n<h1 id=\"copytonewbuffer\">copyToNewBuffer</h1>\n\n<p>先来看看<font color = \"rgb(226,238,250)\"><code>copyToNewBuffer</code></font>函数的实现：</p>\n\n<pre><code class=\"language-swift\">internal mutating func _copyToNewBuffer(oldCount: Int) {  \n    let newCount = oldCount + 1\n    var newBuffer = Optional(\n    _forceCreateUniqueMutableBuffer(\n        &amp;_buffer, countForNewBuffer: oldCount, minNewCapacity: newCount))\n    _arrayOutOfPlaceUpdate(\n        &amp;_buffer, &amp;newBuffer, oldCount, 0, _IgnorePointer())\n    }\n</code></pre>\n\n<p>这个方法又分为两步，<font color = \"rgb(226,238,250)\"><code>_forceCreateUniqueMutableBuffer</code></font>和<font color = \"rgb(226,238,250)\"><code>_arrayOutOfPlaceUpdate</code></font>。前者实现了新存储区域的创建，而后者完成了数据的复制工作。</p>\n\n<p>为了简单起见，我们先看看<font color = \"rgb(226,238,250)\"><code>_arrayOutOfPlaceUpdate</code></font>函数,这个函数的实现太长了，不过好在有注释：</p>\n\n<pre><code class=\"language-swift\">/// Initialize the elements of dest by copying the first headCount\n/// items from source, calling initializeNewElements on the next\n/// uninitialized element, and finally by copying the last N items\n/// from source into the N remaining uninitialized elements of dest.\n///\n/// As an optimization, may move elements out of source rather than\n/// copying when it isUniquelyReferenced.\n</code></pre>\n\n<p>大意是说，源数组中已存在的元素会被复制到目标数组中，如果新数组比较长，空缺部分会调用<font color = \"rgb(226,238,250)\"><code>initializeNewElements</code></font>方法来初始化。为了优化性能，被唯一引用的元素可能会直接从源数组移到新数组而不是复制。其实就是换了一个指针指向那个元素，从而避免了复制。</p>\n\n<p>接下来我们再研究一下比较关键的<font color = \"rgb(226,238,250)\"><code>_forceCreateUniqueMutableBuffer</code></font>部分，也就是数组是怎样扩容的：</p>\n\n<pre><code class=\"language-swift\">@inline(never)\nfunc _forceCreateUniqueMutableBuffer&lt;_Buffer : _ArrayBufferType&gt;(  \n    inout source: _Buffer,  countForNewBuffer: Int,  minNewCapacity: Int\n    ) -&gt; _ContiguousArrayBuffer&lt;_Buffer.Element&gt; {\n\n    //其实什么也没干，多加了一个参数就转发给 _forceCreateUniqueMutableBufferImpl了\n      return _forceCreateUniqueMutableBufferImpl(\n        &amp;source, countForBuffer: countForNewBuffer, minNewCapacity: minNewCapacity,\n        requiredCapacity: minNewCapacity)\n}\n\ninternal func _forceCreateUniqueMutableBufferImpl&lt;_Buffer : _ArrayBufferType&gt;(  \n  inout source: _Buffer,  countForBuffer: Int, minNewCapacity: Int,\n  requiredCapacity: Int\n) -&gt; _ContiguousArrayBuffer&lt;_Buffer.Element&gt; {\n    _sanityCheck(countForBuffer &gt;= 0)\n      _sanityCheck(requiredCapacity &gt;= countForBuffer)\n      _sanityCheck(minNewCapacity &gt;= countForBuffer)\n\n      let minimumCapacity = max(\n    requiredCapacity, minNewCapacity &gt; source.capacity\n        ? _growArrayCapacity(source.capacity) : source.capacity)\n\n    return _ContiguousArrayBuffer(\n        count: countForBuffer, minimumCapacity: minimumCapacity)\n}\n</code></pre>\n\n<p><font color = \"rgb(226,238,250)\"><code>_forceCreateUniqueMutableBufferImpl</code></font>函数刚开始的三个检查读者可以自行理解，关键部分在于<font color = \"rgb(226,238,250)\"><code>minimumCapacity</code></font>的计算。因为它会作为容量参数被传到用于创建新的Buffer的函数中。</p>\n\n<p>这个函数有四个参数，第一个参数buffer可以理解为数组中真正用于数据存放的那个部分。对于最后两个参数，意思有点像，我们不妨考虑一个实际的、需要进行数组扩容的情况，向一个容量为3，长度为3的数组新增一个元素1，此时函数的调用顺序如下：</p>\n\n<ol>\n<li><font color = \"rgb(226,238,250)\"><code>append(1)</code></font>  </li>\n<li><font color = \"rgb(226,238,250)\"><code>_reserveCapacityAssumingUniqueBuffer(3)</code></font>  </li>\n<li><font color = \"rgb(226,238,250)\"><code>_copyToNewBuffer(3)</code></font>  </li>\n<li><font color = \"rgb(226,238,250)\"><code>_forceCreateUniqueMutableBuffer(&amp;_buffer, countForNewBuffer: 3, minNewCapacity: 4)</code></font>  </li>\n<li><font color = \"rgb(226,238,250)\"><code>_forceCreateUniqueMutableBufferImpl(&amp;_buffer, countForBuffer: 3, minNewCapacity: 4, requiredCapacity: 4)</code></font></li>\n</ol>\n\n<p>还记得<font color = \"rgb(226,238,250)\"><code>_copyToNewBuffer()</code></font>方法里的<code>let newCount = oldCount + 1</code>么，所以<font color = \"rgb(226,238,250)\"><code>oldCount(=3)</code></font>作为<font color = \"rgb(226,238,250)\"><code>minNewCapacity</code></font>，而<font color = \"rgb(226,238,250)\"><code>newCount(=4)</code></font>作为<font color = \"rgb(226,238,250)\"><code>requiredCapacity</code></font>参数被传入<font color = \"rgb(226,238,250)\"><code>_forceCreateUniqueMutableBufferImpl</code></font>方法。</p>\n\n<p>此时，<font color = \"rgb(226,238,250)\"><code>minimumCapacity</code></font>的计算，其实就是以下表达式的值：</p>\n\n<pre><code class=\"language-swift\">max(4, 4 &gt; 3 ? _growArrayCapacity(3) : 3)  \n</code></pre>\n\n<p>我们知道，如果数组需要扩容，<font color = \"rgb(226,238,250)\"><code>source.capacity</code></font>总是等于<font color = \"rgb(226,238,250)\"><code>minNewCapacity</code></font>的。也就是说上式可以写为：</p>\n\n<pre><code class=\"language-swift\">max(length+1, length+1 &gt; length ? _growArrayCapacity(length) : length)\n\n//等价于\nmax(length+1, _growArrayCapacity(length))  \n</code></pre>\n\n<p>可以看到<font color = \"rgb(226,238,250)\"><code>_growArrayCapacity</code></font>返回值是传入参数的两倍：</p>\n\n<pre><code class=\"language-swift\">@warn_unused_result\ninternal func _growArrayCapacity(capacity: Int) -&gt; Int {  \n  return capacity * 2\n}\n</code></pre>\n\n<p>所以<font color = \"rgb(226,238,250)\"><code>minimumCapacity</code></font> = <font color = \"rgb(226,238,250)\"><code>max(length+1, 2 * length)</code></font> = <font color = \"rgb(226,238,250)\"><code>2 * length</code></font>。也就是新扩容的数组长度其实翻倍了。</p>\n\n<h1 id=\"\">线程安全</h1>\n\n<p>现在我们可以理解为什么<font color = \"rgb(226,238,250)\"><code>append</code></font>方法不是线程安全的了。如果在某一个线程中插入新元素，导致了数组扩容，那么Swift会创建一个新的数组（意味着地址完全不同）。然后ARC会为我们自动释放旧的数组，但这时候可能另一个线程还在访问旧的数组对象。</p>\n\n<h1 id=\"\">验证</h1>\n\n<p>说了这么多，我们来证明一下Swift数组扩容的工作原理：</p>\n\n<pre><code class=\"language-swift\">let semaphore = dispatch_semaphore_create(1)  \nvar array: [Int] = []  \nfor i in 1...100000 {  \n    array.append(i)\n    let arrayPtr = UnsafeMutableBufferPointer&lt;Int&gt;(start: &amp;array, count: array.count)\n    print(arrayPtr)\n}\n</code></pre>\n\n<p>运行结果如下，可以验证文章开头的结论：“初始容量为2，扩容时容量翻倍”</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Swift_append/double.png\" alt=\"容量翻倍\" /></p>","image":null,"featured":0,"page":1,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:00:49.000Z","created_by":1,"updated_at":"2016-01-28T16:30:15.000Z","updated_by":1,"published_at":"2015-12-09T08:00:00.000Z","published_by":1},{"id":7,"uuid":"03c046b0-eb28-47e3-bfdc-8d7e2c377bc6","title":"深入探究Swift数组背后的协议、方法、拓展","slug":"swiftarrayimplemation","markdown":"最近翻译完了[《Advanced Swift》中文版](http://www.jianshu.com/p/18744b078508)的“集合”章节。书的质量非常高，讲解非常细致。但不可避免的导致篇幅有点长，有些前面的知识点看到后面无法串联起来。同时由于偏重于讲解，所以个人感觉总结还不够，比如我们可以考虑这几个问题：\n\n* 数组类型(_ArrayType)、集合(Collection)、序列(Sequence)、生成器(Generator)、元素(Element)、下标(Index)，这些类型(协议)各自的作用。\n* 数组是如何利用上面这些类实现各种方法的。\n* <font color = \"rgb(226,238,250)\">`map`</font>、<font color = \"rgb(226,238,250)\">`reduce`</font>、<font color = \"rgb(226,238,250)\">`filter`</font>等方法的作用是什么，他们是怎么实现的。\n* 只有数组有上面这些方法么，如果不是，什么样的类型才有这些方法。\n* 如果实现一个自定义的集合类型，应该怎么做。\n\n而这些问题恰恰是过去我们没有重视或根本无法找到答案的问题。因为在OC中，由于<font color = \"rgb(226,238,250)\">`NSArray`</font>封装的非常好，而且在单纯的iOS开发中对数组的理解不用非常深入，所以我们很少深究数组背后的实现原理。\n\n其实答案就遍布在[《Advanced Swift》中文版](http://www.jianshu.com/p/18744b078508)的“集合”章节的各篇文章中。本文会通过分析Swift中数组的实现，回答上述问题并尝试着建立完整的知识体系。由于篇幅所限，本文不会给出非常详细的源码，而是做总结性的提炼。\n\n# 参考文章\n\n* [Advanced Swift——数组可变性](http://www.jianshu.com/p/21d518da46ed)：主要介绍数组的值语义\n* [Advanced Swift——数组变换](http://www.jianshu.com/p/7b1bb303ec45)： 主要介绍<font color = \"rgb(226,238,250)\">`map`</font>、<font color = \"rgb(226,238,250)\">`reduce`</font>、<font color = \"rgb(226,238,250)\">`filter`</font>等方法的使用和原理\n* [Advanced Swift——字典与集合](http://www.jianshu.com/p/17731dd5db55)：主要介绍字典与集合类型的使用\n* [Advanced Swift——集合协议](http://www.jianshu.com/p/17731dd5db55)：主要介绍数组相关的三种协议\n* [Advanced Swift——集合](http://www.jianshu.com/p/847797ecb79b)：通过实现一个队列，介绍<font color = \"rgb(226,238,250)\">`CollectionType`</font>类型的使用\n* [Advanced Swift——下标](http://www.jianshu.com/p/a22e29b75e40)：实现自定义链表，介绍数组下标的相关知识\n\n#相关类型简介\n\n我们从零开始，根据集合最本质的特点开始思考，逐步抽象。\n\n###元素(Element)\n\n对于任何一种集合来说，它本质上是一种数据结构，也就是用来存放数据的。我们在各种代码中见到的<font color = \"rgb(226,238,250)\">`Element`</font>表示的就是最底层数据的类型别名。因为对于集合这种范型类型来说，它不关心具体存放的数据的类型，所以就用通用的<font color = \"rgb(226,238,250)\">`Element`</font>来代替，比如我们写这样的代码:\n\n```swift\nlet array: Array<Int> = [1,2,3]\n```\n\n这就相当于告诉数组，<font color = \"rgb(226,238,250)\">`Element`</font>现在具体变为<font color = \"rgb(226,238,250)\">`Int`</font>类型了。\n\n###生成器(Generator)\n\n对于集合来说，它往往还需要提供遍历的功能。那怎么把它设计为可遍历的呢？不要指望for循环，要知道目前我们什么都没有，没有数组的概念，更没有下标的概念。有一句名言说：“任何编程问题都可以通过增加一个中间层来解决”。于是，我们抽象出一个<font color = \"rgb(226,238,250)\">`Generator `</font>(生成器)的概念。我们把它声明成一个协议，任何实现这个协议的类都要提供一个<font color = \"rgb(226,238,250)\">`next`</font>方法，返回集合中的下一个元素：\n\n```swift\nprotocol GeneratorType {\n\ttypealias Element\n\tmutating func next() -> Element?\n}\n```\n\n可以想象的是这样一来，实现了<font color = \"rgb(226,238,250)\">`GeneratorType `</font>协议的类，就可以隐藏具体元素的信息，通过不断调用<font color = \"rgb(226,238,250)\">`next`</font>方法就可以获得所有元素了。比如你可以用一个生成器，不断生成斐波那契数列的下一个数字。\n\n总的来说，生成器(<font color = \"rgb(226,238,250)\">`Generator `</font>)允许我们遍历所有的元素。\n\n### 序列(Sequence)\n\n生成器不断生成下一个元素，但是已经生成过的元素就无法再获取到了。比如在斐波那契数列中通过3和5得到了8，那么这个生成器永远也不会再生成元素3了，下一个生成的元素是13。也就是说对于生成器来说，已经访问过的元素就无法再次获取到。\n\n然而对于集合来说，它所包含的元素总是客观存在的。为了能够多次遍历集合，我们抽象出了序列(<font color = \"rgb(226,238,250)\">`Sequence `</font>)的概念。<font color = \"rgb(226,238,250)\">`Sequence `</font>封装了<font color = \"rgb(226,238,250)\">`Generator `</font>对象的创建过程：\n\n```swift\nprotocol SequenceType {\n\ttypealias Generator: GeneratorType\n\tfunc generate() -> Generator\n}\n```\n\n序列(<font color = \"rgb(226,238,250)\">`Sequence `</font>)相比于单纯的<font color = \"rgb(226,238,250)\">`Generator `</font>，使**反复**遍历集合中的元素成为可能。这时候，我们已经可以通过<font color = \"rgb(226,238,250)\">`for`</font>循环而不是<font color = \"rgb(226,238,250)\">`Generator`</font>来遍历所有元素。\n\n### 集合(Collection)\n\n对比一下现有的<font color = \"rgb(226,238,250)\">`Sequence `</font>和数组，会发现它还欠缺一个特性——下标。\n\n回顾一下<font color = \"rgb(226,238,250)\">`Generator `</font>和<font color = \"rgb(226,238,250)\">`Sequence `</font>，它们只是实现了集合的遍历，但没有指定怎么遍历。也就是说，只要<font color = \"rgb(226,238,250)\">`Generator `</font>设计“得当”，即使是1和2这两个元素，我们也可以不断遍历：“1的next是2，2的next是1”。这种情况显然不符合我们对数组的认识。归根结底，还是<font color = \"rgb(226,238,250)\">`Sequence `</font>中无法确定元素的位置，也就无法确保不遍历到已经访问过的元素。\n\n基于这种考虑，我们抽象出集合(<font color = \"rgb(226,238,250)\">`Collection`</font>)的概念。在集合中，每个元素都有确切的位置，因此集合有明确的开始位置和结束位置。给定一个位置，就可以找到这个位置上的元素。<font color = \"rgb(226,238,250)\">`Collection`</font>在<font color = \"rgb(226,238,250)\">`Sequence`</font>的基础上实现了<font color = \"rgb(226,238,250)\">`Indexable`</font>协议\n\n```swift\n\npublic protocol CollectionType : Indexable, SequenceType {\n\tpublic var startIndex: Self.Index { get }\n\tpublic var endIndex: Self.Index { get }\n\tpublic subscript (position: Self.Index) -> Self._Element { get }\n}\n```\n\n当然，<font color = \"rgb(226,238,250)\">`CollectionType`</font>中的内容远远不止这些。这里列出的仅仅是为了表示<font color = \"rgb(226,238,250)\">`CollectionType`</font>的特性。\n\n### 下标(Index)\n\n虽然我们在使用数组的时候，元素下标总是从0开始，并且逐个递增。但下标不必是从0开始递增的整数。比如<font color = \"rgb(226,238,250)\">`a、b、c……`</font>也可以作为下标。下标类型的关键在于能根据某一个下标推断出下一个下标是什么，比如对于整数来说下一个下标就是当前下标值加1。下标类型的协议如下：\n\n```swift\npublic protocol ForwardIndexType : _Incrementable {\n\t///....\n}\n\npublic protocol _Incrementable : Equatable {\n    public func successor() -> Self\n}\n```\n\n对于下标类型来说，它们必须实现<font color = \"rgb(226,238,250)\">`successor()`</font>方法，同时也得是<font color = \"rgb(226,238,250)\">`Equatable`</font>的，否则怎么知道某个位置上的元素已经被访问过了呢。\n\n#数组简介\n\n有了以上基本知识做铺垫，接下来就可以研究一下Swift中数组是怎么实现的了。\n\n### 基本定义\n我们可能早已体会到Swift数组的强大，它的下标脚本不仅可以读取元素，还可以直接修改元素。它可以通过字面量初始化，还可以调用\n<font color = \"rgb(226,238,250)\">`appendContentsOf `</font>方法从别的数组中添加元素。甚至于我们可能都没有仔细考虑过为什么可以用<font color = \"rgb(226,238,250)\">`for number in array`</font>这样的语法。\n\n首先，我们需要明确一个概念：数组丰富强大的特性绝不是由<font color = \"rgb(226,238,250)\">`Array`</font>这一个类型可以提供的。实际上，这主要是协议的功劳。用OC写iOS时，协议几乎就是代理的代名词(可能是我对OC不甚精通，目光短浅)，但毋庸置疑的是在Swift中，协议的功能被空前的强化。数组通过实现协议、以及协议的嵌套、拓展功能，具有了很多特性。数组的背后交织着错综复杂的协议、方法和拓展。\n\n下面是数组的定义：\n\n```swift\npublic struct Array<Element> : CollectionType, MutableCollectionType, _DestructorSafeContainer {\n    public var startIndex: Int { get }\n    public var endIndex: Int { get }\n    public subscript (index: Int) -> Element\n    public subscript (subRange: Range<Int>) -> ArraySlice<Element>\n}\n```\n\n数组是一个结构体，它实现了三个协议，有两个变量和两个下标脚本。除此以外，数组还有大量的拓展。\n###数组拓展\n\n数组的大量功能在拓展中完成，由于拓展很多，我就不列出完整代码，只是做一个整理。数组一共拓展了四类协议：\n\n* <font color = \"rgb(226,238,250)\">`ArrayLiteralConvertible `</font>： 这个协议是为了支持这样的语法的：<font color = \"rgb(226,238,250)\">`let a: Array<Int> = [1,2,3]`</font>。实现协议很简单，只要提供一个自定义方法即可：\n\n```swift\npublic init(arrayLiteral elements: Element...)\n```\n* <font color = \"rgb(226,238,250)\">`_Reflectable `</font>：这个协议用于处理反射相关的内容，这里不做详解\n* <font color = \"rgb(226,238,250)\">`CustomStringConvertible `</font>和<font color = \"rgb(226,238,250)\">`CustomDebugStringConvertible `</font>：这两个是方便我们调试的协议，与数组自身的功能无关。\n* <font color = \"rgb(226,238,250)\">`_ArrayType `</font>：这是数组**最关键的**部分。在实现这个协议之前，数组还只是一个普通的集合类型，它仅仅是拥有下标，而且可以重复遍历所有元素而已。而通过实现<font color = \"rgb(226,238,250)\">`_ArrayType `</font>协议，它可以**在指定位置(下标)添加或移除一个或多个元素**，它还有了自己的<font color = \"rgb(226,238,250)\">`count`</font>属性。\n\n这一点也许有些颠覆我们此前的认识。一个集合类型，是不能添加或删除元素的。数组通过实现了<font color = \"rgb(226,238,250)\">`_ArrayType `</font>协议提供了这样的功能。但这也很容易理解，因为集合的本质还是在于元素的收集，而非考虑如何改变这些元素。\n\n<font color = \"rgb(226,238,250)\">`_ArrayType `</font>协议还给了我们一个非常重要的启示。比如说我想实现自己的数据结构——栈，那么就应该实现对应的<font color = \"rgb(226,238,250)\">`_StackType `</font>协议。这种协议要充分考虑数据结构自身的特点，从而提供对应的方法。比如我们不可能向栈的某个特定位置添加若干个元素(只能向栈顶添加一个)。所以<font color = \"rgb(226,238,250)\">`_StackType `</font>协议中不会定义<font color = \"rgb(226,238,250)\">`append `</font>、<font color = \"rgb(226,238,250)\">`appendContentsOf`</font>这样的方法，而是应该定义<font color = \"rgb(226,238,250)\">`pop`</font>和<font color = \"rgb(226,238,250)\">`push`</font>方法。\n\n#SequenceType\n\n接下来的任务是搞清楚<font color = \"rgb(226,238,250)\">`ColectionType`</font>的原理了。不过在此之前，我们先来看看<font color = \"rgb(226,238,250)\">`SequenceType`</font>的一些细节，毕竟<font color = \"rgb(226,238,250)\">`CollectionType`</font>协议是继承了<font color = \"rgb(226,238,250)\">`SequenceType`</font>协议的。\n\n在有了<font color = \"rgb(226,238,250)\">`Generator`</font>之后，我们已经可以在<font color = \"rgb(226,238,250)\">`while`</font>循环中用<font color = \"rgb(226,238,250)\">`Generator`</font>的<font color = \"rgb(226,238,250)\">`next`</font>方法遍历所有元素了。之前也说过，<font color = \"rgb(226,238,250)\">`SequenceType`</font>使对元素的多次遍历成为可能。\n\n注意，仅仅是成为可能而已。如果遍历的细节由<font color = \"rgb(226,238,250)\">`Generator`</font>控制，那么多次遍历是没有问题的。在极个别情况下，但如果遍历的细节依赖于<font color = \"rgb(226,238,250)\">`SequenceType`</font>自身的某个属性，而且这个属性会发生变化，那么就不能多次遍历所有元素了。\n\n<font color = \"rgb(226,238,250)\">`SequenceType`</font>协议的基本部分非常简单，只有一个<font color = \"rgb(226,238,250)\">`generator()`</font>方法，封装了<font color = \"rgb(226,238,250)\">`Generator`</font>的创建过程。\n\n一旦有了遍历元素的概念，<font color = \"rgb(226,238,250)\">`SequenceType`</font>立刻就有了非常多的拓展。这里简单列举几个比较关键的：\n\n* <font color = \"rgb(226,238,250)\">`forEach`</font>：这个拓展使得我们可以用for循环遍历集合了：<font color = \"rgb(226,238,250)\">`for item in sequence`</font>\n* <font color = \"rgb(226,238,250)\">`dropFirst(n: Int)`</font>和<font color = \"rgb(226,238,250)\">`dropLast(n: Int)`</font>：这两个方法返回的是除了前(后)n个元素之外的<font color = \"rgb(226,238,250)\">`Sequence`</font>。需要提一下的是，由于此时的<font color = \"rgb(226,238,250)\">`SequenceType`</font>还没有下标的概念，这两个方法的实现是**非常复杂**的。\n* <font color = \"rgb(226,238,250)\">`prefix(maxLength: Int)`</font>和<font color = \"rgb(226,238,250)\">`suffix(maxLength: Int)`</font>：和刚刚两个方法类似，这两个方法返回的是前(后)maxLength个元素，实现也不简单。\n* <font color = \"rgb(226,238,250)\">`elementsEqual`</font>、<font color = \"rgb(226,238,250)\">`contains`</font>、<font color = \"rgb(226,238,250)\">`minElement`</font>、<font color = \"rgb(226,238,250)\">`maxElement`</font>等，这些都是针对元素的判断和选择。\n* <font color = \"rgb(226,238,250)\">`map`</font>、<font color = \"rgb(226,238,250)\">`flatMap`</font>、<font color = \"rgb(226,238,250)\">`filter`</font>、<font color = \"rgb(226,238,250)\">`reduce`</font>这些方法是针对所有元素的变换。\n\n<font color = \"rgb(226,238,250)\">`SequenceType`</font>的拓展实在是太多了，但总结来看不外乎两点：\n\n1. 由于可以多次遍历元素了，我们可以对元素进行各种比较、处理、筛选等等操作。这些派生出来的方法和函数极大的强化了<font color = \"rgb(226,238,250)\">`SequenceType `</font>的功能。\n2. 由于<font color = \"rgb(226,238,250)\">`SequenceType `</font>自身的局限性，不能保证一定可以多次遍历所有元素，还没有下标和元素位置的概念，因此某些方法的实现还不够高效，\n\n带着这样的遗憾，我们来看看最关键的<font color = \"rgb(226,238,250)\">`CollectionType `</font>是如何实现的。\n\n#细谈CollectionType\n\n之前我们说过<font color = \"rgb(226,238,250)\">`CollectionType`</font>协议是在<font color = \"rgb(226,238,250)\">`SequenceType`</font>的基础上实现了<font color = \"rgb(226,238,250)\">`Indexable`</font>协议。由于协议的继承关系，任何实现了<font color = \"rgb(226,238,250)\">`CollectionType`</font>协议的类，必须实现<font color = \"rgb(226,238,250)\">`Indexable`</font>协议规定的两个参数：<font color = \"rgb(226,238,250)\">`startIndex`</font>和<font color = \"rgb(226,238,250)\">`endIndex`</font>，以及一个下标脚本：<font color = \"rgb(226,238,250)\">`subscript (position: Self.Index) -> Self._Element { get }`</font>。即使这三个要求在<font color = \"rgb(226,238,250)\">`CollectionType`</font>中没有直接标出来。\n\n回顾一下数组定义的前三行，正是满足了这三个要求。再看<font color = \"rgb(226,238,250)\">`CollectionType`</font>,它不仅重载了<font color = \"rgb(226,238,250)\">`Indexable`</font>的一个下标脚本，还额外提供了一个下标脚本用来访问某一段元素，这个下标脚本返回的类型是切片(<font color = \"rgb(226,238,250)\">`Slice`</font>)。这也正是数组定义的第四行，实现的内容。\n\n细心的读者可能已经注意到，<font color = \"rgb(226,238,250)\">`CollectionType`</font>还定义了很多属性和方法，比如：<font color = \"rgb(226,238,250)\">`prefixUpTo`</font>、<font color = \"rgb(226,238,250)\">`suffixFrom`</font>、<font color = \"rgb(226,238,250)\">`isEmpty`</font>、<font color = \"rgb(226,238,250)\">`first`</font>等等。但数组没有实现其中的任何一个。\n\n事实上，这不仅不是数组设计的失败之处，而正是Swift协议的强大之处。Swift可以通过协议拓展，为计算属性和方法提供默认实现。因此，数组可以不用写任何代码就具备这些方法。更赞的是，任何实现了<font color = \"rgb(226,238,250)\">`CollectionType`</font>协议的类型也因此具有了这些方法。\n\n观察一下<font color = \"rgb(226,238,250)\">`CollectionType `</font>的其它拓展，大部分都是重写了<font color = \"rgb(226,238,250)\">`SequenceType `</font>中的实现。之前已经提到过<font color = \"rgb(226,238,250)\">`SequenceType `</font>没有下标的概念，而类似于<font color = \"rgb(226,238,250)\">`dropFirst `</font>这样的方法，利用下标的概念是非常容易实现的。\n\n除了对一些已有方法的重写之外，<font color = \"rgb(226,238,250)\">`CollectionType `</font>还新增了一些基于下标的方法。比如<font color = \"rgb(226,238,250)\">`indexOf() `</font>等。\n\n套用官方文档中对<font color = \"rgb(226,238,250)\">`CollectionType `</font>的总结就是：\n\n>     A multi-pass sequence with addressable positions\n\n也就是说<font color = \"rgb(226,238,250)\">`CollectionType `</font>是可以多次遍历，元素可定位的<font color = \"rgb(226,238,250)\">`SequenceType `</font>\n\n#总结\n\n<font color = \"rgb(226,238,250)\">`Element`</font>、<font color = \"rgb(226,238,250)\">`Generator`</font>、<font color = \"rgb(226,238,250)\">`SequenceType`</font>、<font color = \"rgb(226,238,250)\">`CollectionType`</font>、<font color = \"rgb(226,238,250)\">`Array`</font>由下至上构造了数组背后的层次结构。他们的关系如下图所示：\n\n![Swift数组层次结构](http://7xonij.com1.z0.glb.clouddn.com/Advanced%20Swift/Collection/array-hierarchy.png)\n\n\n如果我们希望定义一个自己的数据结构，比如链表。首先可以明确它要实现<font color = \"rgb(226,238,250)\">`CollectionType`</font>协议。链表应该是和<font color = \"rgb(226,238,250)\">`Array`</font>同层次的类型。然后我们需要定义一个<font color = \"rgb(226,238,250)\">`_ListType`</font>的协议，这个协议对应数组的<font color = \"rgb(226,238,250)\">`_ArrayList`</font>协议，根据数据结构自身的特性定义一些方法。\n\n如果觉得<font color = \"rgb(226,238,250)\">`CollectionType`</font>甚至是<font color = \"rgb(226,238,250)\">`SequenceType`</font>不满足我们的需求，我们还可以自己实现对应的类型。难度不会很大，因为它们虽然负责，但大多数方法已有默认实现，我们只要重写一些关键的逻辑即可。\n\n最后需要说明的是，Swift中对集合的实现实在是太复杂了，如果每个都详细分析，怕是可以写一本书。希望读完这篇文章后，读者可以举一反三，自行阅读源码解决相关问题。","html":"<p>最近翻译完了<a href=\"http://www.jianshu.com/p/18744b078508\">《Advanced Swift》中文版</a>的“集合”章节。书的质量非常高，讲解非常细致。但不可避免的导致篇幅有点长，有些前面的知识点看到后面无法串联起来。同时由于偏重于讲解，所以个人感觉总结还不够，比如我们可以考虑这几个问题：</p>\n\n<ul>\n<li>数组类型(_ArrayType)、集合(Collection)、序列(Sequence)、生成器(Generator)、元素(Element)、下标(Index)，这些类型(协议)各自的作用。</li>\n<li>数组是如何利用上面这些类实现各种方法的。</li>\n<li><font color = \"rgb(226,238,250)\"><code>map</code></font>、<font color = \"rgb(226,238,250)\"><code>reduce</code></font>、<font color = \"rgb(226,238,250)\"><code>filter</code></font>等方法的作用是什么，他们是怎么实现的。</li>\n<li>只有数组有上面这些方法么，如果不是，什么样的类型才有这些方法。</li>\n<li>如果实现一个自定义的集合类型，应该怎么做。</li>\n</ul>\n\n<p>而这些问题恰恰是过去我们没有重视或根本无法找到答案的问题。因为在OC中，由于<font color = \"rgb(226,238,250)\"><code>NSArray</code></font>封装的非常好，而且在单纯的iOS开发中对数组的理解不用非常深入，所以我们很少深究数组背后的实现原理。</p>\n\n<p>其实答案就遍布在<a href=\"http://www.jianshu.com/p/18744b078508\">《Advanced Swift》中文版</a>的“集合”章节的各篇文章中。本文会通过分析Swift中数组的实现，回答上述问题并尝试着建立完整的知识体系。由于篇幅所限，本文不会给出非常详细的源码，而是做总结性的提炼。</p>\n\n<h1 id=\"\">参考文章</h1>\n\n<ul>\n<li><a href=\"http://www.jianshu.com/p/21d518da46ed\">Advanced Swift——数组可变性</a>：主要介绍数组的值语义</li>\n<li><a href=\"http://www.jianshu.com/p/7b1bb303ec45\">Advanced Swift——数组变换</a>： 主要介绍<font color = \"rgb(226,238,250)\"><code>map</code></font>、<font color = \"rgb(226,238,250)\"><code>reduce</code></font>、<font color = \"rgb(226,238,250)\"><code>filter</code></font>等方法的使用和原理</li>\n<li><a href=\"http://www.jianshu.com/p/17731dd5db55\">Advanced Swift——字典与集合</a>：主要介绍字典与集合类型的使用</li>\n<li><a href=\"http://www.jianshu.com/p/17731dd5db55\">Advanced Swift——集合协议</a>：主要介绍数组相关的三种协议</li>\n<li><a href=\"http://www.jianshu.com/p/847797ecb79b\">Advanced Swift——集合</a>：通过实现一个队列，介绍<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>类型的使用</li>\n<li><a href=\"http://www.jianshu.com/p/a22e29b75e40\">Advanced Swift——下标</a>：实现自定义链表，介绍数组下标的相关知识</li>\n</ul>\n\n<h1 id=\"\">相关类型简介</h1>\n\n<p>我们从零开始，根据集合最本质的特点开始思考，逐步抽象。</p>\n\n<h3 id=\"element\">元素(Element)</h3>\n\n<p>对于任何一种集合来说，它本质上是一种数据结构，也就是用来存放数据的。我们在各种代码中见到的<font color = \"rgb(226,238,250)\"><code>Element</code></font>表示的就是最底层数据的类型别名。因为对于集合这种范型类型来说，它不关心具体存放的数据的类型，所以就用通用的<font color = \"rgb(226,238,250)\"><code>Element</code></font>来代替，比如我们写这样的代码:</p>\n\n<pre><code class=\"language-swift\">let array: Array&lt;Int&gt; = [1,2,3]  \n</code></pre>\n\n<p>这就相当于告诉数组，<font color = \"rgb(226,238,250)\"><code>Element</code></font>现在具体变为<font color = \"rgb(226,238,250)\"><code>Int</code></font>类型了。</p>\n\n<h3 id=\"generator\">生成器(Generator)</h3>\n\n<p>对于集合来说，它往往还需要提供遍历的功能。那怎么把它设计为可遍历的呢？不要指望for循环，要知道目前我们什么都没有，没有数组的概念，更没有下标的概念。有一句名言说：“任何编程问题都可以通过增加一个中间层来解决”。于是，我们抽象出一个<font color = \"rgb(226,238,250)\"><code>Generator</code></font>(生成器)的概念。我们把它声明成一个协议，任何实现这个协议的类都要提供一个<font color = \"rgb(226,238,250)\"><code>next</code></font>方法，返回集合中的下一个元素：</p>\n\n<pre><code class=\"language-swift\">protocol GeneratorType {  \n    typealias Element\n    mutating func next() -&gt; Element?\n}\n</code></pre>\n\n<p>可以想象的是这样一来，实现了<font color = \"rgb(226,238,250)\"><code>GeneratorType</code></font>协议的类，就可以隐藏具体元素的信息，通过不断调用<font color = \"rgb(226,238,250)\"><code>next</code></font>方法就可以获得所有元素了。比如你可以用一个生成器，不断生成斐波那契数列的下一个数字。</p>\n\n<p>总的来说，生成器(<font color = \"rgb(226,238,250)\"><code>Generator</code></font>)允许我们遍历所有的元素。</p>\n\n<h3 id=\"sequence\">序列(Sequence)</h3>\n\n<p>生成器不断生成下一个元素，但是已经生成过的元素就无法再获取到了。比如在斐波那契数列中通过3和5得到了8，那么这个生成器永远也不会再生成元素3了，下一个生成的元素是13。也就是说对于生成器来说，已经访问过的元素就无法再次获取到。</p>\n\n<p>然而对于集合来说，它所包含的元素总是客观存在的。为了能够多次遍历集合，我们抽象出了序列(<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>)的概念。<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>封装了<font color = \"rgb(226,238,250)\"><code>Generator</code></font>对象的创建过程：</p>\n\n<pre><code class=\"language-swift\">protocol SequenceType {  \n    typealias Generator: GeneratorType\n    func generate() -&gt; Generator\n}\n</code></pre>\n\n<p>序列(<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>)相比于单纯的<font color = \"rgb(226,238,250)\"><code>Generator</code></font>，使<strong>反复</strong>遍历集合中的元素成为可能。这时候，我们已经可以通过<font color = \"rgb(226,238,250)\"><code>for</code></font>循环而不是<font color = \"rgb(226,238,250)\"><code>Generator</code></font>来遍历所有元素。</p>\n\n<h3 id=\"collection\">集合(Collection)</h3>\n\n<p>对比一下现有的<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>和数组，会发现它还欠缺一个特性——下标。</p>\n\n<p>回顾一下<font color = \"rgb(226,238,250)\"><code>Generator</code></font>和<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>，它们只是实现了集合的遍历，但没有指定怎么遍历。也就是说，只要<font color = \"rgb(226,238,250)\"><code>Generator</code></font>设计“得当”，即使是1和2这两个元素，我们也可以不断遍历：“1的next是2，2的next是1”。这种情况显然不符合我们对数组的认识。归根结底，还是<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>中无法确定元素的位置，也就无法确保不遍历到已经访问过的元素。</p>\n\n<p>基于这种考虑，我们抽象出集合(<font color = \"rgb(226,238,250)\"><code>Collection</code></font>)的概念。在集合中，每个元素都有确切的位置，因此集合有明确的开始位置和结束位置。给定一个位置，就可以找到这个位置上的元素。<font color = \"rgb(226,238,250)\"><code>Collection</code></font>在<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>的基础上实现了<font color = \"rgb(226,238,250)\"><code>Indexable</code></font>协议</p>\n\n<pre><code class=\"language-swift\">public protocol CollectionType : Indexable, SequenceType {  \n    public var startIndex: Self.Index { get }\n    public var endIndex: Self.Index { get }\n    public subscript (position: Self.Index) -&gt; Self._Element { get }\n}\n</code></pre>\n\n<p>当然，<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>中的内容远远不止这些。这里列出的仅仅是为了表示<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>的特性。</p>\n\n<h3 id=\"index\">下标(Index)</h3>\n\n<p>虽然我们在使用数组的时候，元素下标总是从0开始，并且逐个递增。但下标不必是从0开始递增的整数。比如<font color = \"rgb(226,238,250)\"><code>a、b、c……</code></font>也可以作为下标。下标类型的关键在于能根据某一个下标推断出下一个下标是什么，比如对于整数来说下一个下标就是当前下标值加1。下标类型的协议如下：</p>\n\n<pre><code class=\"language-swift\">public protocol ForwardIndexType : _Incrementable {  \n    ///....\n}\n\npublic protocol _Incrementable : Equatable {  \n    public func successor() -&gt; Self\n}\n</code></pre>\n\n<p>对于下标类型来说，它们必须实现<font color = \"rgb(226,238,250)\"><code>successor()</code></font>方法，同时也得是<font color = \"rgb(226,238,250)\"><code>Equatable</code></font>的，否则怎么知道某个位置上的元素已经被访问过了呢。</p>\n\n<h1 id=\"\">数组简介</h1>\n\n<p>有了以上基本知识做铺垫，接下来就可以研究一下Swift中数组是怎么实现的了。</p>\n\n<h3 id=\"\">基本定义</h3>\n\n<p>我们可能早已体会到Swift数组的强大，它的下标脚本不仅可以读取元素，还可以直接修改元素。它可以通过字面量初始化，还可以调用\n<font color = \"rgb(226,238,250)\"><code>appendContentsOf</code></font>方法从别的数组中添加元素。甚至于我们可能都没有仔细考虑过为什么可以用<font color = \"rgb(226,238,250)\"><code>for number in array</code></font>这样的语法。</p>\n\n<p>首先，我们需要明确一个概念：数组丰富强大的特性绝不是由<font color = \"rgb(226,238,250)\"><code>Array</code></font>这一个类型可以提供的。实际上，这主要是协议的功劳。用OC写iOS时，协议几乎就是代理的代名词(可能是我对OC不甚精通，目光短浅)，但毋庸置疑的是在Swift中，协议的功能被空前的强化。数组通过实现协议、以及协议的嵌套、拓展功能，具有了很多特性。数组的背后交织着错综复杂的协议、方法和拓展。</p>\n\n<p>下面是数组的定义：</p>\n\n<pre><code class=\"language-swift\">public struct Array&lt;Element&gt; : CollectionType, MutableCollectionType, _DestructorSafeContainer {  \n    public var startIndex: Int { get }\n    public var endIndex: Int { get }\n    public subscript (index: Int) -&gt; Element\n    public subscript (subRange: Range&lt;Int&gt;) -&gt; ArraySlice&lt;Element&gt;\n}\n</code></pre>\n\n<p>数组是一个结构体，它实现了三个协议，有两个变量和两个下标脚本。除此以外，数组还有大量的拓展。</p>\n\n<h3 id=\"\">数组拓展</h3>\n\n<p>数组的大量功能在拓展中完成，由于拓展很多，我就不列出完整代码，只是做一个整理。数组一共拓展了四类协议：</p>\n\n<ul>\n<li><font color = \"rgb(226,238,250)\"><code>ArrayLiteralConvertible</code></font>： 这个协议是为了支持这样的语法的：<font color = \"rgb(226,238,250)\"><code>let a: Array&lt;Int&gt; = [1,2,3]</code></font>。实现协议很简单，只要提供一个自定义方法即可：</li>\n</ul>\n\n<pre><code class=\"language-swift\">public init(arrayLiteral elements: Element...)  \n</code></pre>\n\n<ul>\n<li><font color = \"rgb(226,238,250)\"><code>_Reflectable</code></font>：这个协议用于处理反射相关的内容，这里不做详解</li>\n<li><font color = \"rgb(226,238,250)\"><code>CustomStringConvertible</code></font>和<font color = \"rgb(226,238,250)\"><code>CustomDebugStringConvertible</code></font>：这两个是方便我们调试的协议，与数组自身的功能无关。</li>\n<li><font color = \"rgb(226,238,250)\"><code>_ArrayType</code></font>：这是数组<strong>最关键的</strong>部分。在实现这个协议之前，数组还只是一个普通的集合类型，它仅仅是拥有下标，而且可以重复遍历所有元素而已。而通过实现<font color = \"rgb(226,238,250)\"><code>_ArrayType</code></font>协议，它可以<strong>在指定位置(下标)添加或移除一个或多个元素</strong>，它还有了自己的<font color = \"rgb(226,238,250)\"><code>count</code></font>属性。</li>\n</ul>\n\n<p>这一点也许有些颠覆我们此前的认识。一个集合类型，是不能添加或删除元素的。数组通过实现了<font color = \"rgb(226,238,250)\"><code>_ArrayType</code></font>协议提供了这样的功能。但这也很容易理解，因为集合的本质还是在于元素的收集，而非考虑如何改变这些元素。</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>_ArrayType</code></font>协议还给了我们一个非常重要的启示。比如说我想实现自己的数据结构——栈，那么就应该实现对应的<font color = \"rgb(226,238,250)\"><code>_StackType</code></font>协议。这种协议要充分考虑数据结构自身的特点，从而提供对应的方法。比如我们不可能向栈的某个特定位置添加若干个元素(只能向栈顶添加一个)。所以<font color = \"rgb(226,238,250)\"><code>_StackType</code></font>协议中不会定义<font color = \"rgb(226,238,250)\"><code>append</code></font>、<font color = \"rgb(226,238,250)\"><code>appendContentsOf</code></font>这样的方法，而是应该定义<font color = \"rgb(226,238,250)\"><code>pop</code></font>和<font color = \"rgb(226,238,250)\"><code>push</code></font>方法。</p>\n\n<h1 id=\"sequencetype\">SequenceType</h1>\n\n<p>接下来的任务是搞清楚<font color = \"rgb(226,238,250)\"><code>ColectionType</code></font>的原理了。不过在此之前，我们先来看看<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>的一些细节，毕竟<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>协议是继承了<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>协议的。</p>\n\n<p>在有了<font color = \"rgb(226,238,250)\"><code>Generator</code></font>之后，我们已经可以在<font color = \"rgb(226,238,250)\"><code>while</code></font>循环中用<font color = \"rgb(226,238,250)\"><code>Generator</code></font>的<font color = \"rgb(226,238,250)\"><code>next</code></font>方法遍历所有元素了。之前也说过，<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>使对元素的多次遍历成为可能。</p>\n\n<p>注意，仅仅是成为可能而已。如果遍历的细节由<font color = \"rgb(226,238,250)\"><code>Generator</code></font>控制，那么多次遍历是没有问题的。在极个别情况下，但如果遍历的细节依赖于<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>自身的某个属性，而且这个属性会发生变化，那么就不能多次遍历所有元素了。</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>协议的基本部分非常简单，只有一个<font color = \"rgb(226,238,250)\"><code>generator()</code></font>方法，封装了<font color = \"rgb(226,238,250)\"><code>Generator</code></font>的创建过程。</p>\n\n<p>一旦有了遍历元素的概念，<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>立刻就有了非常多的拓展。这里简单列举几个比较关键的：</p>\n\n<ul>\n<li><font color = \"rgb(226,238,250)\"><code>forEach</code></font>：这个拓展使得我们可以用for循环遍历集合了：<font color = \"rgb(226,238,250)\"><code>for item in sequence</code></font></li>\n<li><font color = \"rgb(226,238,250)\"><code>dropFirst(n: Int)</code></font>和<font color = \"rgb(226,238,250)\"><code>dropLast(n: Int)</code></font>：这两个方法返回的是除了前(后)n个元素之外的<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>。需要提一下的是，由于此时的<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>还没有下标的概念，这两个方法的实现是<strong>非常复杂</strong>的。</li>\n<li><font color = \"rgb(226,238,250)\"><code>prefix(maxLength: Int)</code></font>和<font color = \"rgb(226,238,250)\"><code>suffix(maxLength: Int)</code></font>：和刚刚两个方法类似，这两个方法返回的是前(后)maxLength个元素，实现也不简单。</li>\n<li><font color = \"rgb(226,238,250)\"><code>elementsEqual</code></font>、<font color = \"rgb(226,238,250)\"><code>contains</code></font>、<font color = \"rgb(226,238,250)\"><code>minElement</code></font>、<font color = \"rgb(226,238,250)\"><code>maxElement</code></font>等，这些都是针对元素的判断和选择。</li>\n<li><font color = \"rgb(226,238,250)\"><code>map</code></font>、<font color = \"rgb(226,238,250)\"><code>flatMap</code></font>、<font color = \"rgb(226,238,250)\"><code>filter</code></font>、<font color = \"rgb(226,238,250)\"><code>reduce</code></font>这些方法是针对所有元素的变换。</li>\n</ul>\n\n<p><font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>的拓展实在是太多了，但总结来看不外乎两点：</p>\n\n<ol>\n<li>由于可以多次遍历元素了，我们可以对元素进行各种比较、处理、筛选等等操作。这些派生出来的方法和函数极大的强化了<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>的功能。  </li>\n<li>由于<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>自身的局限性，不能保证一定可以多次遍历所有元素，还没有下标和元素位置的概念，因此某些方法的实现还不够高效，</li>\n</ol>\n\n<p>带着这样的遗憾，我们来看看最关键的<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>是如何实现的。</p>\n\n<h1 id=\"collectiontype\">细谈CollectionType</h1>\n\n<p>之前我们说过<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>协议是在<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>的基础上实现了<font color = \"rgb(226,238,250)\"><code>Indexable</code></font>协议。由于协议的继承关系，任何实现了<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>协议的类，必须实现<font color = \"rgb(226,238,250)\"><code>Indexable</code></font>协议规定的两个参数：<font color = \"rgb(226,238,250)\"><code>startIndex</code></font>和<font color = \"rgb(226,238,250)\"><code>endIndex</code></font>，以及一个下标脚本：<font color = \"rgb(226,238,250)\"><code>subscript (position: Self.Index) -&gt; Self._Element { get }</code></font>。即使这三个要求在<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>中没有直接标出来。</p>\n\n<p>回顾一下数组定义的前三行，正是满足了这三个要求。再看<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>,它不仅重载了<font color = \"rgb(226,238,250)\"><code>Indexable</code></font>的一个下标脚本，还额外提供了一个下标脚本用来访问某一段元素，这个下标脚本返回的类型是切片(<font color = \"rgb(226,238,250)\"><code>Slice</code></font>)。这也正是数组定义的第四行，实现的内容。</p>\n\n<p>细心的读者可能已经注意到，<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>还定义了很多属性和方法，比如：<font color = \"rgb(226,238,250)\"><code>prefixUpTo</code></font>、<font color = \"rgb(226,238,250)\"><code>suffixFrom</code></font>、<font color = \"rgb(226,238,250)\"><code>isEmpty</code></font>、<font color = \"rgb(226,238,250)\"><code>first</code></font>等等。但数组没有实现其中的任何一个。</p>\n\n<p>事实上，这不仅不是数组设计的失败之处，而正是Swift协议的强大之处。Swift可以通过协议拓展，为计算属性和方法提供默认实现。因此，数组可以不用写任何代码就具备这些方法。更赞的是，任何实现了<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>协议的类型也因此具有了这些方法。</p>\n\n<p>观察一下<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>的其它拓展，大部分都是重写了<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>中的实现。之前已经提到过<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>没有下标的概念，而类似于<font color = \"rgb(226,238,250)\"><code>dropFirst</code></font>这样的方法，利用下标的概念是非常容易实现的。</p>\n\n<p>除了对一些已有方法的重写之外，<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>还新增了一些基于下标的方法。比如<font color = \"rgb(226,238,250)\"><code>indexOf()</code></font>等。</p>\n\n<p>套用官方文档中对<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>的总结就是：</p>\n\n<blockquote>\n<pre><code>A multi-pass sequence with addressable positions\n</code></pre>\n</blockquote>\n\n<p>也就是说<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>是可以多次遍历，元素可定位的<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font></p>\n\n<h1 id=\"\">总结</h1>\n\n<p><font color = \"rgb(226,238,250)\"><code>Element</code></font>、<font color = \"rgb(226,238,250)\"><code>Generator</code></font>、<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>、<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>、<font color = \"rgb(226,238,250)\"><code>Array</code></font>由下至上构造了数组背后的层次结构。他们的关系如下图所示：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Advanced%20Swift/Collection/array-hierarchy.png\" alt=\"Swift数组层次结构\" /></p>\n\n<p>如果我们希望定义一个自己的数据结构，比如链表。首先可以明确它要实现<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>协议。链表应该是和<font color = \"rgb(226,238,250)\"><code>Array</code></font>同层次的类型。然后我们需要定义一个<font color = \"rgb(226,238,250)\"><code>_ListType</code></font>的协议，这个协议对应数组的<font color = \"rgb(226,238,250)\"><code>_ArrayList</code></font>协议，根据数据结构自身的特性定义一些方法。</p>\n\n<p>如果觉得<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>甚至是<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>不满足我们的需求，我们还可以自己实现对应的类型。难度不会很大，因为它们虽然负责，但大多数方法已有默认实现，我们只要重写一些关键的逻辑即可。</p>\n\n<p>最后需要说明的是，Swift中对集合的实现实在是太复杂了，如果每个都详细分析，怕是可以写一本书。希望读完这篇文章后，读者可以举一反三，自行阅读源码解决相关问题。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:04:21.000Z","created_by":1,"updated_at":"2016-01-28T16:32:49.000Z","updated_by":1,"published_at":"2015-12-14T08:04:00.000Z","published_by":1},{"id":8,"uuid":"e2a40440-4d49-413e-b2e1-812e5bdbed2f","title":"从原理分析Swift中switch怎么比较对象","slug":"cong-yuan-li-fen-xi-swiftzhong-switchzen-yao-bi-jiao-dui-xiang","markdown":"今天突然想到一个问题，让我觉得有必要总结一下switch语句。我们知道swift中的switch，远比C语言只能比较整数强大得多，但问题来了，哪些类型可以放到switch中比较呢，对象可以比较么？\n\n<!--more-->\n\n[官方文档](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120)对switch的用法给出了这样的解释：\n\n> Cases can match many different patterns, including interval matches, tuples, and casts to a specific type.\n\n也就是说除了最常用的比较整数、字符串等等之外，switch还可以用来匹配范围、元组，转化成某个特定类型等等。但文档里这个**including**用的实在是无语，因为它没有指明所有可以放在switch中比较的类型，文章开头提出的问题依然没有答案。\n\n我们不妨动手试一下，用switch匹配对象：\n\n```swift\nclass A {\n    \n}\n\nvar o  = A()\nvar o1 = A()\nvar o2 = A()\n\nswitch o {\ncase o1:\n    print(\"it is o1\")\ncase o2:\n    print(\"it is o2\")\ndefault:\n    print(\"not o1 or o2\")\n}\n```\n\n果然，编译器报错了：“Expression pattern of type 'A' cannot match values of type 'A'”。至少我们目前还不明白“expression pattern”是什么，怎么类型A就不能匹配类型A了。\n\n我们做一下改动，在<font color = \"rgb(226,238,250)\">`case`</font>语句后面加上<font color = \"rgb(226,238,250)\">`let`</font>：\n\n```swift\nswitch o {\ncase let o1:\n    print(\"it is o1\")\ncase let o2:\n    print(\"it is o2\")\ndefault:\n    print(\"not o1 or o2\")\n}\n```\n\nOK，编译运行，结果是：<font color = \"rgb(226,238,250)\">`it is o1`</font>。这是因为<font color = \"rgb(226,238,250)\">`case let`</font>不是匹配值，而是值绑定，也就是把o的值赋给临时变量o1,这在o是可选类型时很有用，类似于<font color = \"rgb(226,238,250)\">`if let`</font>那样的隐式解析可选类型。没有打出<font color = \"rgb(226,238,250)\">`it is o2`</font>是因为swift中的switch，只匹配第一个相符的case，然后就结束了，即使不写<font color = \"rgb(226,238,250)\">`break`</font>也不会跳到后面的case。\n\n扯远了，回到话题上来，既然添加<font color = \"rgb(226,238,250)\">`let`</font>不行，我们得想别的办法。这时候不妨考虑一下<font color = \"rgb(226,238,250)\">`switch`</font>语句是怎么实现的。据我个人猜测，估计类似于用了好多个if判断有没有匹配的case，那既然如此，我们给类型A重载一下<font color = \"rgb(226,238,250)\">``==`</font>运算符试试：\n\n```swift\nclass A {}\n\nfunc == (lhs: A, rhs: A) -> Bool { return true }\n\nvar o = A(); var o1 = A() ;var o2 = A()\n\nswitch o {\ncase o1:\n    print(\"it is o1\")\ncase o2:\n    print(\"it is o2\")\ndefault:\n    print(\"not o1 or o2\")\n}\n```\n\n很显然，又失败了。如果这就能搞定问题，那这篇文章也太水了。报错信息和之前一样。可问题是我们已经重载了<font color = \"rgb(226,238,250)\">`==`</font>运算符，为什么A类型还是不能饿匹配A类型呢，难道switch不用判断两个变量是否相等么。\n\nswitch作为一个多条件匹配的语句，自然是要判断变量是否相等的，不过它不是通过<font color = \"rgb(226,238,250)\">`==`</font>运算符判断，而是通过<font color = \"rgb(226,238,250)\">`~=`</font>运算符。再来看一段[官方文档](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/doc/uid/TP40014097-CH36-ID419)的解释：\n\n> An expression pattern represents the value of an expression. Expression patterns appear only in switch statement case labels.\n\n以及这句话：\n\n> The expression represented by the expression pattern is compared with the value of an input expression using the Swift standard library ~= operator. \n\n第一句解释了之前的报错，所谓的“express pattern”是指表达式的值，这个概念只在switch的case标签中有。所以之前的报错信息是说：“o1这个表达式的值(还是o1)与传入的参数o都是类型A的，但它们无法匹配”。至于为什么不能匹配，答案在第二句话中，因为o1和o的匹配是通过调用标准库中的<font color = \"rgb(226,238,250)\">`~=`</font>运算符完成的。\n\n所以，只要把重载<font color = \"rgb(226,238,250)\">`==`</font>换成重载<font color = \"rgb(226,238,250)\">`~=`</font>就可以了。改动一个字符，别的都不用改，然后程序就可以运行了。Swift默认在<font color = \"rgb(226,238,250)\">`~=`</font>运算符中调用<font color = \"rgb(226,238,250)\">`==`</font>运算符，这也就是为什么我们感觉不到匹配整数类型需要什么额外处理。但对于自定义类型来说，不重载<font color = \"rgb(226,238,250)\">`~=`</font>运算符，就算你重载了<font color = \"rgb(226,238,250)\">`==`</font>也是没用的。\n\n除此以外，还有一种解决方法，那就是让A类型实现<font color = \"rgb(226,238,250)\">`Equatable`</font>协议。这样就不需要重载<font color = \"rgb(226,238,250)\">`~=`</font>运算符了。答案就在Swift的module的最后几行：\n\n```swift\n@warn_unused_result\npublic func ~=<T : Equatable>(a: T, b: T) -> Bool\n```\n\nSwift已经为所有实现了<font color = \"rgb(226,238,250)\">`Equatable `</font>协议的类重载了<font color = \"rgb(226,238,250)\">`~=`</font>运算符。虽然实现<font color = \"rgb(226,238,250)\">`Equatable `</font>协议只要求重载<font color = \"rgb(226,238,250)\">`==`</font>运算符，但如果你不显式的注明遵守了<font color = \"rgb(226,238,250)\">`Equatable `</font>协议，swift是无法知道的。因此，如果你重载了<font color = \"rgb(226,238,250)\">`==`</font>运算符，就顺手标注一下实现了<font color = \"rgb(226,238,250)\">`Equatable `</font>协议吧，这样还有很多好处，比如<font color = \"rgb(226,238,250)\">`SequenceType`</font>的<font color = \"rgb(226,238,250)\">`split`</font>方法等。\n\n最后总结一句：\n> 能放在switch语句中的类型必须重载<font color = \"rgb(226,238,250)\">`~=`</font>运算符，或者实现<font color = \"rgb(226,238,250)\">`Equatable`</font>协议。","html":"<p>今天突然想到一个问题，让我觉得有必要总结一下switch语句。我们知道swift中的switch，远比C语言只能比较整数强大得多，但问题来了，哪些类型可以放到switch中比较呢，对象可以比较么？</p>\n\n<!--more-->\n\n<p><a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120\">官方文档</a>对switch的用法给出了这样的解释：</p>\n\n<blockquote>\n  <p>Cases can match many different patterns, including interval matches, tuples, and casts to a specific type.</p>\n</blockquote>\n\n<p>也就是说除了最常用的比较整数、字符串等等之外，switch还可以用来匹配范围、元组，转化成某个特定类型等等。但文档里这个<strong>including</strong>用的实在是无语，因为它没有指明所有可以放在switch中比较的类型，文章开头提出的问题依然没有答案。</p>\n\n<p>我们不妨动手试一下，用switch匹配对象：</p>\n\n<pre><code class=\"language-swift\">class A {\n\n}\n\nvar o  = A()  \nvar o1 = A()  \nvar o2 = A()\n\nswitch o {  \ncase o1:  \n    print(\"it is o1\")\ncase o2:  \n    print(\"it is o2\")\ndefault:  \n    print(\"not o1 or o2\")\n}\n</code></pre>\n\n<p>果然，编译器报错了：“Expression pattern of type 'A' cannot match values of type 'A'”。至少我们目前还不明白“expression pattern”是什么，怎么类型A就不能匹配类型A了。</p>\n\n<p>我们做一下改动，在<font color = \"rgb(226,238,250)\"><code>case</code></font>语句后面加上<font color = \"rgb(226,238,250)\"><code>let</code></font>：</p>\n\n<pre><code class=\"language-swift\">switch o {  \ncase let o1:  \n    print(\"it is o1\")\ncase let o2:  \n    print(\"it is o2\")\ndefault:  \n    print(\"not o1 or o2\")\n}\n</code></pre>\n\n<p>OK，编译运行，结果是：<font color = \"rgb(226,238,250)\"><code>it is o1</code></font>。这是因为<font color = \"rgb(226,238,250)\"><code>case let</code></font>不是匹配值，而是值绑定，也就是把o的值赋给临时变量o1,这在o是可选类型时很有用，类似于<font color = \"rgb(226,238,250)\"><code>if let</code></font>那样的隐式解析可选类型。没有打出<font color = \"rgb(226,238,250)\"><code>it is o2</code></font>是因为swift中的switch，只匹配第一个相符的case，然后就结束了，即使不写<font color = \"rgb(226,238,250)\"><code>break</code></font>也不会跳到后面的case。</p>\n\n<p>扯远了，回到话题上来，既然添加<font color = \"rgb(226,238,250)\"><code>let</code></font>不行，我们得想别的办法。这时候不妨考虑一下<font color = \"rgb(226,238,250)\"><code>switch</code></font>语句是怎么实现的。据我个人猜测，估计类似于用了好多个if判断有没有匹配的case，那既然如此，我们给类型A重载一下<font color = \"rgb(226,238,250)\"><code>`==</code></font>运算符试试：</p>\n\n<p><pre><code class=\"language-swift\">switch o {  \ncase let o1:  \n    print(\"it is o1\")\ncase let o2:  \n    print(\"it is o2\")\ndefault:  \n    print(\"not o1 or o2\")\n}\n</code></pre></p>\n\n<p>很显然，又失败了。如果这就能搞定问题，那这篇文章也太水了。报错信息和之前一样。可问题是我们已经重载了<font color = \"rgb(226,238,250)\"><code>==</code></font>运算符，为什么A类型还是不能饿匹配A类型呢，难道switch不用判断两个变量是否相等么。</p>\n\n<p>switch作为一个多条件匹配的语句，自然是要判断变量是否相等的，不过它不是通过<font color = \"rgb(226,238,250)\"><code>==</code></font>运算符判断，而是通过<font color = \"rgb(226,238,250)\"><code>~=</code></font>运算符。再来看一段<a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/doc/uid/TP40014097-CH36-ID419\">官方文档</a>的解释：</p>\n\n<blockquote>\n  <p>An expression pattern represents the value of an expression. Expression patterns appear only in switch statement case labels.</p>\n</blockquote>\n\n<p>以及这句话：</p>\n\n<blockquote>\n  <p>The expression represented by the expression pattern is compared with the value of an input expression using the Swift standard library ~= operator. </p>\n</blockquote>\n\n<p>第一句解释了之前的报错，所谓的“express pattern”是指表达式的值，这个概念只在switch的case标签中有。所以之前的报错信息是说：“o1这个表达式的值(还是o1)与传入的参数o都是类型A的，但它们无法匹配”。至于为什么不能匹配，答案在第二句话中，因为o1和o的匹配是通过调用标准库中的<font color = \"rgb(226,238,250)\"><code>~=</code></font>运算符完成的。</p>\n\n<p>所以，只要把重载<font color = \"rgb(226,238,250)\"><code>==</code></font>换成重载<font color = \"rgb(226,238,250)\"><code>~=</code></font>就可以了。改动一个字符，别的都不用改，然后程序就可以运行了。Swift默认在<font color = \"rgb(226,238,250)\"><code>~=</code></font>运算符中调用<font color = \"rgb(226,238,250)\"><code>==</code></font>运算符，这也就是为什么我们感觉不到匹配整数类型需要什么额外处理。但对于自定义类型来说，不重载<font color = \"rgb(226,238,250)\"><code>~=</code></font>运算符，就算你重载了<font color = \"rgb(226,238,250)\"><code>==</code></font>也是没用的。</p>\n\n<p>除此以外，还有一种解决方法，那就是让A类型实现<font color = \"rgb(226,238,250)\"><code>Equatable</code></font>协议。这样就不需要重载<font color = \"rgb(226,238,250)\"><code>~=</code></font>运算符了。答案就在Swift的module的最后几行：</p>\n\n<p><code>it is o1</code></p>\n\n<p>Swift已经为所有实现了<font color = \"rgb(226,238,250)\"><code>Equatable</code></font>协议的类重载了<font color = \"rgb(226,238,250)\"><code>~=</code></font>运算符。虽然实现<font color = \"rgb(226,238,250)\"><code>Equatable</code></font>协议只要求重载<font color = \"rgb(226,238,250)\"><code>==</code></font>运算符，但如果你不显式的注明遵守了<font color = \"rgb(226,238,250)\"><code>Equatable</code></font>协议，swift是无法知道的。因此，如果你重载了<font color = \"rgb(226,238,250)\"><code>==</code></font>运算符，就顺手标注一下实现了<font color = \"rgb(226,238,250)\"><code>Equatable</code></font>协议吧，这样还有很多好处，比如<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>的<font color = \"rgb(226,238,250)\"><code>split</code></font>方法等。</p>\n\n<p>最后总结一句：</p>\n\n<blockquote>\n  <p>能放在switch语句中的类型必须重载<font color = \"rgb(226,238,250)\"><code>~=</code></font>运算符，或者实现<font color = \"rgb(226,238,250)\"><code>Equatable</code></font>协议。</p>\n</blockquote>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:07:37.000Z","created_by":1,"updated_at":"2016-01-28T16:32:36.000Z","updated_by":1,"published_at":"2015-12-17T08:07:00.000Z","published_by":1},{"id":9,"uuid":"3bec92a5-3cc5-47ae-8f3e-b61ccf633156","title":"史上最简单的UIScrollView+Autolayout出坑指南","slug":"uiscrollviewwithautolayout","markdown":"网上有很多使用Storyboard完成<font color = \"rgb(226,238,250)\">`UIScrollview`</font>的例子，但是纯代码的例子却不多。有限的一些例子大多也是外国开发者用VFL写的。而这篇文章基于swift语言和SnapKit分析了如何用纯代码加Autolayout写<font color = \"rgb(226,238,250)\">`UIScrollview`</font>，完整代码已经上传到我的[github](https://github.com/bestswifter/MySampleCode/tree/master/AutolayoutScrollViewInCode)。\n\n在正文中，我会分析其中的关键代码。对于Autolayout，**绝对不可取**的态度是不停的试几个约束，一旦发现好用，也不管其原理，就放手不管了。事实上，我们写的每一个约束，都要明白它存在的价值是什么，要做到不写一个无用的约束，不漏一个必要的约束，明白为什么某种写法有效，而另一种写法就无效。\n\n废话不多说，估计大家用<font color = \"rgb(226,238,250)\">`UIScrollview`</font>时，都有过被Autolayout坑的经历，要么是布局不对，要么不能滑动，以及其他匪夷所思的bug。这与Autolayout和<font color = \"rgb(226,238,250)\">`UIScrollview`</font>各自的特性有关。\n\n# 理论分析\n\n首先，我们知道Autolayout改变了传统的以frame为主的布局思想。它其实是一种相对布局，核心思想是视图与视图之间的位置关系。比如，我们可以根据矩形的起始横坐标、纵坐标、长和宽这四个变量确定它的位置。或者，如果已经确定矩形A的位置，只要知道矩形B每条边的和A对应边之间的距离，也能确定B的位置。前者就是frame的思想，它基于绝对数值，而后者是Autolayout的思想，它基于偏移量的概念。\n\n其次，<font color = \"rgb(226,238,250)\">`UIScrollview`</font>有自己的frame也就是我们在屏幕上能看到的区域。它还有一个<font color = \"rgb(226,238,250)\">`contentSize `</font>的概念。在使用frame布局的时候，我们一般先设置好子视图的位置，最后再设置<font color = \"rgb(226,238,250)\">`contentSize `</font>,它会将所有的子视图包含在内。于是通过滑动，我们就可以在有限的布局中，看到所有的内容了。\n\n但是在Autolayout时代，为了简化布局，我们希望<font color = \"rgb(226,238,250)\">`contentSize `</font>能够自动设置。比如有一个scrollView，它有两个子视图。frame分别为(x: 0, y: 0, width: 10, height: 10)和(x: 10, y: 0, width: 10, height: 10)，那么我们自然会认为这两个视图左右并排排列，<font color = \"rgb(226,238,250)\">`contentSize `</font>为(x: 0, y: 0, width: 20, height: 10)：\n\n![自动计算contentSize](http://7xonij.com1.z0.glb.clouddn.com/Autolayout+Scrollview/sample1.png)\n\n这种把若干个子视图合并，得出<font color = \"rgb(226,238,250)\">`contentSize `</font>的能力，人类是天生具备的，但是计算机却不是这样。仅凭以上信息，程序无法推断出真正的<font color = \"rgb(226,238,250)\">`contentSize `</font>。原因在于，我们没有明确的告诉系统，在这两个子视图拼接而成的区域以外，还有没有区域应该被<font color = \"rgb(226,238,250)\">`contentSize `</font>包含。\n\n也就是说，<font color = \"rgb(226,238,250)\">`contentSize `</font>也有可能是下图中的阴影部分：\n\n![更大的contentSize](http://7xonij.com1.z0.glb.clouddn.com/Autolayout+Scrollview/sample2.png)\n\n如果需要指定<font color = \"rgb(226,238,250)\">`contentSize `</font>就是两个正方形拼接而成的区域，我们还需要提供四个信息：\n\n1. 左边的正方形的左侧的边，距离contentSize左边的距离为0\n2. 右边的正方形的右侧的边，距离contentSize右边的距离为0\n\n……\n\n通过以上的分析，我们可以看到，其实<font color = \"rgb(226,238,250)\">`contentSize `</font>是依赖于子视图自身的大小，和上下左右四个方向的留白大小计算出的。而<font color = \"rgb(226,238,250)\">`UIScrollview`</font>的leading/trailing/top/bottom是相对于它的<font color = \"rgb(226,238,250)\">`contentSize `</font>而不是`bounds`来确定的。所以如果你写这样的代码，布局是肯定不会生效的：\n\n```swift\nsubview.snp_makeConstraints { (make) -> Void in\n    make.edges.equalTo(scrollView).offset(5)\n}\n```\n\n因为我们其实是在根据<font color = \"rgb(226,238,250)\">`UIScrollview`</font>的leading/trailing/top/bottom来确定子视图的位置，而我们已经分析过，<font color = \"rgb(226,238,250)\">`UIScrollview`</font>的leading/trailing/top/bottom是相对于自己的<font color = \"rgb(226,238,250)\">`contentSize `</font>而言的。而<font color = \"rgb(226,238,250)\">`contentSize `</font>又是根据子视图位置决定的。这就变成了一种你依赖我，我又依赖你的情况。\n\n为了打破这种循环依赖，为子视图添加约束的**两个要求**是：\n\n1. 它不依赖于任何与<font color = \"rgb(226,238,250)\">scrollview</font>有关布局，也就是不能参考<font color = \"rgb(226,238,250)\">scrollview</font>的位置和大小。\n2. 它不仅要确定过自己的大小，还要确定自己与<font color = \"rgb(226,238,250)\">`contentSize `</font>四周的距离。\n\n\n第二个要求意思是说，正常使用autolayout时，我们确定一个矩形在水平方向上的范围，只要知道它的左边距离它左边的矩形有多远，以及它有多宽即可。但是在<font color = \"rgb(226,238,250)\">`UIScrollView `中布局时，还需要告诉`UIScrollView `</font>，它的右边距离右边的视图有多远。这样<font color = \"rgb(226,238,250)\">`contentSize `</font>才能确定。否则<font color = \"rgb(226,238,250)\">`UIScrollView `</font>就不知道<font color = \"rgb(226,238,250)\">`contentSize `</font>向右可以延伸多少。在竖直方向上也是同理。\n\n**这两大要求一定要牢记！**接下来我们的代码都将围绕如何满足这两大要求展开。\n\n# 动手实践\n\n明白了问题的理论背景后，我们通过一个具体的需求，来看看正确的代码怎么写，以下面这个效果为例：\n\n![任务目标](http://7xonij.com1.z0.glb.clouddn.com/Autolayout+Scrollview/1.pic.png)\n\n如图所示，中间是一个<font color = \"rgb(226,238,250)\">`UIScrollview`</font>,它的背景颜色是黄色。红色部分我们称之为`box`，它是一个普通的，红色背景的`UIView`。也就是说我们向<font color = \"rgb(226,238,250)\">`UIScrollview`</font>中添加了多个`box`，每个子`box`之间间隔一定距离。我们分步实现这个功能\n\n## 使用container\n\n首先我们介绍一种使用Container的方法。\n\n###第一步：为scrollView添加约束\n\n\n```swift\nlet scrollView = UIScrollView()\nview.addSubview(scrollView)\nscrollView.snp_makeConstraints { (make) -> Void in\n    make.centerY.equalTo(view.snp_centerY)\n    make.left.right.equalTo(view)\n    make.height.equalTo(topScrollHeight)\n}\n```\n\n我们之前说过，使用Autolayout时，不用考虑frame布局。所以直接创建一个<font color = \"rgb(226,238,250)\">`scrollview `</font>对象。需要先把<font color = \"rgb(226,238,250)\">`scrollview `</font>添加到父视图上才能添加约束。\n\n对<font color = \"rgb(226,238,250)\">`scrollview `</font>添加约束没有什么难点，就像我们给其他视图添加约束一样。这里表示`scrollView`和父视图左右对齐，居中显示。\n\n###第二步：为container添加约束\n\n```swift\nscrollView.addSubview(containerView)\ncontainerView.snp_makeConstraints { (make) -> Void in\n    make.edges.equalTo(scrollView)\n    make.height.equalTo(topScrollHeight)\n}\n```\n\n这里对<font color = \"rgb(226,238,250)\">`container `</font>的约束非常重要，第一个约束表示自己上、下、左、右和<font color = \"rgb(226,238,250)\">`contentSize `</font>的距离为0，因此只要<font color = \"rgb(226,238,250)\">`container `</font>的大小确定，<font color = \"rgb(226,238,250)\">`contentSize `</font>也就可以确定了，因为此时它和<font color = \"rgb(226,238,250)\">`container `</font>大小、位置完全相同。\n\n第二个约束直接通过一个数值，确定<font color = \"rgb(226,238,250)\">`container `</font>的高度。避免了依赖<font color = \"rgb(226,238,250)\">`scrollview `</font>布局。这样一来，<font color = \"rgb(226,238,250)\">`scrollview `</font>就变成水平的了。<font color = \"rgb(226,238,250)\">`container `</font>的宽度直接决定了<font color = \"rgb(226,238,250)\">`scrollview `</font>的宽度。\n\n### 第三步：添加box\n\n```swift\nfor i in 0...5 {\n    let box = UIView()\n    containerView.addSubview(box)\n    \n    box.snp_makeConstraints(closure: { (make) -> Void in\n        make.top.height.equalTo(containerView)  // 确定top和height之后，box在竖直方向上完全确定\n        make.width.equalTo(boxWidth)\t\t//确定width后，只要再确定left，就可以在水平方向上完全确定\n        if i == 0 {\n            make.left.equalTo(containerView).offset(boxGap / 2)  //第一个box的left单独处理\n        }\n        else if let previousBox = containerView.subviews[i - 1] as? UIView{\n            make.left.equalTo(previousBox.snp_right).offset(boxGap)  // 在前一个box右侧15个距离\n        }\n        if i == 5 {\n            containerView.snp_makeConstraints(closure: { (make) -> Void in\n                make.right.equalTo(box)  // 确定container的右侧边界。\n            })\n        }\n    })\n}\n```\n\n对`box`的约束看似复杂，其实非常简单。因为<font color = \"rgb(226,238,250)\">`scrollview `</font>在Autolayout下的布局，难点就在于子视图布局时约束比较多。但现在，我们通过一个<font color = \"rgb(226,238,250)\">`container `</font>已经隔离了，也就说我们又回归了常规的Autolayout布局。以水平方向为例，我们只要确定`left`和`width`即可。\n\n在最后一个`if`语句中，我们为<font color = \"rgb(226,238,250)\">`container `</font>添加了右侧的约束。这样就确定了<font color = \"rgb(226,238,250)\">`container `</font>的宽度。由于<font color = \"rgb(226,238,250)\">`container `</font>封装了所有的`box`，所以对于<font color = \"rgb(226,238,250)\">`scrollview `</font>来说，它的子视图只有一个，就是<font color = \"rgb(226,238,250)\">`container `</font>，而<font color = \"rgb(226,238,250)\">`container `</font>自身的大小，上下左右四个方向和<font color = \"rgb(226,238,250)\">`contentSize `</font>距离在之前的约束中已经被定义为0，<font color = \"rgb(226,238,250)\">`contentSize `</font>也就可以确定了。\n\n##使用外部视图\n\n除了使用<font color = \"rgb(226,238,250)\">`container `</font>以外，我们还可以使用外部的视图确定子视图的位置。这种方法，步骤较少，和之前一样，第一步是创建`scrollView`并添加约束。接下来我们直接添加子视图：\n\n```swift\nbox.snp_makeConstraints(closure: { (make) -> Void in\n    make.top.equalTo(0)\n    make.bottom.equalTo(view).offset(-(ScreenHeight - topScrollHeight) / 2)  // This bottom can be incorret when device is rotated\n    make.height.equalTo(topScrollHeight)\n    \n    make.width.equalTo(boxWidth)\n    if i == 0 {\n        make.left.equalTo(boxGap / 2)\n    }\n    else if let previousBox = scrollView.subviews[i - 1] as? UIView{\n        make.left.equalTo(previousBox.snp_right).offset(boxGap)\n    }\n    \n    if i == 5 {\n        make.right.equalTo(scrollView)\n    }\n})\n```\n\n这时候，`box`是直接add到`scrollView`上的。我们直接指定它的`top`为0。前三个约束分别指定了`box`的顶部、底部和高度。这样就在竖直方向上满足了两大要求中的第二个要求。对于`bottom`的约束，它的参考物是`view`，这就是所谓的外部视图。\n\n接下来我们分别为`width`和`left`添加了约束。而且只要对最后一个`box`添加`right`约束即可在水平方向上满足第二个要求。由于我们的布局依赖于外部的视图，所以自然满足第一个要求，因此这种写法也是可以的。\n\n\n## Container与外部视图的优缺点\n\n与<font color = \"rgb(226,238,250)\">`container `</font>相比，使用外部视图出了代码量可能略少以外，我实在想不到它还有什么优点。\n\n首先，一旦我们使用了<font color = \"rgb(226,238,250)\">`container `</font>，首先它天然满足第一个要求，因为它并没有进行布局，只是让<font color = \"rgb(226,238,250)\">`contentSize `</font>与自己等大，然后设置自己的大小。而且它几乎已经满足了第二个要求。只要我们最后确定它的宽度或高度即可。其次，在<font color = \"rgb(226,238,250)\">`container `</font>内部，子视图布局不用考虑满足第二个要求，因为<font color = \"rgb(226,238,250)\">`container `</font>已经隔离了这一切，我们要做的只是按照习惯，确定子视图的位置，这样<font color = \"rgb(226,238,250)\">`container `</font>的位置也会随着子视图确定。\n\n其次，我发现的使用外部视图布局的缺点就至少有三个：\n\n1. 它依赖外部视图进行定位，这样的写法不够优雅\n2. 观察代码中对于bottom属性的约束，它不能完美适配旋转屏幕后的视图。因为此时的屏幕长和宽会对调。而且目测没有什么好的解决方案。\n3. 布局过程中容易踩到坑，比如对于`left`属性的约束，如果你的代码是这样的：\n\n```swift\nmake.left.equalTo(view).offset(boxGap / 2)\n```\n\n它和原来的写法几乎是等价的。但你仔细分析，或者试着滑动`scrollView`时，一定会大吃一惊。如果你不能一眼看出来这种写法的问题所在，那我建议你运行代码体验一下，并且以后尽量避免这种写法。\n\n#### 最后重复一下，代码地址在[https://github.com/bestswifter/MySampleCode/tree/master/AutolayoutScrollViewInCode](https://github.com/bestswifter/MySampleCode/tree/master/AutolayoutScrollViewInCode)，可以下载下来把玩研究一番，如果觉得对你有帮助，请给一个star。","html":"<p>网上有很多使用Storyboard完成<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>的例子，但是纯代码的例子却不多。有限的一些例子大多也是外国开发者用VFL写的。而这篇文章基于swift语言和SnapKit分析了如何用纯代码加Autolayout写<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>，完整代码已经上传到我的<a href=\"https://github.com/bestswifter/MySampleCode/tree/master/AutolayoutScrollViewInCode\">github</a>。</p>\n\n<p>在正文中，我会分析其中的关键代码。对于Autolayout，<strong>绝对不可取</strong>的态度是不停的试几个约束，一旦发现好用，也不管其原理，就放手不管了。事实上，我们写的每一个约束，都要明白它存在的价值是什么，要做到不写一个无用的约束，不漏一个必要的约束，明白为什么某种写法有效，而另一种写法就无效。</p>\n\n<p>废话不多说，估计大家用<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>时，都有过被Autolayout坑的经历，要么是布局不对，要么不能滑动，以及其他匪夷所思的bug。这与Autolayout和<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>各自的特性有关。</p>\n\n<h1 id=\"\">理论分析</h1>\n\n<p>首先，我们知道Autolayout改变了传统的以frame为主的布局思想。它其实是一种相对布局，核心思想是视图与视图之间的位置关系。比如，我们可以根据矩形的起始横坐标、纵坐标、长和宽这四个变量确定它的位置。或者，如果已经确定矩形A的位置，只要知道矩形B每条边的和A对应边之间的距离，也能确定B的位置。前者就是frame的思想，它基于绝对数值，而后者是Autolayout的思想，它基于偏移量的概念。</p>\n\n<p>其次，<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>有自己的frame也就是我们在屏幕上能看到的区域。它还有一个<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>的概念。在使用frame布局的时候，我们一般先设置好子视图的位置，最后再设置<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>,它会将所有的子视图包含在内。于是通过滑动，我们就可以在有限的布局中，看到所有的内容了。</p>\n\n<p>但是在Autolayout时代，为了简化布局，我们希望<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>能够自动设置。比如有一个scrollView，它有两个子视图。frame分别为(x: 0, y: 0, width: 10, height: 10)和(x: 10, y: 0, width: 10, height: 10)，那么我们自然会认为这两个视图左右并排排列，<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>为(x: 0, y: 0, width: 20, height: 10)：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Autolayout+Scrollview/sample1.png\" alt=\"自动计算contentSize\" /></p>\n\n<p>这种把若干个子视图合并，得出<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>的能力，人类是天生具备的，但是计算机却不是这样。仅凭以上信息，程序无法推断出真正的<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>。原因在于，我们没有明确的告诉系统，在这两个子视图拼接而成的区域以外，还有没有区域应该被<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>包含。</p>\n\n<p>也就是说，<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>也有可能是下图中的阴影部分：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Autolayout+Scrollview/sample2.png\" alt=\"更大的contentSize\" /></p>\n\n<p>如果需要指定<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>就是两个正方形拼接而成的区域，我们还需要提供四个信息：</p>\n\n<ol>\n<li>左边的正方形的左侧的边，距离contentSize左边的距离为0  </li>\n<li>右边的正方形的右侧的边，距离contentSize右边的距离为0</li>\n</ol>\n\n<p>……</p>\n\n<p>通过以上的分析，我们可以看到，其实<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>是依赖于子视图自身的大小，和上下左右四个方向的留白大小计算出的。而<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>的leading/trailing/top/bottom是相对于它的<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>而不是<code>bounds</code>来确定的。所以如果你写这样的代码，布局是肯定不会生效的：</p>\n\n<pre><code class=\"language-swift\">subview.snp_makeConstraints { (make) -&gt; Void in  \n    make.edges.equalTo(scrollView).offset(5)\n}\n</code></pre>\n\n<p>因为我们其实是在根据<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>的leading/trailing/top/bottom来确定子视图的位置，而我们已经分析过，<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>的leading/trailing/top/bottom是相对于自己的<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>而言的。而<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>又是根据子视图位置决定的。这就变成了一种你依赖我，我又依赖你的情况。</p>\n\n<p>为了打破这种循环依赖，为子视图添加约束的<strong>两个要求</strong>是：</p>\n\n<ol>\n<li>它不依赖于任何与<font color = \"rgb(226,238,250)\">scrollview</font>有关布局，也就是不能参考<font color = \"rgb(226,238,250)\">scrollview</font>的位置和大小。  </li>\n<li>它不仅要确定过自己的大小，还要确定自己与<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>四周的距离。</li>\n</ol>\n\n<p>第二个要求意思是说，正常使用autolayout时，我们确定一个矩形在水平方向上的范围，只要知道它的左边距离它左边的矩形有多远，以及它有多宽即可。但是在<font color = \"rgb(226,238,250)\"><code>UIScrollView</code>中布局时，还需要告诉<code>UIScrollView</code></font>，它的右边距离右边的视图有多远。这样<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>才能确定。否则<font color = \"rgb(226,238,250)\"><code>UIScrollView</code></font>就不知道<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>向右可以延伸多少。在竖直方向上也是同理。</p>\n\n<p><strong>这两大要求一定要牢记！</strong>接下来我们的代码都将围绕如何满足这两大要求展开。</p>\n\n<h1 id=\"\">动手实践</h1>\n\n<p>明白了问题的理论背景后，我们通过一个具体的需求，来看看正确的代码怎么写，以下面这个效果为例：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Autolayout+Scrollview/1.pic.png\" alt=\"任务目标\" /></p>\n\n<p>如图所示，中间是一个<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>,它的背景颜色是黄色。红色部分我们称之为<code>box</code>，它是一个普通的，红色背景的<code>UIView</code>。也就是说我们向<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>中添加了多个<code>box</code>，每个子<code>box</code>之间间隔一定距离。我们分步实现这个功能</p>\n\n<h2 id=\"container\">使用container</h2>\n\n<p>首先我们介绍一种使用Container的方法。</p>\n\n<h3 id=\"scrollview\">第一步：为scrollView添加约束</h3>\n\n<pre><code class=\"language-swift\">let scrollView = UIScrollView()  \nview.addSubview(scrollView)  \nscrollView.snp_makeConstraints { (make) -&gt; Void in  \n    make.centerY.equalTo(view.snp_centerY)\n    make.left.right.equalTo(view)\n    make.height.equalTo(topScrollHeight)\n}\n</code></pre>\n\n<p>我们之前说过，使用Autolayout时，不用考虑frame布局。所以直接创建一个<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>对象。需要先把<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>添加到父视图上才能添加约束。</p>\n\n<p>对<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>添加约束没有什么难点，就像我们给其他视图添加约束一样。这里表示<code>scrollView</code>和父视图左右对齐，居中显示。</p>\n\n<h3 id=\"container\">第二步：为container添加约束</h3>\n\n<pre><code class=\"language-swift\">scrollView.addSubview(containerView)  \ncontainerView.snp_makeConstraints { (make) -&gt; Void in  \n    make.edges.equalTo(scrollView)\n    make.height.equalTo(topScrollHeight)\n}\n</code></pre>\n\n<p>这里对<font color = \"rgb(226,238,250)\"><code>container</code></font>的约束非常重要，第一个约束表示自己上、下、左、右和<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>的距离为0，因此只要<font color = \"rgb(226,238,250)\"><code>container</code></font>的大小确定，<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>也就可以确定了，因为此时它和<font color = \"rgb(226,238,250)\"><code>container</code></font>大小、位置完全相同。</p>\n\n<p>第二个约束直接通过一个数值，确定<font color = \"rgb(226,238,250)\"><code>container</code></font>的高度。避免了依赖<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>布局。这样一来，<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>就变成水平的了。<font color = \"rgb(226,238,250)\"><code>container</code></font>的宽度直接决定了<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>的宽度。</p>\n\n<h3 id=\"box\">第三步：添加box</h3>\n\n<pre><code class=\"language-swift\">for i in 0...5 {  \n    let box = UIView()\n    containerView.addSubview(box)\n\n    box.snp_makeConstraints(closure: { (make) -&gt; Void in\n        make.top.height.equalTo(containerView)  // 确定top和height之后，box在竖直方向上完全确定\n        make.width.equalTo(boxWidth)        //确定width后，只要再确定left，就可以在水平方向上完全确定\n        if i == 0 {\n            make.left.equalTo(containerView).offset(boxGap / 2)  //第一个box的left单独处理\n        }\n        else if let previousBox = containerView.subviews[i - 1] as? UIView{\n            make.left.equalTo(previousBox.snp_right).offset(boxGap)  // 在前一个box右侧15个距离\n        }\n        if i == 5 {\n            containerView.snp_makeConstraints(closure: { (make) -&gt; Void in\n                make.right.equalTo(box)  // 确定container的右侧边界。\n            })\n        }\n    })\n}\n</code></pre>\n\n<p>对<code>box</code>的约束看似复杂，其实非常简单。因为<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>在Autolayout下的布局，难点就在于子视图布局时约束比较多。但现在，我们通过一个<font color = \"rgb(226,238,250)\"><code>container</code></font>已经隔离了，也就说我们又回归了常规的Autolayout布局。以水平方向为例，我们只要确定<code>left</code>和<code>width</code>即可。</p>\n\n<p>在最后一个<code>if</code>语句中，我们为<font color = \"rgb(226,238,250)\"><code>container</code></font>添加了右侧的约束。这样就确定了<font color = \"rgb(226,238,250)\"><code>container</code></font>的宽度。由于<font color = \"rgb(226,238,250)\"><code>container</code></font>封装了所有的<code>box</code>，所以对于<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>来说，它的子视图只有一个，就是<font color = \"rgb(226,238,250)\"><code>container</code></font>，而<font color = \"rgb(226,238,250)\"><code>container</code></font>自身的大小，上下左右四个方向和<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>距离在之前的约束中已经被定义为0，<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>也就可以确定了。</p>\n\n<h2 id=\"\">使用外部视图</h2>\n\n<p>除了使用<font color = \"rgb(226,238,250)\"><code>container</code></font>以外，我们还可以使用外部的视图确定子视图的位置。这种方法，步骤较少，和之前一样，第一步是创建<code>scrollView</code>并添加约束。接下来我们直接添加子视图：</p>\n\n<pre><code class=\"language-swift\">box.snp_makeConstraints(closure: { (make) -&gt; Void in  \n    make.top.equalTo(0)\n    make.bottom.equalTo(view).offset(-(ScreenHeight - topScrollHeight) / 2)  // This bottom can be incorret when device is rotated\n    make.height.equalTo(topScrollHeight)\n\n    make.width.equalTo(boxWidth)\n    if i == 0 {\n        make.left.equalTo(boxGap / 2)\n    }\n    else if let previousBox = scrollView.subviews[i - 1] as? UIView{\n        make.left.equalTo(previousBox.snp_right).offset(boxGap)\n    }\n\n    if i == 5 {\n        make.right.equalTo(scrollView)\n    }\n})\n</code></pre>\n\n<p>这时候，<code>box</code>是直接add到<code>scrollView</code>上的。我们直接指定它的<code>top</code>为0。前三个约束分别指定了<code>box</code>的顶部、底部和高度。这样就在竖直方向上满足了两大要求中的第二个要求。对于<code>bottom</code>的约束，它的参考物是<code>view</code>，这就是所谓的外部视图。</p>\n\n<p>接下来我们分别为<code>width</code>和<code>left</code>添加了约束。而且只要对最后一个<code>box</code>添加<code>right</code>约束即可在水平方向上满足第二个要求。由于我们的布局依赖于外部的视图，所以自然满足第一个要求，因此这种写法也是可以的。</p>\n\n<h2 id=\"container\">Container与外部视图的优缺点</h2>\n\n<p>与<font color = \"rgb(226,238,250)\"><code>container</code></font>相比，使用外部视图出了代码量可能略少以外，我实在想不到它还有什么优点。</p>\n\n<p>首先，一旦我们使用了<font color = \"rgb(226,238,250)\"><code>container</code></font>，首先它天然满足第一个要求，因为它并没有进行布局，只是让<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>与自己等大，然后设置自己的大小。而且它几乎已经满足了第二个要求。只要我们最后确定它的宽度或高度即可。其次，在<font color = \"rgb(226,238,250)\"><code>container</code></font>内部，子视图布局不用考虑满足第二个要求，因为<font color = \"rgb(226,238,250)\"><code>container</code></font>已经隔离了这一切，我们要做的只是按照习惯，确定子视图的位置，这样<font color = \"rgb(226,238,250)\"><code>container</code></font>的位置也会随着子视图确定。</p>\n\n<p>其次，我发现的使用外部视图布局的缺点就至少有三个：</p>\n\n<ol>\n<li>它依赖外部视图进行定位，这样的写法不够优雅  </li>\n<li>观察代码中对于bottom属性的约束，它不能完美适配旋转屏幕后的视图。因为此时的屏幕长和宽会对调。而且目测没有什么好的解决方案。  </li>\n<li>布局过程中容易踩到坑，比如对于<code>left</code>属性的约束，如果你的代码是这样的：</li>\n</ol>\n\n<pre><code class=\"language-swift\">make.left.equalTo(view).offset(boxGap / 2)  \n</code></pre>\n\n<p>它和原来的写法几乎是等价的。但你仔细分析，或者试着滑动<code>scrollView</code>时，一定会大吃一惊。如果你不能一眼看出来这种写法的问题所在，那我建议你运行代码体验一下，并且以后尽量避免这种写法。</p>\n\n<h4 id=\"httpsgithubcombestswiftermysamplecodetreemasterautolayoutscrollviewincodehttpsgithubcombestswiftermysamplecodetreemasterautolayoutscrollviewincodestar\">最后重复一下，代码地址在<a href=\"https://github.com/bestswifter/MySampleCode/tree/master/AutolayoutScrollViewInCode\">https://github.com/bestswifter/MySampleCode/tree/master/AutolayoutScrollViewInCode</a>，可以下载下来把玩研究一番，如果觉得对你有帮助，请给一个star。</h4>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:09:08.000Z","created_by":1,"updated_at":"2016-01-28T16:32:26.000Z","updated_by":1,"published_at":"2015-12-21T08:09:00.000Z","published_by":1},{"id":10,"uuid":"c22d5ff7-6e0d-4d24-bde8-cda39818c09f","title":"程序员的自我修养读书笔记","slug":"cheng-xu-yuan-de-zi-wo-xiu-yang-du-shu-bi-ji","markdown":"最初买《程序员的自我修养》这本书，只因为在京东买书差一些钱，不够用优惠券。买回来以后的很长一段时间，我都以为这本书只是程序员用来调侃和自黑的。不过翻读了第一章以后，我就发现自己错的太离谱。我觉得即使一个不使用C/C++，甚至是写解释性语言(如JS等)的程序员，也有必要抽空读一读这本书。作为使用OC或Swift的iOS开发者，我认为这本书是必读的。\n\n所以这篇文章会简单梳理一下《程序员的自我修养》这本书的脉络结构，如果时间有限，又想快速阅读这本书，可以先看看这篇文章。标注了页号的地方表示详细知识可以在给出的页数获取详细的知识。为了简化问题，有些地方会省略一些原文中的细节，一切为了保证读者快速了解这本书。\n\n对于不是专门从事C和底层开发的程序猿来说，个人认为完整的看完本书的所有内容是不太现实，也不太必要的。这本书中有两大部分的知识点对于新手来说非常有必要了解：\n\n1. 一段源代码是怎么变成最后可执行的程序的\n2. 一个进程，在内存中是什么样的\n\n带着这两个问题去读书，收获会更大。在阅读原书之前，这里有几个相关内容的总结，我尽可能用简单的语言介绍某些知识背景。即使不能完全看懂，也有利于读书时的理解。\n\n<!--more-->\n\n## 从源码到程序\n\n程序最初的存在形式是源代码，也就是若干个`.c`文件。它要想变成一个可执行的程序，需要以下几个步骤：\n\n1. 预编译(P39)：负责这一步工作的叫“预编译器”。它主要负责处理所有的`#define`宏定义；所有的预编译指令，比如`#if`、`#endif`等。接下来会递归处理`#include`指令，用被包含的文件替换这个预编译指令。`.c`文件经过预编译，变为`.i`文件。\n2. 编译(P42)：这一步由编译器负责，主要又由词法分析、语法分析、语义分析、优化和生成汇编代码五个部分：\n\n\t* 词法分析：识别源代码中的各种括号、数字、标点等。比如有`(`但没有`)`，这一步就能发现错误\n\t* 语法分析：这一步会生成语法树，比如`2+4`就是一颗根节点为`+`，左右叶子节点分别为`2`和`4`的语法树。如果你只是写`2+`，在这一步就会报错。\n\t* 语义分析：这一步主要考虑类型声明、匹配和转换。比如你写`2 * \"3\"`在这一步就会报错\n\t* 中间语言生成：这一步会生成平台无关的三地址码，比如`2 + 3`会写成`t1 = 2 + 3`，同时也会把这样在编译期就可以确定的表达式进行优化\n\t* 目标代码生成：编译器根据三地址码生成依赖于目标机器的目标机器代码，也就是汇编语言。\n\n\t`.i`文件经过编译，得到汇编文件，后缀是`.s`\n\t\n3. 汇编(P40)：这一步由汇编器负责，将汇编语言转换成机器可以执行的语言(完全由0和1组成).汇编文件经过汇编，变成目标文件，后缀为`.o`。\n4. 链接(P41)：这一步是这本书的重点。之前的几个步骤，都是以`.c`文件为基本单位，一个`.c`源代码文件最终被汇编，生成目标文件。这一步就是处理如何把多个目标文件链接起来。\n\t\n\t考虑一个`.c`文件中，用到了另一个`.c`文件中的变量或函数。在编译这个文件时，我们无法在编译期确定这个变量或函数的地址。只有在把所有目标文件链接起来以后，才能确定。链接器主要负责地址重分配、符号名称绑定和重定位。\n\t\n从源代码到程序的运行要做的远远不止编译，很多时候我们说“把程序编译一下”，是不准确的。不过编译确实是整个流程中最复杂的部分。\n\n## 软件调用层次\n\n我们把整个计算机调用结构分为四层：\n\n1. 最上层是应用层。不管是浏览器、游戏，还是我们使用的各种开发工具，如Xcode，VS，汇编器自身等，都属于这一范畴。\n2. 第二层是操作系统的运行库。我们在程序里调用系统API，比如文件读写，就是调用了第二层提供的相应服务。这种调用通过操作系统的API完成，它沟通了应用层和操作系统的运行库。这也就是为什么不管是在Mac还是Windows上编程，我们都可以调用`printf()`或`fread()`等函数。因为不同的操作系统的运行库提供了不同底层的实现，但对应用层提供的API总是一样的。\n3. 第三层是操作系统内核。操作系统的运行库通过系统调用(System Call)调用系统内核提供的函数。比如`fread`属于API，它在Linux下会调用`read()`这个系统调用，而在Windows下会调用`ReadFile()`这个系统调用。应用程序可以直接调用系统调用，但是这样一来，我们需要考虑各个操作系统下系统调用的不同，而且系统调用由于更加底层，实现起来也就更加困难。最关键的是，系统调用是通过中断来完成的，涉及到堆栈的保存与恢复，频繁的系统调用会影响性能。\n4. 第四层是硬件层。程序无法直接访问这一层，只有操作系统的内核，通过硬件厂商提供的接口才能访问。\n\n这四层之间的关系如下图所示：\n\n![层次关系](http://7xonij.com1.z0.glb.clouddn.com/自我修养/hierarchy.png)\n\n## 虚拟地址空间\n\n在程序运行的过程中，最重要的概念就是虚拟地址空间。所谓的虚拟地址空间，是指应用程序自己认为，自己所处的地址空间。它区别于物理地址空间。后者是真实存在的，比如电脑有一根8G的内存条，物理地址空间就是0~8Gb。CPU的MMU负责把虚拟地址转换成物理地址。\n\n引入虚拟地址的第一个好处是，程序员不再关心真实的物理内存空间是什么样的，理论上来说，程序员有几乎无限大的虚拟内存空间可用，最后只要建立虚拟地址和物理地址的对应关系即可。另一方面，操作系统屏蔽了物理内存空间的细节，进程无法访问到操作系统禁止访问的物理地址，也不能访问到别的进程的地址空间，这大大增强了程序安全性。\n\n由虚拟地址空间引申出来的分页(Paging)技术，大大提高了内存的使用效率。要想运行一个程序，不再需要把整个程序都放入内存中执行，我们只要保证将要执行的页在内存中即可，如果不存在则导致页错误。\n\n关于地址空间的理解非常重要，书中有很多关于内存、和地址的描述，需要我们自己分析这是虚拟地址还是物理地址。如果分析错了，理解问题会比较麻烦。\n\n## 链接与重定位\n\n我们把`foo`函数定义在另一个文件中，然后在`main.c`中调用这个函数，单独编译`main.c`后代码如下：\n\n```c\n……\n0000000000000024\tcallq\t0x29\n0000000000000029\txorl\t%ecx, %ecx\n……\n```\n\n可以看到，本该调用`foo`函数的地方，我们直接调用了下一条命令，但是当`main.o`和`foo.o`链接起来后，就变成了：\n\n```c\n0000000100000f30\tpushq\t%rbp\n0000000100000f31\tmovq\t%rsp, %rbp\n0000000100000f34\tmovl\t$0x7b, %eax\n0000000100000f39\tmovl\t%edi, -0x4(%rbp)\n0000000100000f3c\tmovl\t%esi, -0x8(%rbp)\n0000000100000f3f\tpopq\t%rbp\n//以上为foo函数实现\n……\n0000000100000f74\tcallq\t0x100000f30\n0000000100000f79\txorl\t%ecx, %ecx\n……\n```\n\n这时候`foo`函数的位置就正确设置了。原因在于在`main.c`这个编译模块单独编译时，编译器无法确定`foo`的位置，只好临时用下一条指令的位置代替一下。\n\n链接器在链接过程中，就是要对这样的符号进行重定位。在重定位时，`main.o`中有`foo`函数经过修饰的符号名，同样的符号名在`foo.o`中也有，于是两者一拍即合，就这样被链接器连在了一起。`0x29`这个临时的调用地址被更新成了`0x100000f30 `。这个过程类似于拼图游戏，程序在链接时就是处理各种各样类似的问题，当所有编译模块都按照符号名完整的链接起来时，程序也就可以开始运行了。\n\n书中花了不少篇幅介绍目标文件的组成结构，其中很多都是为了重定位而准备的。一旦明白了重定位的原理和过程，在阅读相关内容时就会轻松很多。\n\n\n## 知识概要\n\n最后列出一部分知识点的简要概括和他们在书中的位置，方便读者参考：\n\n###静态链接部分\n\n这一部分主要是讨论多个`.c`文件怎么通过静态链接，得到一个静态库。\n\n* P58\n\n\t目标文件中分为若干个段，比如.text段存放代码，.data段存放存放已初始化的全局变量和局部静态变量，.bss段存放未初始化的全局变量和局部静态变量，除此以外目标文件还有很多其他的段。\n\t\n* P70\n\n\tLinux下的目标文件还有一个ELF文件头，用于汇总这个目标文件的各种信息,其中包括了ELF魔数、机器字节长度、数据存储方式、版本、运行平台、ABI版本，重定位类型、硬件平台及版本、入口地址、段表位置、段的数量等。\n\t\n* P74\n\t\n\t段表其实是一个数组，其中每一个元素都是结构体。结构体里面有段的名称、类型、加载地址、相对于文件头的偏移量，段的大小，链接信息等。\n\t\n* P79\n\n\t目标文件中还有一个重定位表。需要重定位的信息都记录在这个表里面。.text段中所有需要重定位的信息，都放在.rel.text段中。\n\t\n* P81\n\t\n\t在链接时，我们把函数名和变量都称为符号。每一个函数、变量都有自己独特的符号名，这样在链接时才能把它们对应起来。不同的语言有自己的符号修饰规则。UNIX下的C，编译出来的符号名前面加“\\_”，如函数foo在编译之后的结果为_foo。\n\t\n* P86\n\t\n\tC++的namespace就是用来避免符号名冲突。C++有一套自己的符号名修饰规则，可以通过c++filt命令还原被修饰过的符号名(demangle)。一旦了解了符号名的修饰规则，在写iOS时遇到`undefined symbol`或`duplicate symbol name`的报错，就非常好检查了。\n\t\n* P92\n\n\t符号分为强符号，和弱符号。强符号不可名称重复，弱符号（未初始化的全局变量）可以有符号名相同。对符号名的引用分为强引用和弱引用，强引用表示如果找不到符号定义会报错，弱引用不报错，默认为0或某个特殊值。\n\t\n* P99\n\n\t链接过程一般分为两步，首先地址分配，然后符号解析并重定位。\n\t\n\t由于不同的目标文件，可能含有相同的段，所以在链接过程中，我们可以合并相似段，这就是地址分配。\n\t\n\t合并完成后，所有符号的位置都可以唯一确定，此时可以就开始重定位工作了。链接完成后，我们就得到了静态库。\n\t\n* P118\n\t\n\t静态库可以看做一组目标文件的集合，同一个静态库中的不同目标文件可能相互依赖，不同的静态库也可以相互依赖。\n\t\n* P127\n\t\n\t链接控制脚本控制链接器的运行，将目标文件和库文件转化为可执行文件。链接控制脚本由链接脚本语言写成。可以认为的控制程序入口，某几个段合并，某几个段舍弃等\n\t\n### 动态装载\n\n这一部分主要是讨论经过链接后，可执行文件如何装载到内存中\n\n* P153\n\n\t有两种典型的动态装载方法：覆盖装入和页映射。覆盖装入允许互不依赖的两个模块共同享有同一块内存，在使用中互相替换。速度较慢，用时间换空间。我们常用的方案是页映射，把程序虚拟的内存空间分成多个页，由专门的页装载管理器负责管理虚拟页和物理内存中页的对应关系。\n\t\n* P157\n\n\t创建进程三步骤：首先进程自己的创建物理空间。设置好虚拟空间中各个页到物理空间里的页的映射关系（这一步可能在页错误之后发生）、然后建立虚拟空间与可执行文件的映射关系。Linux下，目标文件的每个段都有自己在虚拟内存中的位置，这叫虚拟内存区域（VMA, Virtual Memory Area），表示它装载在虚拟内存中的地址，最后指令寄存器设置为可执行文件入口。\n\t\n* P159\n\n\t进程创建后，只有物理页与虚拟页的对应关系，但是真正的指令和数据还没有放入物理页中，物理页的内存处于未分配状态。一旦访问到这个物理页，就会发生页错误。\n\t\n\t发生页错误时，操作系统立刻根据物理内存的页与虚拟内存的页的对应关系，找到这个页对应的虚拟内存，然后再查询每个段的VMA，就可以找这个页面在可执行文件中的偏移量。这时候操作系统先为物理页分配内存空间，然后把可执行文件中的数据和指令写入物理页，最后建立物理页和虚拟页联系即可。然后进程从发生页错误的地方重新执行。\n\t\n* P169\n\n\t可执行文件有很多Section，它们的大小各不相同，但有些小于页的大小，导致了空间浪费（不能连续存储不同的section是因为可能会有两个权限不同的section在同一个页中）。由于操作系统不关心每个Section的具体作用，但是关心它们的读写权限（是否可读、可写、可执行），所以往往把具有权限的Section合并成一个Segment\n\t\n* P172：\n\n\t进程运行后，操作系统会初始化进程的堆栈，其中存放了环境变量和命令行参数。这些参数被传给main函数（argc和argv两个参数对应参数数量和参数数组）\n\t\n### 动态链接\n\n* P181\n\n\t动态链接把程序按模块拆分成若干个相对独立的部分，模块之间的链接推迟到运行时。ELF的动态链接文件成为“动态共享对象（DSO）”，后缀为“.so”。动态链接的过程由动态链接器完成。动态链接可以节约内存（多个进程共享内存中的某一个模块）、方便升级（静态链接的每一个模块都会影响整个可执行文件）。\n\t\n* P188：\n\t\n\t由于动态共享对象会被多个程序使用，导致它在虚拟地址空间中的位置难以确定。不同模块的目标装载地址如果有相同的，那么同时导入这两个模块就会出问题。如果都不一样也不行，因为可能存在的模块太多了。没有那么多内存。所以动态共享对象需要在装载时重定位。\n\t\n* P191：\n\n\t装载时重定位会导致无法在多个进程间共享，目前采用的方案是地址无关代码技术。动态对象中的地址引用分为模块内部和外部，指令引用和数据引用，两两组合成四种。对于模块内部的指令或数据引用，采用相对偏移调用的方法。\n\t\n* P195：\n\n\t把地址相关需要重定位的部分放到数据段中，同时建立全局偏移表（GOT）。用.got和.got.plt表分别处理数据和函数引用。\n\t\n* P200：\n\n\t当函数第一次被用到的时候才重定位，从而提高程序运行速度。这种方法被称为延迟绑定（Lazy Binding）。Linux维护一个PLT（Procedure Linkage Table）来保存符号名和真实地址之间的对应关系\n\t\n* P208：\n\n\t动态链接中有两个重定位表.rel.dyn和.rel.plt分别对应.rel.text和.rel.data。前者对数据引用（.got）进行修正，后者对函数引用(.got.plt)进行修正。\n\t\n* P214：\n\n\t动态链接器是一个特殊共享对象，它不依赖于任何动态共享文件，且自己的重定位工作由自己完成。通过一段被称为自举（Bootstrap）的特殊代码，不用到任何静态或全部变量，完成这项工作\n\t\n#### 内存与库\n\n* P286：\n\n\ti386处理器下，栈顶有esp寄存器定位，由于栈向下生长，压栈使得栈顶地址减小\n\t\n* P287：\n\n\t栈保存了函数调用所需要的维护信息，被称为堆栈帧（Stack Frame）或活动记录，包含了函数的返回地址和函数，临时变量以及保存的上下文。ebp是帧指针指向活动记录的某一个固定位置。\n\t\n* P294：\n\n\t函数的调用方和被调用方要遵守同一个“调用惯例”。默认的cdecl惯例要求函数参数以从右到左的顺序入栈，由函数调用方负责参数的出栈。\n\t\n* P301：\n\n\t函数返回值的获取：如果是四个字节，放在eax中。4-8字节的返回值通过eax（低位）和edx（高位）联合存储。查过8字节的返回值，把返回值在栈中存放的地址放到eax中。\n\t\n* P306：\n\n\t栈上的数据在函数返回时就会被释放，全局地、动态的申请内存的方式是利用堆。如果由操作系统管理堆，由于总是进行系统调用，性能开销比较大，所以一般由应用程序“批发”一大块内存空间，然后自己进行内存管理。\n\t\n* P311：\n\n\t堆并不总是向上生长（如Windows的HeapCreate系列），调用malloc有可能产生系统调用（取决于进程预申请的空间是否足够），堆内存在进程结束后被操作系统回收，堆内存在虚拟地址空间中连续，在物理空间中可能不连续\n\t\n* P314：\n\n\t堆分配三种算法：空闲链表（简单，记录长度的字节容易被数组越界破坏）、位图（速度快（容易命中cache），稳定性好（不容易数组越界），易管理，会产生碎片，位图有可能过大）、对象池（针对固定大小的分配空间）\n\t\n* P319：\n\n\t创建进程后，操作系统把控制权交给运行库的某个入口函数，然后开始堆的构造，启动I/O，创建线程，进行全局变量构造等。然后调用main函数，main函数执行完成后，执行与之前相反的操作，进行系统调用结束进程。","html":"<p>最初买《程序员的自我修养》这本书，只因为在京东买书差一些钱，不够用优惠券。买回来以后的很长一段时间，我都以为这本书只是程序员用来调侃和自黑的。不过翻读了第一章以后，我就发现自己错的太离谱。我觉得即使一个不使用C/C++，甚至是写解释性语言(如JS等)的程序员，也有必要抽空读一读这本书。作为使用OC或Swift的iOS开发者，我认为这本书是必读的。</p>\n\n<p>所以这篇文章会简单梳理一下《程序员的自我修养》这本书的脉络结构，如果时间有限，又想快速阅读这本书，可以先看看这篇文章。标注了页号的地方表示详细知识可以在给出的页数获取详细的知识。为了简化问题，有些地方会省略一些原文中的细节，一切为了保证读者快速了解这本书。</p>\n\n<p>对于不是专门从事C和底层开发的程序猿来说，个人认为完整的看完本书的所有内容是不太现实，也不太必要的。这本书中有两大部分的知识点对于新手来说非常有必要了解：</p>\n\n<ol>\n<li>一段源代码是怎么变成最后可执行的程序的  </li>\n<li>一个进程，在内存中是什么样的</li>\n</ol>\n\n<p>带着这两个问题去读书，收获会更大。在阅读原书之前，这里有几个相关内容的总结，我尽可能用简单的语言介绍某些知识背景。即使不能完全看懂，也有利于读书时的理解。</p>\n\n<!--more-->\n\n<h2 id=\"\">从源码到程序</h2>\n\n<p>程序最初的存在形式是源代码，也就是若干个<code>.c</code>文件。它要想变成一个可执行的程序，需要以下几个步骤：</p>\n\n<ol>\n<li>预编译(P39)：负责这一步工作的叫“预编译器”。它主要负责处理所有的<code>#define</code>宏定义；所有的预编译指令，比如<code>#if</code>、<code>#endif</code>等。接下来会递归处理<code>#include</code>指令，用被包含的文件替换这个预编译指令。<code>.c</code>文件经过预编译，变为<code>.i</code>文件。  </li>\n<li><p>编译(P42)：这一步由编译器负责，主要又由词法分析、语法分析、语义分析、优化和生成汇编代码五个部分：</p>\n\n<ul><li>词法分析：识别源代码中的各种括号、数字、标点等。比如有<code>(</code>但没有<code>)</code>，这一步就能发现错误</li>\n<li>语法分析：这一步会生成语法树，比如<code>2+4</code>就是一颗根节点为<code>+</code>，左右叶子节点分别为<code>2</code>和<code>4</code>的语法树。如果你只是写<code>2+</code>，在这一步就会报错。</li>\n<li>语义分析：这一步主要考虑类型声明、匹配和转换。比如你写<code>2 * \"3\"</code>在这一步就会报错</li>\n<li>中间语言生成：这一步会生成平台无关的三地址码，比如<code>2 + 3</code>会写成<code>t1 = 2 + 3</code>，同时也会把这样在编译期就可以确定的表达式进行优化</li>\n<li>目标代码生成：编译器根据三地址码生成依赖于目标机器的目标机器代码，也就是汇编语言。</li></ul>\n\n<p><code>.i</code>文件经过编译，得到汇编文件，后缀是<code>.s</code></p></li>\n<li><p>汇编(P40)：这一步由汇编器负责，将汇编语言转换成机器可以执行的语言(完全由0和1组成).汇编文件经过汇编，变成目标文件，后缀为<code>.o</code>。  </p></li>\n<li><p>链接(P41)：这一步是这本书的重点。之前的几个步骤，都是以<code>.c</code>文件为基本单位，一个<code>.c</code>源代码文件最终被汇编，生成目标文件。这一步就是处理如何把多个目标文件链接起来。</p>\n\n<p>考虑一个<code>.c</code>文件中，用到了另一个<code>.c</code>文件中的变量或函数。在编译这个文件时，我们无法在编译期确定这个变量或函数的地址。只有在把所有目标文件链接起来以后，才能确定。链接器主要负责地址重分配、符号名称绑定和重定位。</p></li>\n</ol>\n\n<p>从源代码到程序的运行要做的远远不止编译，很多时候我们说“把程序编译一下”，是不准确的。不过编译确实是整个流程中最复杂的部分。</p>\n\n<h2 id=\"\">软件调用层次</h2>\n\n<p>我们把整个计算机调用结构分为四层：</p>\n\n<ol>\n<li>最上层是应用层。不管是浏览器、游戏，还是我们使用的各种开发工具，如Xcode，VS，汇编器自身等，都属于这一范畴。  </li>\n<li>第二层是操作系统的运行库。我们在程序里调用系统API，比如文件读写，就是调用了第二层提供的相应服务。这种调用通过操作系统的API完成，它沟通了应用层和操作系统的运行库。这也就是为什么不管是在Mac还是Windows上编程，我们都可以调用<code>printf()</code>或<code>fread()</code>等函数。因为不同的操作系统的运行库提供了不同底层的实现，但对应用层提供的API总是一样的。  </li>\n<li>第三层是操作系统内核。操作系统的运行库通过系统调用(System Call)调用系统内核提供的函数。比如<code>fread</code>属于API，它在Linux下会调用<code>read()</code>这个系统调用，而在Windows下会调用<code>ReadFile()</code>这个系统调用。应用程序可以直接调用系统调用，但是这样一来，我们需要考虑各个操作系统下系统调用的不同，而且系统调用由于更加底层，实现起来也就更加困难。最关键的是，系统调用是通过中断来完成的，涉及到堆栈的保存与恢复，频繁的系统调用会影响性能。  </li>\n<li>第四层是硬件层。程序无法直接访问这一层，只有操作系统的内核，通过硬件厂商提供的接口才能访问。</li>\n</ol>\n\n<p>这四层之间的关系如下图所示：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/自我修养/hierarchy.png\" alt=\"层次关系\" /></p>\n\n<h2 id=\"\">虚拟地址空间</h2>\n\n<p>在程序运行的过程中，最重要的概念就是虚拟地址空间。所谓的虚拟地址空间，是指应用程序自己认为，自己所处的地址空间。它区别于物理地址空间。后者是真实存在的，比如电脑有一根8G的内存条，物理地址空间就是0~8Gb。CPU的MMU负责把虚拟地址转换成物理地址。</p>\n\n<p>引入虚拟地址的第一个好处是，程序员不再关心真实的物理内存空间是什么样的，理论上来说，程序员有几乎无限大的虚拟内存空间可用，最后只要建立虚拟地址和物理地址的对应关系即可。另一方面，操作系统屏蔽了物理内存空间的细节，进程无法访问到操作系统禁止访问的物理地址，也不能访问到别的进程的地址空间，这大大增强了程序安全性。</p>\n\n<p>由虚拟地址空间引申出来的分页(Paging)技术，大大提高了内存的使用效率。要想运行一个程序，不再需要把整个程序都放入内存中执行，我们只要保证将要执行的页在内存中即可，如果不存在则导致页错误。</p>\n\n<p>关于地址空间的理解非常重要，书中有很多关于内存、和地址的描述，需要我们自己分析这是虚拟地址还是物理地址。如果分析错了，理解问题会比较麻烦。</p>\n\n<h2 id=\"\">链接与重定位</h2>\n\n<p>我们把<code>foo</code>函数定义在另一个文件中，然后在<code>main.c</code>中调用这个函数，单独编译<code>main.c</code>后代码如下：</p>\n\n<pre><code class=\"language-c\">……\n0000000000000024    callq   0x29  \n0000000000000029    xorl    %ecx, %ecx  \n……\n</code></pre>\n\n<p>可以看到，本该调用<code>foo</code>函数的地方，我们直接调用了下一条命令，但是当<code>main.o</code>和<code>foo.o</code>链接起来后，就变成了：</p>\n\n<pre><code class=\"language-c\">0000000100000f30    pushq   %rbp  \n0000000100000f31    movq    %rsp, %rbp  \n0000000100000f34    movl    $0x7b, %eax  \n0000000100000f39    movl    %edi, -0x4(%rbp)  \n0000000100000f3c    movl    %esi, -0x8(%rbp)  \n0000000100000f3f    popq    %rbp  \n//以上为foo函数实现\n……\n0000000100000f74    callq   0x100000f30  \n0000000100000f79    xorl    %ecx, %ecx  \n……\n</code></pre>\n\n<p>这时候<code>foo</code>函数的位置就正确设置了。原因在于在<code>main.c</code>这个编译模块单独编译时，编译器无法确定<code>foo</code>的位置，只好临时用下一条指令的位置代替一下。</p>\n\n<p>链接器在链接过程中，就是要对这样的符号进行重定位。在重定位时，<code>main.o</code>中有<code>foo</code>函数经过修饰的符号名，同样的符号名在<code>foo.o</code>中也有，于是两者一拍即合，就这样被链接器连在了一起。<code>0x29</code>这个临时的调用地址被更新成了<code>0x100000f30</code>。这个过程类似于拼图游戏，程序在链接时就是处理各种各样类似的问题，当所有编译模块都按照符号名完整的链接起来时，程序也就可以开始运行了。</p>\n\n<p>书中花了不少篇幅介绍目标文件的组成结构，其中很多都是为了重定位而准备的。一旦明白了重定位的原理和过程，在阅读相关内容时就会轻松很多。</p>\n\n<h2 id=\"\">知识概要</h2>\n\n<p>最后列出一部分知识点的简要概括和他们在书中的位置，方便读者参考：</p>\n\n<h3 id=\"\">静态链接部分</h3>\n\n<p>这一部分主要是讨论多个<code>.c</code>文件怎么通过静态链接，得到一个静态库。</p>\n\n<ul>\n<li><p>P58</p>\n\n<p>目标文件中分为若干个段，比如.text段存放代码，.data段存放存放已初始化的全局变量和局部静态变量，.bss段存放未初始化的全局变量和局部静态变量，除此以外目标文件还有很多其他的段。</p></li>\n<li><p>P70</p>\n\n<p>Linux下的目标文件还有一个ELF文件头，用于汇总这个目标文件的各种信息,其中包括了ELF魔数、机器字节长度、数据存储方式、版本、运行平台、ABI版本，重定位类型、硬件平台及版本、入口地址、段表位置、段的数量等。</p></li>\n<li><p>P74</p>\n\n<p>段表其实是一个数组，其中每一个元素都是结构体。结构体里面有段的名称、类型、加载地址、相对于文件头的偏移量，段的大小，链接信息等。</p></li>\n<li><p>P79</p>\n\n<p>目标文件中还有一个重定位表。需要重定位的信息都记录在这个表里面。.text段中所有需要重定位的信息，都放在.rel.text段中。</p></li>\n<li><p>P81</p>\n\n<p>在链接时，我们把函数名和变量都称为符号。每一个函数、变量都有自己独特的符号名，这样在链接时才能把它们对应起来。不同的语言有自己的符号修饰规则。UNIX下的C，编译出来的符号名前面加“_”，如函数foo在编译之后的结果为_foo。</p></li>\n<li><p>P86</p>\n\n<p>C++的namespace就是用来避免符号名冲突。C++有一套自己的符号名修饰规则，可以通过c++filt命令还原被修饰过的符号名(demangle)。一旦了解了符号名的修饰规则，在写iOS时遇到<code>undefined symbol</code>或<code>duplicate symbol name</code>的报错，就非常好检查了。</p></li>\n<li><p>P92</p>\n\n<p>符号分为强符号，和弱符号。强符号不可名称重复，弱符号（未初始化的全局变量）可以有符号名相同。对符号名的引用分为强引用和弱引用，强引用表示如果找不到符号定义会报错，弱引用不报错，默认为0或某个特殊值。</p></li>\n<li><p>P99</p>\n\n<p>链接过程一般分为两步，首先地址分配，然后符号解析并重定位。</p>\n\n<p>由于不同的目标文件，可能含有相同的段，所以在链接过程中，我们可以合并相似段，这就是地址分配。</p>\n\n<p>合并完成后，所有符号的位置都可以唯一确定，此时可以就开始重定位工作了。链接完成后，我们就得到了静态库。</p></li>\n<li><p>P118</p>\n\n<p>静态库可以看做一组目标文件的集合，同一个静态库中的不同目标文件可能相互依赖，不同的静态库也可以相互依赖。</p></li>\n<li><p>P127</p>\n\n<p>链接控制脚本控制链接器的运行，将目标文件和库文件转化为可执行文件。链接控制脚本由链接脚本语言写成。可以认为的控制程序入口，某几个段合并，某几个段舍弃等</p></li>\n</ul>\n\n<h3 id=\"\">动态装载</h3>\n\n<p>这一部分主要是讨论经过链接后，可执行文件如何装载到内存中</p>\n\n<ul>\n<li><p>P153</p>\n\n<p>有两种典型的动态装载方法：覆盖装入和页映射。覆盖装入允许互不依赖的两个模块共同享有同一块内存，在使用中互相替换。速度较慢，用时间换空间。我们常用的方案是页映射，把程序虚拟的内存空间分成多个页，由专门的页装载管理器负责管理虚拟页和物理内存中页的对应关系。</p></li>\n<li><p>P157</p>\n\n<p>创建进程三步骤：首先进程自己的创建物理空间。设置好虚拟空间中各个页到物理空间里的页的映射关系（这一步可能在页错误之后发生）、然后建立虚拟空间与可执行文件的映射关系。Linux下，目标文件的每个段都有自己在虚拟内存中的位置，这叫虚拟内存区域（VMA, Virtual Memory Area），表示它装载在虚拟内存中的地址，最后指令寄存器设置为可执行文件入口。</p></li>\n<li><p>P159</p>\n\n<p>进程创建后，只有物理页与虚拟页的对应关系，但是真正的指令和数据还没有放入物理页中，物理页的内存处于未分配状态。一旦访问到这个物理页，就会发生页错误。</p>\n\n<p>发生页错误时，操作系统立刻根据物理内存的页与虚拟内存的页的对应关系，找到这个页对应的虚拟内存，然后再查询每个段的VMA，就可以找这个页面在可执行文件中的偏移量。这时候操作系统先为物理页分配内存空间，然后把可执行文件中的数据和指令写入物理页，最后建立物理页和虚拟页联系即可。然后进程从发生页错误的地方重新执行。</p></li>\n<li><p>P169</p>\n\n<p>可执行文件有很多Section，它们的大小各不相同，但有些小于页的大小，导致了空间浪费（不能连续存储不同的section是因为可能会有两个权限不同的section在同一个页中）。由于操作系统不关心每个Section的具体作用，但是关心它们的读写权限（是否可读、可写、可执行），所以往往把具有权限的Section合并成一个Segment</p></li>\n<li><p>P172：</p>\n\n<p>进程运行后，操作系统会初始化进程的堆栈，其中存放了环境变量和命令行参数。这些参数被传给main函数（argc和argv两个参数对应参数数量和参数数组）</p></li>\n</ul>\n\n<h3 id=\"\">动态链接</h3>\n\n<ul>\n<li><p>P181</p>\n\n<p>动态链接把程序按模块拆分成若干个相对独立的部分，模块之间的链接推迟到运行时。ELF的动态链接文件成为“动态共享对象（DSO）”，后缀为“.so”。动态链接的过程由动态链接器完成。动态链接可以节约内存（多个进程共享内存中的某一个模块）、方便升级（静态链接的每一个模块都会影响整个可执行文件）。</p></li>\n<li><p>P188：</p>\n\n<p>由于动态共享对象会被多个程序使用，导致它在虚拟地址空间中的位置难以确定。不同模块的目标装载地址如果有相同的，那么同时导入这两个模块就会出问题。如果都不一样也不行，因为可能存在的模块太多了。没有那么多内存。所以动态共享对象需要在装载时重定位。</p></li>\n<li><p>P191：</p>\n\n<p>装载时重定位会导致无法在多个进程间共享，目前采用的方案是地址无关代码技术。动态对象中的地址引用分为模块内部和外部，指令引用和数据引用，两两组合成四种。对于模块内部的指令或数据引用，采用相对偏移调用的方法。</p></li>\n<li><p>P195：</p>\n\n<p>把地址相关需要重定位的部分放到数据段中，同时建立全局偏移表（GOT）。用.got和.got.plt表分别处理数据和函数引用。</p></li>\n<li><p>P200：</p>\n\n<p>当函数第一次被用到的时候才重定位，从而提高程序运行速度。这种方法被称为延迟绑定（Lazy Binding）。Linux维护一个PLT（Procedure Linkage Table）来保存符号名和真实地址之间的对应关系</p></li>\n<li><p>P208：</p>\n\n<p>动态链接中有两个重定位表.rel.dyn和.rel.plt分别对应.rel.text和.rel.data。前者对数据引用（.got）进行修正，后者对函数引用(.got.plt)进行修正。</p></li>\n<li><p>P214：</p>\n\n<p>动态链接器是一个特殊共享对象，它不依赖于任何动态共享文件，且自己的重定位工作由自己完成。通过一段被称为自举（Bootstrap）的特殊代码，不用到任何静态或全部变量，完成这项工作</p></li>\n</ul>\n\n<h4 id=\"\">内存与库</h4>\n\n<ul>\n<li><p>P286：</p>\n\n<p>i386处理器下，栈顶有esp寄存器定位，由于栈向下生长，压栈使得栈顶地址减小</p></li>\n<li><p>P287：</p>\n\n<p>栈保存了函数调用所需要的维护信息，被称为堆栈帧（Stack Frame）或活动记录，包含了函数的返回地址和函数，临时变量以及保存的上下文。ebp是帧指针指向活动记录的某一个固定位置。</p></li>\n<li><p>P294：</p>\n\n<p>函数的调用方和被调用方要遵守同一个“调用惯例”。默认的cdecl惯例要求函数参数以从右到左的顺序入栈，由函数调用方负责参数的出栈。</p></li>\n<li><p>P301：</p>\n\n<p>函数返回值的获取：如果是四个字节，放在eax中。4-8字节的返回值通过eax（低位）和edx（高位）联合存储。查过8字节的返回值，把返回值在栈中存放的地址放到eax中。</p></li>\n<li><p>P306：</p>\n\n<p>栈上的数据在函数返回时就会被释放，全局地、动态的申请内存的方式是利用堆。如果由操作系统管理堆，由于总是进行系统调用，性能开销比较大，所以一般由应用程序“批发”一大块内存空间，然后自己进行内存管理。</p></li>\n<li><p>P311：</p>\n\n<p>堆并不总是向上生长（如Windows的HeapCreate系列），调用malloc有可能产生系统调用（取决于进程预申请的空间是否足够），堆内存在进程结束后被操作系统回收，堆内存在虚拟地址空间中连续，在物理空间中可能不连续</p></li>\n<li><p>P314：</p>\n\n<p>堆分配三种算法：空闲链表（简单，记录长度的字节容易被数组越界破坏）、位图（速度快（容易命中cache），稳定性好（不容易数组越界），易管理，会产生碎片，位图有可能过大）、对象池（针对固定大小的分配空间）</p></li>\n<li><p>P319：</p>\n\n<p>创建进程后，操作系统把控制权交给运行库的某个入口函数，然后开始堆的构造，启动I/O，创建线程，进行全局变量构造等。然后调用main函数，main函数执行完成后，执行与之前相反的操作，进行系统调用结束进程。</p></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:12:39.000Z","created_by":1,"updated_at":"2016-01-28T16:32:14.000Z","updated_by":1,"published_at":"2015-12-22T08:12:00.000Z","published_by":1},{"id":11,"uuid":"77bc08df-c3ff-41fe-8bc1-003ebb9b1ab3","title":"Swift与OC中拷贝与可变性","slug":"differenceofcopybettenswiftandoc","markdown":"首先来看一下Objective-C中的拷贝与可变性。为了解释方便，定义两个类：<font color = \"rgb(226,238,250)\">`Person`</font>和<font color = \"rgb(226,238,250)\">`MyObject`</font>，它们都继承自<font color = \"rgb(226,238,250)\">`NSObject`</font>。他们的关系如下:\n\n```objc\n// Person.h\n@property (strong, nonatomic, nullable) MyObject *object;\n```\n\n```objc\n// MyObjec.h\n@property (copy, nonatomic) NSString *name;\n```\n\n##普通对象拷贝\n\n对于一个OC中的对象来说，可能涉及拷贝的有三种操作：\n\n1. <font color = \"rgb(226,238,250)\">`retain`</font>操作：\n\n\t```objc\n\tPerson *p = [[Person alloc] init];\n\tPerson *p1 = p;\n\t```\n\t\n\t这里的<font color = \"rgb(226,238,250)\">`p1`</font>默认是<font color = \"rgb(226,238,250)\">`__strong`</font>，所以它会对`p`进行<font color = \"rgb(226,238,250)\">`retain`</font>操作。<font color = \"rgb(226,238,250)\">`retain`</font>与复制无关，只会对引用计数加1。<font color = \"rgb(226,238,250)\">`p1`</font>和<font color = \"rgb(226,238,250)\">`p`</font>的地址是完全一样的：\n\t\n\t```objc\n\t2015-12-23 21:24:31.893 Copy[1300:120857] p = 0x1006012c0\n2015-12-23 21:24:31.894 Copy[1300:120857] p1 = 0x1006012c0\n\t```\n\t\n\t这种写法最简单，而且严格来说不是复制，但值得一提，因为在接下来的OC和Swift中，都会涉及到这样的代码。\n\t\n2. <font color = \"rgb(226,238,250)\">`copy`</font>方法：\n\n\t调用<font color = \"rgb(226,238,250)\">`copy`</font>方法需要实现<font color = \"rgb(226,238,250)\">`NSCopying`</font>协议，并提供<font color = \"rgb(226,238,250)\">`copyWithZone`</font>方法：\n\t\n\t```objc\n\t- (id)copyWithZone:(NSZone *)zone {\n    \tPerson *copyInstance = [[self class] allocWithZone:zone];\n    \tcopyInstance.object = self.object;\n    \treturn copyInstance;\n\t}\n\t```\n\t\n\t第二行代码就是刚刚所说的<font color = \"rgb(226,238,250)\">`retain`</font>操作。因此，我们虽然复制了<font color = \"rgb(226,238,250)\">`Person`</font>对象的指针，但是其内部的属性，依然和原来对象的相同。\n\t\n3. 自定义拷贝方法：\n\t\n\t我们当然可以自己定义一个拷贝方法，在复制<font color = \"rgb(226,238,250)\">`Person`</font>对象的同时，把其中的<font color = \"rgb(226,238,250)\">`object`</font>属性也复制，而不是仅仅<font color = \"rgb(226,238,250)\">`retain`</font>。\n\t\n\n第二三种复制方法的区别如图所示：\n\n![两种拷贝方式](http://7xonij.com1.z0.glb.clouddn.com/Copy/deepVSshallow.png)\n\n##浅拷贝与深拷贝\n\n标为红色的是两种拷贝方式的不同之处。对于左边这种，只拷贝指针本身的拷贝方法，我们称为浅拷贝。对于右边那种，不仅拷贝指针自身，还拷贝指针中所有元素的拷贝方法，我们称为深拷贝。\n\n没有明确的限制<font color = \"rgb(226,238,250)\">`copy`</font>和自定义的拷贝方法要如何实现。也就是说<font color = \"rgb(226,238,250)\">`copy`</font>方法可以用来进行深拷贝，我们也可以自定义浅拷贝的方法。这完全取决于我们自己如何实现<font color = \"rgb(226,238,250)\">`copy`</font>方法和自定义的拷贝方法。在OC中，对于自定义的类来说，浅拷贝与深拷贝只是一种概念，并没有明确的标注哪种方法就是浅拷贝。\n\n**注意**\n\n“深拷贝将被拷贝的对象完全复制”这种说法不完全正确，比如上图中我们看到<font color = \"rgb(226,238,250)\">`data`</font>的地址永远不会拷贝。这是因为，深拷贝只负责了对象的拷贝，以及对象中所有属性的拷贝。正是因为拷贝了属性，将<font color = \"rgb(226,238,250)\">`p`</font>深拷贝后得到的<font color = \"rgb(226,238,250)\">`p'`</font>的<font color = \"rgb(226,238,250)\">`object`</font>指针地址和<font color = \"rgb(226,238,250)\">`p`</font>的<font color = \"rgb(226,238,250)\">`object`</font>指针地址不同。\n\n但是至于<font color = \"rgb(226,238,250)\">`data`</font>会不会被拷贝，这取决于<font color = \"rgb(226,238,250)\">`MyObject`</font>类如何设计，如果<font color = \"rgb(226,238,250)\">`MyObject`</font>的<font color = \"rgb(226,238,250)\">`copy`</font>方法只是浅拷贝，就会形成如上图所示的情况。如果<font color = \"rgb(226,238,250)\">`MyObject`</font>的<font color = \"rgb(226,238,250)\">`copy`</font>方法也是深拷贝，那么<font color = \"rgb(226,238,250)\">`data`</font>的地址也会不同。\n\n##容器对象拷贝\n\n在OC中，所有<font color = \"rgb(226,238,250)\">`Foundation`</font>中的容器类，分为可变容器和不可变容器，它们的拷贝**都是浅拷贝**。这也就是为什么建议自定义的对象实现浅拷贝，如果有需要才自定义深拷贝方法。因为这样一来，所有的方法调用就都可以统一，不至于造成误解。\n\n如果我们把数组想象成一个三层的数据结构，第一层是数组自己的指针，第二层是存放在数组中的指针，第三层(如果第二层是指针)则是这些指针指向的对象。那么在复制数组时，复制的是前两层，第三层的对象不会被复制。如果把前两层看做指针，第三层看做对象，那么数组的拷贝，无论是<font color = \"rgb(226,238,250)\">`copy`</font>还是<font color = \"rgb(226,238,250)\">`mutableCopy`</font>都是浅拷贝。当然，也有人把这个称为“单层深拷贝”，这些概念性的定义都不重要，重要的是知道数组拷贝时的原理。\n\n这一点很好理解。首先，指针所指向的对象，也许很大，深拷贝可能占用过多的内存和时间。其次，容器不知道自己存储的对象是否实现了<font color = \"rgb(226,238,250)\">`NSCopying`</font>协议。如果容器的拷贝默认是深拷贝，同时你在数组中存放了<font color = \"rgb(226,238,250)\">`Person`</font>类的对象，而<font color = \"rgb(226,238,250)\">`Person`</font>类根本没有实现<font color = \"rgb(226,238,250)\">`NSCopying`</font>协议，后果是复制容器会导致程序崩溃。这是任何语言开发者都不希望看到的，所以设身处地想一下，如果是你来设计OC，也不会让数组深拷贝吧。\n\n观察下面这段代码，思考一下为什么<font color = \"rgb(226,238,250)\">`a1[0] = @0`</font>没有影响<font color = \"rgb(226,238,250)\">`a2`</font>：\n\n```objc\nNSMutableArray *a1 = [[NSMutableArray alloc] initWithObjects:@1, @2, nil];\nNSMutableArray *a2 = [a1 mutableCopy];\na1[0] = @0;\nNSLog(@\"a2 = %@\", a2);\n\n/*\n2015-12-23 23:11:53.711 Copy[1795:220469] a2 = (\n    0,\n    2\n)\n*/\n```\n\n## 可变性\n\n容器对象分为可变容器与不可变容器，<font color = \"rgb(226,238,250)\">`NSData`</font>、<font color = \"rgb(226,238,250)\">`NSArray`</font>、<font color = \"rgb(226,238,250)\">`NSString`</font>等都是不可变容器，以<font color = \"rgb(226,238,250)\">`NSMutable`</font>开头的则是它们的可变版本。下面统一用<font color = \"rgb(226,238,250)\">`NSArray`</font>和<font color = \"rgb(226,238,250)\">`NSMutableArray`</font>举例说明。\n\n因为<font color = \"rgb(226,238,250)\">`NSMutableArray`</font>是<font color = \"rgb(226,238,250)\">`NSArray`</font>的子类，所以<font color = \"rgb(226,238,250)\">`NSArray`</font>对象不能强制转换成<font color = \"rgb(226,238,250)\">`NSMutableArray`</font>，否则在调用<font color = \"rgb(226,238,250)\">`addObject`</font>方法时会崩溃。反之，<font color = \"rgb(226,238,250)\">`NSMutableArray`</font>可以转换成它的父类<font color = \"rgb(226,238,250)\">`NSArray`</font>，这么做会导致它失去可变性。\n\n容器拷贝的难点在于可变性的变化。容器有两种方法：<font color = \"rgb(226,238,250)\">`copy`</font>和<font color = \"rgb(226,238,250)\">`mutableCopy`</font>，再次强调这两者都是浅拷贝。它们的区别在于，返回值是否是可变的。前者返回不可变容器，后者返回可变容器。\n\n这也就是说，返回值的可变性与被拷贝对象的可变性无关，仅取决于调用了何种拷贝方法。比如：\n\n```objc\nNSMutableArray *mutableArray = [[NSMutableArray alloc] initWithObjects:@1, @2, nil];\nNSMutableArray *array = [mutableArray copy];\n[array addObject:@3];\n```\n\n尽管我们调用了<font color = \"rgb(226,238,250)\">`mutableArray`</font>的拷贝方法，返回值也声明为<font color = \"rgb(226,238,250)\">`NSMutableArray`</font>，但是调用<font color = \"rgb(226,238,250)\">`addObject`</font>方法时依然会导致运行时错误。这是由错误的调用了<font color = \"rgb(226,238,250)\">`copy`</font>方法导致的。\n\n调用一个对象的浅拷贝方法会得到一个新的对象(地址不同)，但是容器类中有一个特例：\n\n```objc\nNSArray *array1 = @[@1, @2];\nNSArray *array2 = [array1 copy];\n// array1和array2指向的数组对象地址相同\n```\n\n这是因为既然<font color = \"rgb(226,238,250)\">`array1`</font>和<font color = \"rgb(226,238,250)\">`array2`</font>都不能再修改，那么两者共用同一块内存也是无所谓的，所以OC做了这样的优化。\n\n## 字符串拷贝\n\n字符串也可以被当做容器来理解。它有<font color = \"rgb(226,238,250)\">`NSString`</font>和<font color = \"rgb(226,238,250)\">`NSMutableString`</font>两个版本。\n\n于是为什么字符串属性要定义成<font color = \"rgb(226,238,250)\">`@property(copy, nonatomic)`</font>就很好理解了。它主要用于处理这种情况：\n\n```objc\nNSMutableString *string = @\"hello\";\nself.propertyString = string;\n[string appendString:@\" world\"];\n```\n\n如果属性定义成<font color = \"rgb(226,238,250)\">`strong`</font>，那么在第二步执行了<font color = \"rgb(226,238,250)\">`retain`</font>操作，第三步对<font color = \"rgb(226,238,250)\">`string`</font>的修改就会影响到原来的属性。现在我们把属性定义为<font color = \"rgb(226,238,250)\">`copy`</font>，那么第二步操作其实是得到了一个新的，不可变字符串。这符合我们的预期目的。\n\n# Swift拷贝\n\n## 结构体拷贝\n\n数组、字典等容器在Swift中被定义成了结构体，它们的拷贝规则和OC完全不同：\n\n```swift\nvar array1 = [1,2,3]\nvar array2 = array1\n\narray1[0] = 0\nprint(array2) // 输出结果：[1, 2, 3]\n```\n\n可以看到，即使是最简单的等号赋值，也会浅拷贝原来的值。这是由Swift中结构体的值语义决定的。之所以说是浅拷贝而不是深拷贝，理由参见前文解释OC中容器的浅拷贝，尤其是第二点理由，不管是对于OC还是Swift来说都是通用的。\n\n## 对象拷贝\n\n和OC中指针赋值类似，对象的直接赋值操作与拷贝无关：\n\n```swift\nclass Person {\n    var name: String;\n    init(name:String) {\n        self.name = name\n    }\n}\n\nlet person1 = Person(name: \"zxy\")\nlet person2 = person1\nperson1.name = \"new name\"\n\nprint(person2.name) //结果是“new name”\n```\n\n如果要拷贝对象，有两种方法。首先，最自然想到的是实现<font color = \"rgb(226,238,250)\">`NSCopying`</font>协议，注意只有<font color = \"rgb(226,238,250)\">`NSObject`</font>类的对象才能实现这个协议：\n\n```swift\nclass Person : NSObject, NSCopying {\n    var name: String;\n    init(name:String) {\n        self.name = name\n    }\n    \n    func copyWithZone(zone: NSZone) -> AnyObject {\n        return Person(name: self.name)\n    }\n}\n\n```\n\n但这样做最大的问题在于，你必须继承自<font color = \"rgb(226,238,250)\">`NSObject`</font>，这就又回到了OC的那一套。如果我们希望定义纯粹的Swift类，完全可以自己定义并实现拷贝方法。\n\n“面向接口编程”的原则告诉我们，我们应该让<font color = \"rgb(226,238,250)\">`Person`</font>实现某个接口，而不是继承自某个子类：\n\n```swift\nprotocol Copyable {\n    func copy() -> Copyable\n}\n\nclass Person : Copyable {\n    var name: String;\n    init(name:String) {\n        self.name = name\n    }\n    \n    func copy() -> Copyable {\n        return Person(name: self.name)\n    }\n}\n\nlet person1 = Person(name: \"zxy\")\nlet person2 = person1.copy() as! Person\n```\n\n这样就完美的实现Swift-Style拷贝了。\n\n#总结\n\n在OC中，浅拷贝通常由<font color = \"rgb(226,238,250)\">`NSCopying`</font>协议的<font color = \"rgb(226,238,250)\">`copyWithZone`</font>方法实现，深拷贝需要自定义方法。直接赋值意味着<font color = \"rgb(226,238,250)\">`retain`</font>而不是拷贝。\n\n在Swift中，值类型直接用等号赋值意味着浅拷贝，引用类型的拷贝可以通过实现自定义的<font color = \"rgb(226,238,250)\">`Copyable`</font>协议或OC的<font color = \"rgb(226,238,250)\">`NSCopying`</font>协议完成。\n\n在OC中，我们需要容器的可变性，而Swift在这一点做的要比OC好得多。它的可变性非常简单，完全通过<font color = \"rgb(226,238,250)\">`let`</font>和<font color = \"rgb(226,238,250)\">`var`</font>控制，这也是Swift相比于OC的一个优点吧，毕竟高级的语言应该尽可能封装底层实现。","html":"<p>首先来看一下Objective-C中的拷贝与可变性。为了解释方便，定义两个类：<font color = \"rgb(226,238,250)\"><code>Person</code></font>和<font color = \"rgb(226,238,250)\"><code>MyObject</code></font>，它们都继承自<font color = \"rgb(226,238,250)\"><code>NSObject</code></font>。他们的关系如下:</p>\n\n<pre><code class=\"language-objc\">// Person.h\n@property (strong, nonatomic, nullable) MyObject *object;\n</code></pre>\n\n<pre><code class=\"language-objc\">// MyObjec.h\n@property (copy, nonatomic) NSString *name;\n</code></pre>\n\n<h2 id=\"\">普通对象拷贝</h2>\n\n<p>对于一个OC中的对象来说，可能涉及拷贝的有三种操作：</p>\n\n<ol>\n<li><p><font color = \"rgb(226,238,250)\"><code>retain</code></font>操作：</p>\n\n<p><code>objc\nPerson *p = [[Person alloc] init];\nPerson *p1 = p;\n</code></p>\n\n<p>这里的<font color = \"rgb(226,238,250)\"><code>p1</code></font>默认是<font color = \"rgb(226,238,250)\"><code>__strong</code></font>，所以它会对<code>p</code>进行<font color = \"rgb(226,238,250)\"><code>retain</code></font>操作。<font color = \"rgb(226,238,250)\"><code>retain</code></font>与复制无关，只会对引用计数加1。<font color = \"rgb(226,238,250)\"><code>p1</code></font>和<font color = \"rgb(226,238,250)\"><code>p</code></font>的地址是完全一样的：</p>\n\n<p><code>objc\n2015-12-23 21:24:31.893 Copy[1300:120857] p = 0x1006012c0\n2015-12-23 21:24:31.894 Copy[1300:120857] p1 = 0x1006012c0 <br />\n</code></p>\n\n<p>这种写法最简单，而且严格来说不是复制，但值得一提，因为在接下来的OC和Swift中，都会涉及到这样的代码。</p></li>\n<li><p><font color = \"rgb(226,238,250)\"><code>copy</code></font>方法：</p>\n\n<p>调用<font color = \"rgb(226,238,250)\"><code>copy</code></font>方法需要实现<font color = \"rgb(226,238,250)\"><code>NSCopying</code></font>协议，并提供<font color = \"rgb(226,238,250)\"><code>copyWithZone</code></font>方法：</p>\n\n<p>```objc</p>\n\n<ul><li>(id)copyWithZone:(NSZone *)zone {\nPerson *copyInstance = [[self class] allocWithZone:zone];\ncopyInstance.object = self.object;\nreturn copyInstance;\n}\n```</li></ul>\n\n<p>第二行代码就是刚刚所说的<font color = \"rgb(226,238,250)\"><code>retain</code></font>操作。因此，我们虽然复制了<font color = \"rgb(226,238,250)\"><code>Person</code></font>对象的指针，但是其内部的属性，依然和原来对象的相同。</p></li>\n<li><p>自定义拷贝方法：</p>\n\n<p>我们当然可以自己定义一个拷贝方法，在复制<font color = \"rgb(226,238,250)\"><code>Person</code></font>对象的同时，把其中的<font color = \"rgb(226,238,250)\"><code>object</code></font>属性也复制，而不是仅仅<font color = \"rgb(226,238,250)\"><code>retain</code></font>。</p></li>\n</ol>\n\n<p>第二三种复制方法的区别如图所示：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Copy/deepVSshallow.png\" alt=\"两种拷贝方式\" /></p>\n\n<h2 id=\"\">浅拷贝与深拷贝</h2>\n\n<p>标为红色的是两种拷贝方式的不同之处。对于左边这种，只拷贝指针本身的拷贝方法，我们称为浅拷贝。对于右边那种，不仅拷贝指针自身，还拷贝指针中所有元素的拷贝方法，我们称为深拷贝。</p>\n\n<p>没有明确的限制<font color = \"rgb(226,238,250)\"><code>copy</code></font>和自定义的拷贝方法要如何实现。也就是说<font color = \"rgb(226,238,250)\"><code>copy</code></font>方法可以用来进行深拷贝，我们也可以自定义浅拷贝的方法。这完全取决于我们自己如何实现<font color = \"rgb(226,238,250)\"><code>copy</code></font>方法和自定义的拷贝方法。在OC中，对于自定义的类来说，浅拷贝与深拷贝只是一种概念，并没有明确的标注哪种方法就是浅拷贝。</p>\n\n<p><strong>注意</strong></p>\n\n<p>“深拷贝将被拷贝的对象完全复制”这种说法不完全正确，比如上图中我们看到<font color = \"rgb(226,238,250)\"><code>data</code></font>的地址永远不会拷贝。这是因为，深拷贝只负责了对象的拷贝，以及对象中所有属性的拷贝。正是因为拷贝了属性，将<font color = \"rgb(226,238,250)\"><code>p</code></font>深拷贝后得到的<font color = \"rgb(226,238,250)\"><code>p'</code></font>的<font color = \"rgb(226,238,250)\"><code>object</code></font>指针地址和<font color = \"rgb(226,238,250)\"><code>p</code></font>的<font color = \"rgb(226,238,250)\"><code>object</code></font>指针地址不同。</p>\n\n<p>但是至于<font color = \"rgb(226,238,250)\"><code>data</code></font>会不会被拷贝，这取决于<font color = \"rgb(226,238,250)\"><code>MyObject</code></font>类如何设计，如果<font color = \"rgb(226,238,250)\"><code>MyObject</code></font>的<font color = \"rgb(226,238,250)\"><code>copy</code></font>方法只是浅拷贝，就会形成如上图所示的情况。如果<font color = \"rgb(226,238,250)\"><code>MyObject</code></font>的<font color = \"rgb(226,238,250)\"><code>copy</code></font>方法也是深拷贝，那么<font color = \"rgb(226,238,250)\"><code>data</code></font>的地址也会不同。</p>\n\n<h2 id=\"\">容器对象拷贝</h2>\n\n<p>在OC中，所有<font color = \"rgb(226,238,250)\"><code>Foundation</code></font>中的容器类，分为可变容器和不可变容器，它们的拷贝<strong>都是浅拷贝</strong>。这也就是为什么建议自定义的对象实现浅拷贝，如果有需要才自定义深拷贝方法。因为这样一来，所有的方法调用就都可以统一，不至于造成误解。</p>\n\n<p>如果我们把数组想象成一个三层的数据结构，第一层是数组自己的指针，第二层是存放在数组中的指针，第三层(如果第二层是指针)则是这些指针指向的对象。那么在复制数组时，复制的是前两层，第三层的对象不会被复制。如果把前两层看做指针，第三层看做对象，那么数组的拷贝，无论是<font color = \"rgb(226,238,250)\"><code>copy</code></font>还是<font color = \"rgb(226,238,250)\"><code>mutableCopy</code></font>都是浅拷贝。当然，也有人把这个称为“单层深拷贝”，这些概念性的定义都不重要，重要的是知道数组拷贝时的原理。</p>\n\n<p>这一点很好理解。首先，指针所指向的对象，也许很大，深拷贝可能占用过多的内存和时间。其次，容器不知道自己存储的对象是否实现了<font color = \"rgb(226,238,250)\"><code>NSCopying</code></font>协议。如果容器的拷贝默认是深拷贝，同时你在数组中存放了<font color = \"rgb(226,238,250)\"><code>Person</code></font>类的对象，而<font color = \"rgb(226,238,250)\"><code>Person</code></font>类根本没有实现<font color = \"rgb(226,238,250)\"><code>NSCopying</code></font>协议，后果是复制容器会导致程序崩溃。这是任何语言开发者都不希望看到的，所以设身处地想一下，如果是你来设计OC，也不会让数组深拷贝吧。</p>\n\n<p>观察下面这段代码，思考一下为什么<font color = \"rgb(226,238,250)\"><code>a1[0] = @0</code></font>没有影响<font color = \"rgb(226,238,250)\"><code>a2</code></font>：</p>\n\n<pre><code class=\"language-objc\">NSMutableArray *a1 = [[NSMutableArray alloc] initWithObjects:@1, @2, nil];  \nNSMutableArray *a2 = [a1 mutableCopy];  \na1[0] = @0;  \nNSLog(@\"a2 = %@\", a2);\n\n/*\n2015-12-23 23:11:53.711 Copy[1795:220469] a2 = (  \n    0,\n    2\n)\n*/\n</code></pre>\n\n<h2 id=\"\">可变性</h2>\n\n<p>容器对象分为可变容器与不可变容器，<font color = \"rgb(226,238,250)\"><code>NSData</code></font>、<font color = \"rgb(226,238,250)\"><code>NSArray</code></font>、<font color = \"rgb(226,238,250)\"><code>NSString</code></font>等都是不可变容器，以<font color = \"rgb(226,238,250)\"><code>NSMutable</code></font>开头的则是它们的可变版本。下面统一用<font color = \"rgb(226,238,250)\"><code>NSArray</code></font>和<font color = \"rgb(226,238,250)\"><code>NSMutableArray</code></font>举例说明。</p>\n\n<p>因为<font color = \"rgb(226,238,250)\"><code>NSMutableArray</code></font>是<font color = \"rgb(226,238,250)\"><code>NSArray</code></font>的子类，所以<font color = \"rgb(226,238,250)\"><code>NSArray</code></font>对象不能强制转换成<font color = \"rgb(226,238,250)\"><code>NSMutableArray</code></font>，否则在调用<font color = \"rgb(226,238,250)\"><code>addObject</code></font>方法时会崩溃。反之，<font color = \"rgb(226,238,250)\"><code>NSMutableArray</code></font>可以转换成它的父类<font color = \"rgb(226,238,250)\"><code>NSArray</code></font>，这么做会导致它失去可变性。</p>\n\n<p>容器拷贝的难点在于可变性的变化。容器有两种方法：<font color = \"rgb(226,238,250)\"><code>copy</code></font>和<font color = \"rgb(226,238,250)\"><code>mutableCopy</code></font>，再次强调这两者都是浅拷贝。它们的区别在于，返回值是否是可变的。前者返回不可变容器，后者返回可变容器。</p>\n\n<p>这也就是说，返回值的可变性与被拷贝对象的可变性无关，仅取决于调用了何种拷贝方法。比如：</p>\n\n<pre><code class=\"language-objc\">NSMutableArray *mutableArray = [[NSMutableArray alloc] initWithObjects:@1, @2, nil];  \nNSMutableArray *array = [mutableArray copy];  \n[array addObject:@3];\n</code></pre>\n\n<p>尽管我们调用了<font color = \"rgb(226,238,250)\"><code>mutableArray</code></font>的拷贝方法，返回值也声明为<font color = \"rgb(226,238,250)\"><code>NSMutableArray</code></font>，但是调用<font color = \"rgb(226,238,250)\"><code>addObject</code></font>方法时依然会导致运行时错误。这是由错误的调用了<font color = \"rgb(226,238,250)\"><code>copy</code></font>方法导致的。</p>\n\n<p>调用一个对象的浅拷贝方法会得到一个新的对象(地址不同)，但是容器类中有一个特例：</p>\n\n<pre><code class=\"language-objc\">NSArray *array1 = @[@1, @2];  \nNSArray *array2 = [array1 copy];  \n// array1和array2指向的数组对象地址相同\n</code></pre>\n\n<p>这是因为既然<font color = \"rgb(226,238,250)\"><code>array1</code></font>和<font color = \"rgb(226,238,250)\"><code>array2</code></font>都不能再修改，那么两者共用同一块内存也是无所谓的，所以OC做了这样的优化。</p>\n\n<h2 id=\"\">字符串拷贝</h2>\n\n<p>字符串也可以被当做容器来理解。它有<font color = \"rgb(226,238,250)\"><code>NSString</code></font>和<font color = \"rgb(226,238,250)\"><code>NSMutableString</code></font>两个版本。</p>\n\n<p>于是为什么字符串属性要定义成<font color = \"rgb(226,238,250)\"><code>@property(copy, nonatomic)</code></font>就很好理解了。它主要用于处理这种情况：</p>\n\n<pre><code class=\"language-objc\">NSMutableString *string = @\"hello\";  \nself.propertyString = string;  \n[string appendString:@\" world\"];\n</code></pre>\n\n<p>如果属性定义成<font color = \"rgb(226,238,250)\"><code>strong</code></font>，那么在第二步执行了<font color = \"rgb(226,238,250)\"><code>retain</code></font>操作，第三步对<font color = \"rgb(226,238,250)\"><code>string</code></font>的修改就会影响到原来的属性。现在我们把属性定义为<font color = \"rgb(226,238,250)\"><code>copy</code></font>，那么第二步操作其实是得到了一个新的，不可变字符串。这符合我们的预期目的。</p>\n\n<h1 id=\"swift\">Swift拷贝</h1>\n\n<h2 id=\"\">结构体拷贝</h2>\n\n<p>数组、字典等容器在Swift中被定义成了结构体，它们的拷贝规则和OC完全不同：</p>\n\n<pre><code class=\"language-swift\">var array1 = [1,2,3]  \nvar array2 = array1\n\narray1[0] = 0  \nprint(array2) // 输出结果：[1, 2, 3]  \n</code></pre>\n\n<p>可以看到，即使是最简单的等号赋值，也会浅拷贝原来的值。这是由Swift中结构体的值语义决定的。之所以说是浅拷贝而不是深拷贝，理由参见前文解释OC中容器的浅拷贝，尤其是第二点理由，不管是对于OC还是Swift来说都是通用的。</p>\n\n<h2 id=\"\">对象拷贝</h2>\n\n<p>和OC中指针赋值类似，对象的直接赋值操作与拷贝无关：</p>\n\n<pre><code class=\"language-swift\">class Person {  \n    var name: String;\n    init(name:String) {\n        self.name = name\n    }\n}\n\nlet person1 = Person(name: \"zxy\")  \nlet person2 = person1  \nperson1.name = \"new name\"\n\nprint(person2.name) //结果是“new name”  \n</code></pre>\n\n<p>如果要拷贝对象，有两种方法。首先，最自然想到的是实现<font color = \"rgb(226,238,250)\"><code>NSCopying</code></font>协议，注意只有<font color = \"rgb(226,238,250)\"><code>NSObject</code></font>类的对象才能实现这个协议：</p>\n\n<pre><code class=\"language-swift\">class Person : NSObject, NSCopying {  \n    var name: String;\n    init(name:String) {\n        self.name = name\n    }\n\n    func copyWithZone(zone: NSZone) -&gt; AnyObject {\n        return Person(name: self.name)\n    }\n}\n</code></pre>\n\n<p>但这样做最大的问题在于，你必须继承自<font color = \"rgb(226,238,250)\"><code>NSObject</code></font>，这就又回到了OC的那一套。如果我们希望定义纯粹的Swift类，完全可以自己定义并实现拷贝方法。</p>\n\n<p>“面向接口编程”的原则告诉我们，我们应该让<font color = \"rgb(226,238,250)\"><code>Person</code></font>实现某个接口，而不是继承自某个子类：</p>\n\n<pre><code class=\"language-swift\">protocol Copyable {  \n    func copy() -&gt; Copyable\n}\n\nclass Person : Copyable {  \n    var name: String;\n    init(name:String) {\n        self.name = name\n    }\n\n    func copy() -&gt; Copyable {\n        return Person(name: self.name)\n    }\n}\n\nlet person1 = Person(name: \"zxy\")  \nlet person2 = person1.copy() as! Person  \n</code></pre>\n\n<p>这样就完美的实现Swift-Style拷贝了。</p>\n\n<h1 id=\"\">总结</h1>\n\n<p>在OC中，浅拷贝通常由<font color = \"rgb(226,238,250)\"><code>NSCopying</code></font>协议的<font color = \"rgb(226,238,250)\"><code>copyWithZone</code></font>方法实现，深拷贝需要自定义方法。直接赋值意味着<font color = \"rgb(226,238,250)\"><code>retain</code></font>而不是拷贝。</p>\n\n<p>在Swift中，值类型直接用等号赋值意味着浅拷贝，引用类型的拷贝可以通过实现自定义的<font color = \"rgb(226,238,250)\"><code>Copyable</code></font>协议或OC的<font color = \"rgb(226,238,250)\"><code>NSCopying</code></font>协议完成。</p>\n\n<p>在OC中，我们需要容器的可变性，而Swift在这一点做的要比OC好得多。它的可变性非常简单，完全通过<font color = \"rgb(226,238,250)\"><code>let</code></font>和<font color = \"rgb(226,238,250)\"><code>var</code></font>控制，这也是Swift相比于OC的一个优点吧，毕竟高级的语言应该尽可能封装底层实现。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:15:10.000Z","created_by":1,"updated_at":"2016-01-28T16:32:00.000Z","updated_by":1,"published_at":"2015-12-23T08:15:00.000Z","published_by":1},{"id":12,"uuid":"9a3a588a-9b3f-4d0f-a167-1e281e7db51e","title":"OC和Swift闭包对比总结","slug":"oche-swiftbi-bao-dui-bi-zong-jie","markdown":"#OC的block\n\nOC的block已经有很多相关的文章介绍了，主要难点在于`__block`修饰符的作用和原理，以及循环引用问题。首先看一看`__block`修饰符，最后分析循环引用问题。这里的讨论都是基于ARC的。\n\n### 截获基本类型\n\n\n```objc\nint value = 10;\nvoid(^block)() = ^{\n    NSLog(@\"value = %d\", value);\n};\nvalue = 20;\nblock();\n\n// 打印结果是：\"value = 10\"\n```\n\nOC的block会截获外部变量，对于`int`等基本数据类型，block的内部会拷贝一份，简单来说，它的实现大概是这样的：\n\n```objc\nstruct block_impl {\n\t//其它内容\n\tint value;\n};\n```\n\n因为block内部拷贝了截获的变量的副本，所以生成block后再修改变量，不会影响被block截获的变量。同时block内部也不能修改这个变量。\n\n### 修改基本类型\n\n如果要想在block中修改被截获的基本类型变量，需要把它标记为`__block`：\n\n```objc\n__block int value = 10;\nvoid(^block)() = ^{\n    NSLog(@\"value = %d\", value);\n};\nvalue = 20;\nblock();\n\n// 打印结果是：\"value = 20\"\n```\n\n这是因为，对于被标记了`__block`的变量，block在截获它时，会保存一个指针。简单来说，它的实现大概是这样的：\n\n```objc\nstruct block_impl {\n\t//其它内容\n\tblock_ref_value *value;\n};\n\nstruct block_ref_value {\n\tint value; // 这里保存的才是被截获的value的值。\n};\n```\n\n由于block中一直有一个指针指向value，所以block内部对它的修改，可以影响到block外部的变量。因为block修改的就是那个外部变量而不是外部变量的副本。\n\n上面关于block具体实现的例子只是一个简化模型，事实上并非如此，但本质类似。总的来说，只有由`__block`修饰符修饰的基本类型变量，在被block截获时才是可变的。关于这方面的详细解释，可以参考这三篇文章：\n\n* [iOS OC语言: Block底层实现原理](http://www.jianshu.com/p/e23078c11518)：这个很详细地讲了`__block`的实现原理\n* [Block的引用循环问题 (ARC & non-ARC)](http://blog.csdn.net/wildfireli/article/details/22063001)：这个讲了一些block底层的实现原理以及循环引用问题。\n* [你真的理解__block修饰符的原理么？](http://blog.csdn.net/abc649395594/article/details/47086751)：这是我之前写过的一篇介绍`__block`原理的文章，内容会详细一些。\n\n### 截获指针\n\nblock截获指针和截获基本类型是相似的，不过稍稍复杂一些。这是一个最简单的例子。\n\n```objc\nPerson *p = [[Person alloc] initWithName:@\"zxy\"];    \nvoid(^block)() = ^{\n    NSLog(@\"person name = %@\", p.name);\n};\n    \np.name = @\"new name\";\nblock();\n\n// 打印结果是：\"person name = new name\"\n```\n\n在截获基本类型时，block内部可能会有`int capturedValue = value;`这样的代码，类比到指针也是一样的，block内部也会有这样的代码：`Person *capturedP = p;`。在ARC下，这其实是强引用(retain)了block外部的`p`。\n\n由于block内部的`p`和外部的`p`指向的是同一块内存地址。所以在block外部修改`p`的属性，依然会影响到block内部截获的`p`。不过这里的`p`依然不是可变的。修改`p`的`name`不是改变`p`，只是改变`p`内部的属性：\n\n```objc\nPerson *p = [[Person alloc] initWithName:@\"zxy\"];    \nvoid(^block)() = ^{\n\tp.name = @\"new name\"; //OK，没有改变p\n\tp = [[Person alloc] initWithName:@\"new name\"]; //编译错误\n    NSLog(@\"person name = %@\", p.name);\n};\n  \nblock();\n```\n\n### 改变指针\n\n类比`__block`修饰符对基本类型的作用原理，由它修饰的指针，在被block截获时，截获的其实是这个指针的指针。把刚刚的例子修改一下：\n\n```objc\n__block Person *p = [[Person alloc] initWithName:@\"zxy\"];    \nvoid(^block)() = ^{\n    NSLog(@\"person name = %@\", p.name);\n};\n    \np = nil;\nblock();\n\n// 打印结果是：\"person name = (null)\"\n```\n\n此时，block内部有一个指向外部的`p`的指针,一旦`p`被设为`nil`，这个内部的指针就指向了`nil`。所以打印结果就是`null`了。\n\n### __block与强引用\n\n还记得以前有一次面试时被问到，`__block`会不会`retain`变量？答案是：会的。从原理上分析，`__block`修饰的变量被封装在结构体中，block内部持有对这个结构体的强引用。这一点不管是对于基本类型还是指针都是通用的。从实际例子上来说：\n\n```objc\nBlock block;\nif (true) {\n    __block Person *p = [[Person alloc] initWithName:@\"zxy\"];\n    block = ^{\n        NSLog(@\"person name = %@\", p.name);\n    };\n}\nblock();\n\n// 打印结果是：\"person name = zxy\"\n```\n\n如果没有`retain`被标记为`__block`的指针`p`，那么超出作用于后应该会得到`nil`。不过这样的代码不会导致循环引用，因为稍后`block`也会被释放。\n\n### 避免循环引用\n\n不管对象是否标记为`__block`,一旦block截获了它，就会强引用它。所以，判断是否发生循环引用，只要判断block截获的对象，是否也持有block即可。如果这个对象确实需要直接或间接持有block，那么就需要避免block强引用这个对象。解决办法是使用`__weak`修饰符。\n\n```objc\n// block是self的一个属性\n\nid __weak weakSelf = self;\nblock = ^{\n\t//使用weakSelf代替self\n};\n```\n\nblock不会强引用被标记为`__weak`的对象，只会对其产生弱引用。为了防止在block内的操作会释放`wself`,可以先强引用它。这种做法有一个很漂亮的名字叫`weak-strong dacne`，具体实现方法可以参考RAC的`@strongify`和`@weakify`。\n\n### OC中block总结\n\n简单来说，除非标记为`__weak`，block总是会强引用任何捕获的对象。而`__block`表示捕获的就是指针本身,而非另一个指向这个对象的指针。也就是说，被`__block`修饰的对象在block内、外的改动会互相影响。\n\n如果想避免循环引用问题，首先要确定block引用了哪些对象，然后判断这些对象是否直接或间接持有block，如果有的话把这些对象标记为`__weak`避免block强引用它。\n\n# Swift的闭包\n               \nOC中的`__block`是一个很讨厌的修饰符。它不仅不容易理解，而且在ARC和非ARC的表现截然不同。`__block`修饰符本质上是通过截获变量的指针来达到在闭包内修改被截获的变量的目的。\n\n在Swift中，这叫做截获变量的引用。闭包默认会截取变量的引用，也就是说所有变量默认情况下都是加了`__block`修饰符的。\n\n```swift\nvar x = 42\nlet f = {\n\t// [x] in //如果取消注释，结果是42\n    print(x)\n}\nx = 43\nf() // 结果是43\n```\n\n如果如果被截获的变量是引用，和OC一样，那么在闭包内部有一个引用的引用：\n\n```swift\nvar block2: (() -> ())?\nif true {\n    var a: A? = A()\n    block2 = {\n        print(a?.name)\n    }\n    a = A(name: \"new name\")\n}\nblock2?() //结果是：\"Optional(\"new name\")\"\n```\n\n如果把变量写在截获列表中，那么block内部会有一个指向对象的强引用，这和在OC中什么都不写的效果是一样的：\n\n```swift\nvar block2: (() -> ())?\nif true {\n    var a: A? = A()\n    block2 = {\n        [a] in\n        print(a?.name)\n    }\n    a = A(name: \"new name\")\n}\nblock2?() //结果是：\"Optional(\"old name\")\"\n```\n               \nSwift会自动持有被截获的变量的引用，这样就可以在block内部直接修改变量。不过在一些特殊情况下，Swift会做一些优化。通过之前OC中对`__block`的分析可以看到，持有变量的引用肯定比直接持有变量开销更大。所以Swift会自动判断你是否在闭包中或闭包外改变了变量。如果没有改变，闭包会直接持有变量，即使你没有显式的把它卸载捕获列表中。下面这句话截取自[Swift官方文档](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94)：\n\n> As an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by or outside a closure.\n\n### Swift循环引用\n\n不管是否显示的把变量写进捕获列表，闭包都会对对象有强引用。如果闭包是某个对象的属性，而且闭包中截获了对象本身，或对象的某个属性，就会导致循环引用。这和OC中是完全一样的。解决方法是在捕获列表中把被截获的变量标记为`weak`或`unowned`。\n\n关于Swift的循环引用，有一个需要注意的例子：\n\n```swift\nclass A {\n    var name: String = \"A\"\n    var block: (() -> ())?\n    \n    //其他方法\n}\n\nvar a: A? = A()\nvar block = {\n    print(a?.name)\n}\na?.block = block\na = nil\nblock()\n```\n\n我们先创建了可选类型的变量`a`，然后创建一个闭包变量，并把它赋值给`a`的`block`属性。这个闭包内部又会截获`a`，那这样是否会导致循环引用呢？\n\n答案是否定的。虽然从表面上看，对象的闭包属性截获了对象本身。但是如果你运行上面这段代码，你会发现对象的`deinit`方法确实被调用了，打印结果不是“A”而是“nil”。\n\n这是因为我们忽略了可选类型这个因素。这里的`a`不是A类型的对象，而是一个可选类型变量，其内部封装了A的实例对象。闭包截获的是可选类型变量`a`，当你执行`a = nil`时，并不是释放了变量`a`，而是释放了`a`中包含的A类型实例对象。所以A的`deinit`方法会执行，当你调用block时，由于使用了可选链，就会得到`nil`，如果使用强制解封，程序就会崩溃。\n\n如果想要人为造成循环引用，代码要这样写：\n\n```swift\nvar block: (() -> ())?\nif true {\n    var a = A()\n    block = {\n        print(a.name)\n    }\n    a.name = \"New Name\"\n}\nblock!()\n```\n\n### Weak-Strong Dance\n\n为了避免`weak`变量在闭包中提前被释放，我们需要在block一开始强引用它。这在OC部分已经讲过如何使用了。Swift中实现Weak-Strong Dance一般有三种方法。分别是最简单的`if let`可选绑定、标准库的`withExtendedLifetime `方法和自定义的`withExtendedLifetime `方法。\n\n# 总结\n\n1. OC中默认截获变量，Swift默认截获变量的引用。它们都会强引用被截获的变量。\n2. Swift中没有`__block`修饰符，但是多了截获列表。通过把截获的变量标记为`weak`避免引用循环\n3. 两者都有Weak-Strong Dance，不过这一点上OC的写法更简单。\n4. 在使用可选类型时，要明确闭包截获了可选类型还是实例变量。这样才能正确判断是否发生循环引用。","html":"<h1 id=\"ocblock\">OC的block</h1>\n\n<p>OC的block已经有很多相关的文章介绍了，主要难点在于<code>__block</code>修饰符的作用和原理，以及循环引用问题。首先看一看<code>__block</code>修饰符，最后分析循环引用问题。这里的讨论都是基于ARC的。</p>\n\n<h3 id=\"\">截获基本类型</h3>\n\n<pre><code class=\"language-objc\">int value = 10;  \nvoid(^block)() = ^{  \n    NSLog(@\"value = %d\", value);\n};\nvalue = 20;  \nblock();\n\n// 打印结果是：\"value = 10\"\n</code></pre>\n\n<p>OC的block会截获外部变量，对于<code>int</code>等基本数据类型，block的内部会拷贝一份，简单来说，它的实现大概是这样的：</p>\n\n<pre><code class=\"language-objc\">struct block_impl {  \n    //其它内容\n    int value;\n};\n</code></pre>\n\n<p>因为block内部拷贝了截获的变量的副本，所以生成block后再修改变量，不会影响被block截获的变量。同时block内部也不能修改这个变量。</p>\n\n<h3 id=\"\">修改基本类型</h3>\n\n<p>如果要想在block中修改被截获的基本类型变量，需要把它标记为<code>__block</code>：</p>\n\n<pre><code class=\"language-objc\">__block int value = 10;  \nvoid(^block)() = ^{  \n    NSLog(@\"value = %d\", value);\n};\nvalue = 20;  \nblock();\n\n// 打印结果是：\"value = 20\"\n</code></pre>\n\n<p>这是因为，对于被标记了<code>__block</code>的变量，block在截获它时，会保存一个指针。简单来说，它的实现大概是这样的：</p>\n\n<pre><code class=\"language-objc\">struct block_impl {  \n    //其它内容\n    block_ref_value *value;\n};\n\nstruct block_ref_value {  \n    int value; // 这里保存的才是被截获的value的值。\n};\n</code></pre>\n\n<p>由于block中一直有一个指针指向value，所以block内部对它的修改，可以影响到block外部的变量。因为block修改的就是那个外部变量而不是外部变量的副本。</p>\n\n<p>上面关于block具体实现的例子只是一个简化模型，事实上并非如此，但本质类似。总的来说，只有由<code>__block</code>修饰符修饰的基本类型变量，在被block截获时才是可变的。关于这方面的详细解释，可以参考这三篇文章：</p>\n\n<ul>\n<li><a href=\"http://www.jianshu.com/p/e23078c11518\">iOS OC语言: Block底层实现原理</a>：这个很详细地讲了<code>__block</code>的实现原理</li>\n<li><a href=\"http://blog.csdn.net/wildfireli/article/details/22063001\">Block的引用循环问题 (ARC &amp; non-ARC)</a>：这个讲了一些block底层的实现原理以及循环引用问题。</li>\n<li><a href=\"http://blog.csdn.net/abc649395594/article/details/47086751\">你真的理解__block修饰符的原理么？</a>：这是我之前写过的一篇介绍<code>__block</code>原理的文章，内容会详细一些。</li>\n</ul>\n\n<h3 id=\"\">截获指针</h3>\n\n<p>block截获指针和截获基本类型是相似的，不过稍稍复杂一些。这是一个最简单的例子。</p>\n\n<pre><code class=\"language-objc\">Person *p = [[Person alloc] initWithName:@\"zxy\"];  \nvoid(^block)() = ^{  \n    NSLog(@\"person name = %@\", p.name);\n};\n\np.name = @\"new name\";  \nblock();\n\n// 打印结果是：\"person name = new name\"\n</code></pre>\n\n<p>在截获基本类型时，block内部可能会有<code>int capturedValue = value;</code>这样的代码，类比到指针也是一样的，block内部也会有这样的代码：<code>Person *capturedP = p;</code>。在ARC下，这其实是强引用(retain)了block外部的<code>p</code>。</p>\n\n<p>由于block内部的<code>p</code>和外部的<code>p</code>指向的是同一块内存地址。所以在block外部修改<code>p</code>的属性，依然会影响到block内部截获的<code>p</code>。不过这里的<code>p</code>依然不是可变的。修改<code>p</code>的<code>name</code>不是改变<code>p</code>，只是改变<code>p</code>内部的属性：</p>\n\n<pre><code class=\"language-objc\">Person *p = [[Person alloc] initWithName:@\"zxy\"];  \nvoid(^block)() = ^{  \n    p.name = @\"new name\"; //OK，没有改变p\n    p = [[Person alloc] initWithName:@\"new name\"]; //编译错误\n    NSLog(@\"person name = %@\", p.name);\n};\n\nblock();  \n</code></pre>\n\n<h3 id=\"\">改变指针</h3>\n\n<p>类比<code>__block</code>修饰符对基本类型的作用原理，由它修饰的指针，在被block截获时，截获的其实是这个指针的指针。把刚刚的例子修改一下：</p>\n\n<pre><code class=\"language-objc\">__block Person *p = [[Person alloc] initWithName:@\"zxy\"];  \nvoid(^block)() = ^{  \n    NSLog(@\"person name = %@\", p.name);\n};\n\np = nil;  \nblock();\n\n// 打印结果是：\"person name = (null)\"\n</code></pre>\n\n<p>此时，block内部有一个指向外部的<code>p</code>的指针,一旦<code>p</code>被设为<code>nil</code>，这个内部的指针就指向了<code>nil</code>。所以打印结果就是<code>null</code>了。</p>\n\n<h3 id=\"__block\">__block与强引用</h3>\n\n<p>还记得以前有一次面试时被问到，<code>__block</code>会不会<code>retain</code>变量？答案是：会的。从原理上分析，<code>__block</code>修饰的变量被封装在结构体中，block内部持有对这个结构体的强引用。这一点不管是对于基本类型还是指针都是通用的。从实际例子上来说：</p>\n\n<pre><code class=\"language-objc\">Block block;  \nif (true) {  \n    __block Person *p = [[Person alloc] initWithName:@\"zxy\"];\n    block = ^{\n        NSLog(@\"person name = %@\", p.name);\n    };\n}\nblock();\n\n// 打印结果是：\"person name = zxy\"\n</code></pre>\n\n<p>如果没有<code>retain</code>被标记为<code>__block</code>的指针<code>p</code>，那么超出作用于后应该会得到<code>nil</code>。不过这样的代码不会导致循环引用，因为稍后<code>block</code>也会被释放。</p>\n\n<h3 id=\"\">避免循环引用</h3>\n\n<p>不管对象是否标记为<code>__block</code>,一旦block截获了它，就会强引用它。所以，判断是否发生循环引用，只要判断block截获的对象，是否也持有block即可。如果这个对象确实需要直接或间接持有block，那么就需要避免block强引用这个对象。解决办法是使用<code>__weak</code>修饰符。</p>\n\n<pre><code class=\"language-objc\">// block是self的一个属性\n\nid __weak weakSelf = self;  \nblock = ^{  \n    //使用weakSelf代替self\n};\n</code></pre>\n\n<p>block不会强引用被标记为<code>__weak</code>的对象，只会对其产生弱引用。为了防止在block内的操作会释放<code>wself</code>,可以先强引用它。这种做法有一个很漂亮的名字叫<code>weak-strong dacne</code>，具体实现方法可以参考RAC的<code>@strongify</code>和<code>@weakify</code>。</p>\n\n<h3 id=\"ocblock\">OC中block总结</h3>\n\n<p>简单来说，除非标记为<code>__weak</code>，block总是会强引用任何捕获的对象。而<code>__block</code>表示捕获的就是指针本身,而非另一个指向这个对象的指针。也就是说，被<code>__block</code>修饰的对象在block内、外的改动会互相影响。</p>\n\n<p>如果想避免循环引用问题，首先要确定block引用了哪些对象，然后判断这些对象是否直接或间接持有block，如果有的话把这些对象标记为<code>__weak</code>避免block强引用它。</p>\n\n<h1 id=\"swift\">Swift的闭包</h1>\n\n<p>OC中的<code>__block</code>是一个很讨厌的修饰符。它不仅不容易理解，而且在ARC和非ARC的表现截然不同。<code>__block</code>修饰符本质上是通过截获变量的指针来达到在闭包内修改被截获的变量的目的。</p>\n\n<p>在Swift中，这叫做截获变量的引用。闭包默认会截取变量的引用，也就是说所有变量默认情况下都是加了<code>__block</code>修饰符的。</p>\n\n<pre><code class=\"language-swift\">var x = 42  \nlet f = {  \n    // [x] in //如果取消注释，结果是42\n    print(x)\n}\nx = 43  \nf() // 结果是43  \n</code></pre>\n\n<p>如果如果被截获的变量是引用，和OC一样，那么在闭包内部有一个引用的引用：</p>\n\n<pre><code class=\"language-swift\">var block2: (() -&gt; ())?  \nif true {  \n    var a: A? = A()\n    block2 = {\n        print(a?.name)\n    }\n    a = A(name: \"new name\")\n}\nblock2?() //结果是：\"Optional(\"new name\")\"  \n</code></pre>\n\n<p>如果把变量写在截获列表中，那么block内部会有一个指向对象的强引用，这和在OC中什么都不写的效果是一样的：</p>\n\n<pre><code class=\"language-swift\">var block2: (() -&gt; ())?  \nif true {  \n    var a: A? = A()\n    block2 = {\n        [a] in\n        print(a?.name)\n    }\n    a = A(name: \"new name\")\n}\nblock2?() //结果是：\"Optional(\"old name\")\"  \n</code></pre>\n\n<p>Swift会自动持有被截获的变量的引用，这样就可以在block内部直接修改变量。不过在一些特殊情况下，Swift会做一些优化。通过之前OC中对<code>__block</code>的分析可以看到，持有变量的引用肯定比直接持有变量开销更大。所以Swift会自动判断你是否在闭包中或闭包外改变了变量。如果没有改变，闭包会直接持有变量，即使你没有显式的把它卸载捕获列表中。下面这句话截取自<a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94\">Swift官方文档</a>：</p>\n\n<blockquote>\n  <p>As an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by or outside a closure.</p>\n</blockquote>\n\n<h3 id=\"swift\">Swift循环引用</h3>\n\n<p>不管是否显示的把变量写进捕获列表，闭包都会对对象有强引用。如果闭包是某个对象的属性，而且闭包中截获了对象本身，或对象的某个属性，就会导致循环引用。这和OC中是完全一样的。解决方法是在捕获列表中把被截获的变量标记为<code>weak</code>或<code>unowned</code>。</p>\n\n<p>关于Swift的循环引用，有一个需要注意的例子：</p>\n\n<pre><code class=\"language-swift\">class A {  \n    var name: String = \"A\"\n    var block: (() -&gt; ())?\n\n    //其他方法\n}\n\nvar a: A? = A()  \nvar block = {  \n    print(a?.name)\n}\na?.block = block  \na = nil  \nblock()  \n</code></pre>\n\n<p>我们先创建了可选类型的变量<code>a</code>，然后创建一个闭包变量，并把它赋值给<code>a</code>的<code>block</code>属性。这个闭包内部又会截获<code>a</code>，那这样是否会导致循环引用呢？</p>\n\n<p>答案是否定的。虽然从表面上看，对象的闭包属性截获了对象本身。但是如果你运行上面这段代码，你会发现对象的<code>deinit</code>方法确实被调用了，打印结果不是“A”而是“nil”。</p>\n\n<p>这是因为我们忽略了可选类型这个因素。这里的<code>a</code>不是A类型的对象，而是一个可选类型变量，其内部封装了A的实例对象。闭包截获的是可选类型变量<code>a</code>，当你执行<code>a = nil</code>时，并不是释放了变量<code>a</code>，而是释放了<code>a</code>中包含的A类型实例对象。所以A的<code>deinit</code>方法会执行，当你调用block时，由于使用了可选链，就会得到<code>nil</code>，如果使用强制解封，程序就会崩溃。</p>\n\n<p>如果想要人为造成循环引用，代码要这样写：</p>\n\n<pre><code class=\"language-swift\">var block: (() -&gt; ())?  \nif true {  \n    var a = A()\n    block = {\n        print(a.name)\n    }\n    a.name = \"New Name\"\n}\nblock!()  \n</code></pre>\n\n<h3 id=\"weakstrongdance\">Weak-Strong Dance</h3>\n\n<p>为了避免<code>weak</code>变量在闭包中提前被释放，我们需要在block一开始强引用它。这在OC部分已经讲过如何使用了。Swift中实现Weak-Strong Dance一般有三种方法。分别是最简单的<code>if let</code>可选绑定、标准库的<code>withExtendedLifetime</code>方法和自定义的<code>withExtendedLifetime</code>方法。</p>\n\n<h1 id=\"\">总结</h1>\n\n<ol>\n<li>OC中默认截获变量，Swift默认截获变量的引用。它们都会强引用被截获的变量。  </li>\n<li>Swift中没有<code>__block</code>修饰符，但是多了截获列表。通过把截获的变量标记为<code>weak</code>避免引用循环  </li>\n<li>两者都有Weak-Strong Dance，不过这一点上OC的写法更简单。  </li>\n<li>在使用可选类型时，要明确闭包截获了可选类型还是实例变量。这样才能正确判断是否发生循环引用。</li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:18:06.000Z","created_by":1,"updated_at":"2016-01-28T16:31:50.000Z","updated_by":1,"published_at":"2015-12-26T08:18:00.000Z","published_by":1},{"id":13,"uuid":"df7854f6-a907-4354-80b8-bdcbec9453e3","title":"我的2015年总结","slug":"wo-de-2015nian-zong-jie","markdown":"我一直认为，对于程序员来说，写一天代码不算什么，也许这只是解决了一个bug，或者干脆就没能搞定。一周的时间学习内容页有限，可能是一两个困扰已久的知识点终于悟透了，也可能是新学了某个知识点。但是和一个月前的自己相比，总是感觉自己进步颇大，和一年前的自己相比，就有一种判若两人的感觉了。2015就要过去了，我想有必要总结一下这一年来的收获得失。\n\n# 从小白开始\n\n从去年年底正式开始写iOS开始，到大约三四月份，一直在开发自己的第一个iOS应用，现在回顾那段时间的博客，主要是关于UI方面的总结，以及一些常见错误的解决方法。在这个过程中了解了怎么处理HTTP请求和Json解析(没错，当时还不知道HTTP请求是什么)，图片的异步加载与缓存，`UIScrollview`和`UITableView`这些稍微“高端”一些的UI控件。也开始接触了定时器、内存管理等知识。APP上架以后我就天真的以为自己已经把iOS学得差不多了。\n\n# 第一次失败\n\n五月份的时候做过两个小的项目，一个APP上架(广告赚了将近200)，一个Xcode插件在Github，然后兴冲冲的去面了一家公司。待遇是12K+包吃住，虽然也没觉得自己达到这个水平，不过真正到了第二轮被拒的时候还是有一些小伤感。面试虽然没过，却还是有些收获：\n\n1. 逐渐开始过渡到用Google查资料，平时关注Objc.io并RSS订阅各个大牛的技术博客，偶尔在StackOverflow提个问题。总的来说就是层次提高了，获取知识的来源拓宽了。这一点至今让我受益匪浅。\n\n2. 关于UI方面的一些细节，以前做项目，只想着效果OK就可以，面试官问我怎么处理图片的拉伸问题我就一问三不知。还有一些比较底层的知识，比如`CoreGraphis`、`CoreAnimation`等也是之前欠缺的。\n\n3. 以前只会嘴上喊MVC模式，实际代码中VC负责一切。被面试官一下子问个正着。现在严格遵循MVC模式，而且学习了MVVM模式，写了几篇分析ReactiveCocoa源码的文章：[ReactiveCocoa详解](http://blog.csdn.net/column/details/reactivecocoa.html)。可惜对函数式编程的思想还是不够熟练，在项目中用了一两次之后就暂时搁置了，听说美团在用RAC。\n\n# 第二次失败\n\n面试结束后，把面试过程中遇到的问题总结了一下，又投了一份简历。可能是运气不错，我准备的问题被问到了好几个，也有可能是那个创业公司比较缺人，所以成功的拿到了Offer。当时谈了400一天，后来因为晚上加班，最后实际给了440一天（大二就月入过万了，当时还是有点小骄傲）。六月份开始入职，但是问题来的比工资快。现在想来主要是这几点：\n\n1. 不适应身份的转变。企业是企业，学校是学校，在学校的团队里，自己是技术leader同时还身兼产品经理。自己定好需求再实现。但是在公司里，产品经理的需求一日三变，写完的代码leader看技术实现，产品经理看效果，美工检查UI布局。由于以前基础太不扎实，态度也比较敷衍，所以这么一来漏洞百出，顾此失彼。\n\n2. 心态不够好。刚开始干劲十足，但总是被PM改需求，被leader批评。后来慢慢的也有些失望，甚至是抵触。其中的过程比较复杂，至今也不太能理清楚，\n\n总的来说，第二次失败的原因有两个。一是自己技术水平不够，这里有代码规范问题也有iOS开发上的问题，二是太以自我为中心，如果当时能多站在公司的角度考虑问题，也许情况就不是那样。后来和公司的关系越来越僵，最后九月初选择了提前离职，回到学校继续钻研技术。\n\n回到学校之后的整整两个月都没有看技术。半主动离职让我开始怀疑自己，虽然对公司的领导、氛围小有愤懑，但毕竟自己的问题更加严重。于是选择了逃避，每天玩游戏、看电影，甚至去大连旅游了一趟。回家呆了一段时间，再回学校已经是11月，感觉逃避也不是办法，只是还是要一点点学。\n\n# 读书\n\n15年读了不少好书，收益颇丰。实习期间看完了《Effective Objective-C 2.0》和《Objective-C高级编程》，对不少基础知识，比如ARC、block和GCD都有了更加深入的了解。\n\n实习的时候还看了一本《老码说编程之玩转Swift江湖》，当时Swift还是1.x版本。从这一点来说，我是个不合格的实习生。实习期间路上、晚上都在看书，导致白天精力不济。因为当时的思想还是利用实习期间多学技术，但创业公司要求的其实是实习生为他创造效益。\n\n11月读了《程序员的自我修养》，对程序的运行和操作系统有了更透彻的理解。读完之后写了一篇[读后感](http://bestswifter.com/blog/2015/12/22/cheng-xu-yuan-de-zi-wo-xiu-yang-du-shu-bi-ji/)。12月的Swift 2开源，感觉Swift是大势所趋，所以开始学习objc出版的\"Advanced Swift\"，同时自己也写了它的[中文翻译版](http://www.jianshu.com/p/18744b078508)，后来有人提醒我版权问题，所以已经暂停原文翻译了，后面的几篇文章都是对原文进行加工和总结后得出的。\n\n阅读和翻译英文书的收获非常大，对很多的知识的理解比直接阅读中文教程要深刻的多，同时也大幅度提高了自己阅读英文教程的能力。\n\n# 收获\n\n最大的收获，莫过于Swift的学习了，了解基本语法的同时，有机会也会自己看一下已经开源的部分的实现原理。\n\n磨刀不误砍柴工，我减少了很多写项目的时间，希望把基础知识弄扎实，因为很多bug往往来自于对某个概念的错误理解。与其一知半解的去解决bug，不如先掌握知识。所以在读书的同时，我也开始深入的思考iOS开发的一些基础知识：\n\n* AutoLayout和UIScrollview的联合使用\n* UIScrollview性能优化\n* GCD和NSOperationQueue\n* UIView的生命周期\n* Swift与OC在复制对象时的异同\n* Swift与OC闭包的异同\n\n感谢Google上的各种资料，我完成了自己的[Xcode插件](https://github.com/bestswifter/XcodeCareer-Plugin)，用来统计在Xcode中所有写过的代码行数和写代码时间，不过好像有隐藏的bug，后来也就不维护了。因为看过《程序员的自我修养》，对一些底层的知识有了浅显的了解，所以在Google的帮助下，自己破解了一款收费应用：[一个数字的魔法——破解Mac软件之旅](http://bestswifter.com/blog/2015/11/24/%5B%3F%5D-ge-shu-zi-de-mo-fa-po-jie-macruan-jian-zhi-lu/)\n\n仔细想想，其他乱七八糟的东西也学了不少，实习期间相当长的时间在做C++项目，写了一个静态库分别给OC和Java调用，所以也稍微了解了一下C++。发现了CSDN博客的一个bug，又去了解了一下Python，写了一个脚本把自己积分刷到了第一。学校有安卓的课，所以不得不写了个[安卓应用](https://github.com/bestswifter/MathModeling-Android)，也算是了解了一些简单的Java和安卓开发。年底的时候注册了现在用的这个域名，虽然注定要被打脸，但也希望能够鞭策自己吧。\n\n# 2016年的计划\n\n1. 文章要继续阅读和翻译英文书籍。目前Advanced Swift翻译了三分之二，一月份估计可以结束。下一个目标或许还是Objc的书：Core Data。事实上总是有读不完的好书的。\n\n2. 阅读优秀的博文。实际上今年2015年的很多时间浪费在一些低质量的文章上，不仅学不到知识，还把自己弄得晕头转向。NSHispter和Objc.io有非常多优秀的文章，足够在2016年好好拜读了。\n\n3. 技术与基础。有些知识点还没来得及学习，有些学过但是长期不用已经忘了，目前想到的涉及这几点：响应者链与事件处理、KVO、几种消息传递机制的比较、Runtime、NSUrlSession、CALayer等等等等。虽然要学的太多，不过一直很喜欢一句话：“怕什么真理无穷,进一寸有一寸的欢喜”。\n\n4. 大学期间就该做大学里该做的事，比如读书。目前想到的是《代码整洁之道》、《图解TCP/IP协议》，如果有空希望可以深入了解Mac与iOS操作系统。\n\n5. 实习。目前对创业公司有了一定了解，希望能够到一家大公司实习几个月。\n\n虽然任务浩繁，不过总得尽力完成，愿一年后的自己与现在判若两人！","html":"<p>我一直认为，对于程序员来说，写一天代码不算什么，也许这只是解决了一个bug，或者干脆就没能搞定。一周的时间学习内容页有限，可能是一两个困扰已久的知识点终于悟透了，也可能是新学了某个知识点。但是和一个月前的自己相比，总是感觉自己进步颇大，和一年前的自己相比，就有一种判若两人的感觉了。2015就要过去了，我想有必要总结一下这一年来的收获得失。</p>\n\n<h1 id=\"\">从小白开始</h1>\n\n<p>从去年年底正式开始写iOS开始，到大约三四月份，一直在开发自己的第一个iOS应用，现在回顾那段时间的博客，主要是关于UI方面的总结，以及一些常见错误的解决方法。在这个过程中了解了怎么处理HTTP请求和Json解析(没错，当时还不知道HTTP请求是什么)，图片的异步加载与缓存，<code>UIScrollview</code>和<code>UITableView</code>这些稍微“高端”一些的UI控件。也开始接触了定时器、内存管理等知识。APP上架以后我就天真的以为自己已经把iOS学得差不多了。</p>\n\n<h1 id=\"\">第一次失败</h1>\n\n<p>五月份的时候做过两个小的项目，一个APP上架(广告赚了将近200)，一个Xcode插件在Github，然后兴冲冲的去面了一家公司。待遇是12K+包吃住，虽然也没觉得自己达到这个水平，不过真正到了第二轮被拒的时候还是有一些小伤感。面试虽然没过，却还是有些收获：</p>\n\n<ol>\n<li><p>逐渐开始过渡到用Google查资料，平时关注Objc.io并RSS订阅各个大牛的技术博客，偶尔在StackOverflow提个问题。总的来说就是层次提高了，获取知识的来源拓宽了。这一点至今让我受益匪浅。</p></li>\n<li><p>关于UI方面的一些细节，以前做项目，只想着效果OK就可以，面试官问我怎么处理图片的拉伸问题我就一问三不知。还有一些比较底层的知识，比如<code>CoreGraphis</code>、<code>CoreAnimation</code>等也是之前欠缺的。</p></li>\n<li><p>以前只会嘴上喊MVC模式，实际代码中VC负责一切。被面试官一下子问个正着。现在严格遵循MVC模式，而且学习了MVVM模式，写了几篇分析ReactiveCocoa源码的文章：<a href=\"http://blog.csdn.net/column/details/reactivecocoa.html\">ReactiveCocoa详解</a>。可惜对函数式编程的思想还是不够熟练，在项目中用了一两次之后就暂时搁置了，听说美团在用RAC。</p></li>\n</ol>\n\n<h1 id=\"\">第二次失败</h1>\n\n<p>面试结束后，把面试过程中遇到的问题总结了一下，又投了一份简历。可能是运气不错，我准备的问题被问到了好几个，也有可能是那个创业公司比较缺人，所以成功的拿到了Offer。当时谈了400一天，后来因为晚上加班，最后实际给了440一天（大二就月入过万了，当时还是有点小骄傲）。六月份开始入职，但是问题来的比工资快。现在想来主要是这几点：</p>\n\n<ol>\n<li><p>不适应身份的转变。企业是企业，学校是学校，在学校的团队里，自己是技术leader同时还身兼产品经理。自己定好需求再实现。但是在公司里，产品经理的需求一日三变，写完的代码leader看技术实现，产品经理看效果，美工检查UI布局。由于以前基础太不扎实，态度也比较敷衍，所以这么一来漏洞百出，顾此失彼。</p></li>\n<li><p>心态不够好。刚开始干劲十足，但总是被PM改需求，被leader批评。后来慢慢的也有些失望，甚至是抵触。其中的过程比较复杂，至今也不太能理清楚，</p></li>\n</ol>\n\n<p>总的来说，第二次失败的原因有两个。一是自己技术水平不够，这里有代码规范问题也有iOS开发上的问题，二是太以自我为中心，如果当时能多站在公司的角度考虑问题，也许情况就不是那样。后来和公司的关系越来越僵，最后九月初选择了提前离职，回到学校继续钻研技术。</p>\n\n<p>回到学校之后的整整两个月都没有看技术。半主动离职让我开始怀疑自己，虽然对公司的领导、氛围小有愤懑，但毕竟自己的问题更加严重。于是选择了逃避，每天玩游戏、看电影，甚至去大连旅游了一趟。回家呆了一段时间，再回学校已经是11月，感觉逃避也不是办法，只是还是要一点点学。</p>\n\n<h1 id=\"\">读书</h1>\n\n<p>15年读了不少好书，收益颇丰。实习期间看完了《Effective Objective-C 2.0》和《Objective-C高级编程》，对不少基础知识，比如ARC、block和GCD都有了更加深入的了解。</p>\n\n<p>实习的时候还看了一本《老码说编程之玩转Swift江湖》，当时Swift还是1.x版本。从这一点来说，我是个不合格的实习生。实习期间路上、晚上都在看书，导致白天精力不济。因为当时的思想还是利用实习期间多学技术，但创业公司要求的其实是实习生为他创造效益。</p>\n\n<p>11月读了《程序员的自我修养》，对程序的运行和操作系统有了更透彻的理解。读完之后写了一篇<a href=\"http://bestswifter.com/blog/2015/12/22/cheng-xu-yuan-de-zi-wo-xiu-yang-du-shu-bi-ji/\">读后感</a>。12月的Swift 2开源，感觉Swift是大势所趋，所以开始学习objc出版的\"Advanced Swift\"，同时自己也写了它的<a href=\"http://www.jianshu.com/p/18744b078508\">中文翻译版</a>，后来有人提醒我版权问题，所以已经暂停原文翻译了，后面的几篇文章都是对原文进行加工和总结后得出的。</p>\n\n<p>阅读和翻译英文书的收获非常大，对很多的知识的理解比直接阅读中文教程要深刻的多，同时也大幅度提高了自己阅读英文教程的能力。</p>\n\n<h1 id=\"\">收获</h1>\n\n<p>最大的收获，莫过于Swift的学习了，了解基本语法的同时，有机会也会自己看一下已经开源的部分的实现原理。</p>\n\n<p>磨刀不误砍柴工，我减少了很多写项目的时间，希望把基础知识弄扎实，因为很多bug往往来自于对某个概念的错误理解。与其一知半解的去解决bug，不如先掌握知识。所以在读书的同时，我也开始深入的思考iOS开发的一些基础知识：</p>\n\n<ul>\n<li>AutoLayout和UIScrollview的联合使用</li>\n<li>UIScrollview性能优化</li>\n<li>GCD和NSOperationQueue</li>\n<li>UIView的生命周期</li>\n<li>Swift与OC在复制对象时的异同</li>\n<li>Swift与OC闭包的异同</li>\n</ul>\n\n<p>感谢Google上的各种资料，我完成了自己的<a href=\"https://github.com/bestswifter/XcodeCareer-Plugin\">Xcode插件</a>，用来统计在Xcode中所有写过的代码行数和写代码时间，不过好像有隐藏的bug，后来也就不维护了。因为看过《程序员的自我修养》，对一些底层的知识有了浅显的了解，所以在Google的帮助下，自己破解了一款收费应用：<a href=\"http://bestswifter.com/blog/2015/11/24/%5B%3F%5D-ge-shu-zi-de-mo-fa-po-jie-macruan-jian-zhi-lu/\">一个数字的魔法——破解Mac软件之旅</a></p>\n\n<p>仔细想想，其他乱七八糟的东西也学了不少，实习期间相当长的时间在做C++项目，写了一个静态库分别给OC和Java调用，所以也稍微了解了一下C++。发现了CSDN博客的一个bug，又去了解了一下Python，写了一个脚本把自己积分刷到了第一。学校有安卓的课，所以不得不写了个<a href=\"https://github.com/bestswifter/MathModeling-Android\">安卓应用</a>，也算是了解了一些简单的Java和安卓开发。年底的时候注册了现在用的这个域名，虽然注定要被打脸，但也希望能够鞭策自己吧。</p>\n\n<h1 id=\"2016\">2016年的计划</h1>\n\n<ol>\n<li><p>文章要继续阅读和翻译英文书籍。目前Advanced Swift翻译了三分之二，一月份估计可以结束。下一个目标或许还是Objc的书：Core Data。事实上总是有读不完的好书的。</p></li>\n<li><p>阅读优秀的博文。实际上今年2015年的很多时间浪费在一些低质量的文章上，不仅学不到知识，还把自己弄得晕头转向。NSHispter和Objc.io有非常多优秀的文章，足够在2016年好好拜读了。</p></li>\n<li><p>技术与基础。有些知识点还没来得及学习，有些学过但是长期不用已经忘了，目前想到的涉及这几点：响应者链与事件处理、KVO、几种消息传递机制的比较、Runtime、NSUrlSession、CALayer等等等等。虽然要学的太多，不过一直很喜欢一句话：“怕什么真理无穷,进一寸有一寸的欢喜”。</p></li>\n<li><p>大学期间就该做大学里该做的事，比如读书。目前想到的是《代码整洁之道》、《图解TCP/IP协议》，如果有空希望可以深入了解Mac与iOS操作系统。</p></li>\n<li><p>实习。目前对创业公司有了一定了解，希望能够到一家大公司实习几个月。</p></li>\n</ol>\n\n<p>虽然任务浩繁，不过总得尽力完成，愿一年后的自己与现在判若两人！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:19:27.000Z","created_by":1,"updated_at":"2016-01-28T16:31:32.000Z","updated_by":1,"published_at":"2015-12-31T08:19:00.000Z","published_by":1},{"id":14,"uuid":"ec4a9dc8-7ebb-4948-b130-3669b7700b0b","title":"Swift实现多线程map函数","slug":"parallelmap","markdown":"SequenceType协议中定义的`map`函数功能很强大，这个函数起源于函数式编程，能够很方便的对数组中的每个元素进行变换处理，关于它的实现原理和使用方法可以参考我的这篇文章：[Swift数组变换](http://www.jianshu.com/p/7b1bb303ec45)。今天突然想到，如果数组非常大，`map`方法会不会出现性能问题？如果使用多线程技术是否可以提高`map`方法的执行效率？带着这样的问题，我开始了本次实(zuo)验(si)。项目的demo在我的github：[ParallelMap](https://github.com/bestswifter/MySampleCode/tree/master/ParallelMap)，如果觉得不错还请随手点一个star😊\n\n# 第一次尝试\n\n虽然问题有些复杂，不过解决复杂的问题总是从处理简单问题开始的，我尝试直接使用异步多线程来处理：\n\n```swift\nextension Array {\n    func kt_map<T>(transform: (Element) -> T) -> [T] {\n\t    let asyncQueue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_CONCURRENT)\n        var result: [T] = []\n        \n        dispatch_async(asyncQueue) { () -> Void in\n            result = self.map(transform)\n        }\n        return result\n    }\n}\n\nlet test = [1,2,3,4,5,6,7,8,9]\nlet result = kt_map { $0 * 2}\nprint(result) \t// 输出结果： []\n```\n\n这显然是一个错的离谱的实现，最主要问题在于异步调用`self.map`方法后，没有等`result`变量被赋值就直接返回了(其实就是水平差)。不过，从第一次尝试中还是大概明确了方向，得出以下几个结论：\n\n1. 方法内部肯定要用到多线程，但整体来说必须是同步的。必须等所有变换都执行结束，才能返回结果，Swift的`map`方法也是这么做的。\n\n2. 因为方法是同步的，即使在方法内部新开一个线程，调用`self.map`，也不会节省任何时间，反而会因为线程切换浪费大量的时间。\n\n3. 解决问题的思路应该是把数组拆成若干部分，在不同的线程中对不同的部分进行变换，最后再合并起来作为返回值。\n\n\n# 第二次尝试\n\n带着第一次尝试的收获，我开始了第二次尝试，这次代码比之前复杂一些，先上代码，标记数字的地方下面会有详细介绍：\n\n```swift\nfunc ktMap<T>(transform: (Element) -> T) -> [T] { // 1\n    guard !self.isEmpty else { return [] }  // 如果数组为空就直接返回空数组\n    \n    var result: [(Int, [T])] = []   // 2\n    let group = dispatch_group_create()\n    \n    // 3\n    let subArrayLength: Int = max(1, self.count / NSProcessInfo.processInfo().activeProcessorCount / 2)\n    \n    for var step = 0; step * subArrayLength < self.count; step++ {\n        var stepResult: [T] = []\n        // 4\n        dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {\n            for i in (step * subArrayLength)..<((step + 1) * subArrayLength) {\n                stepResult += [transform(self[i])]\n            }\n            result += [(step, stepResult)]\n        }\n    }\n    \n    dispatch_group_wait(group, DISPATCH_TIME_FOREVER)    // 5\n    return result.sort { $0.0 < $1.0 }.flatMap { $0.1 }    // 6\n}\n```\n\n1. 如果可以的话，我肯定仿照Swift对`map`方法的实现，把`transform `闭包声明为`@noescape`，可惜在GCD中要调用这个闭包，只能作罢。关于`@noescape`关键字的优点和限制，可以参考我的这篇博客：[自动闭包和noescape](http://www.jianshu.com/p/f9ba4c41d9c7)。\n\n2. `result`是一个元组的数组。元组中第二个元素是`self`的子数组，第一个元素是这个子数组的序号。比如数组`[1,2,3,4,5,6]`有可能在`result`中表示为`[(0, [1,2,3]), (1, [4,5,6])]`。之所以这样拆分，是因为我要在多线程中分别处理每个子数组，最后再把他们合并成原来的数组。\n\n3. `subArrayLength `表示每个子数组的长度。在整个除法表达式中，我们首先除以当前活跃的处理器核数，以iPhone6的A8处理器为例，它是双核的。因为一个核心对应两个线程，我希望能够在每个线程中处理一个子数组，所以又除以了2。其实这样做没有必要，因为不管我们在程序中开了多少个异步线程，真正对应到CPU的线程的过程是由GCD控制的。这就是操作系统中的“多对多”线程模型。不管怎么说，我们算出了每个子数组的长度。\n\n4. 接下来是一个循环，在每一步中我们异步的执行一些操作（这些操作会在新线程里执行）。`stepResult`是一个子数组，用于存储这一段元素的变换结果。变换结束后，把`step`和`stepResult `分别作为元组的第一、二个元素，存入`result `数组中\n\n5. 调用`dispatch_group_wait `，这样我们会一直等到所有`group`中的方法结束后，才执行下面的代码。因为之前所有的任务都是放在`group `中执行的，所以这就保证了整个`ktMap`方法是同步的。\n\n6. 首先根据元组的第一个元素，也就是子数组序号排序，接着调用`flatMap`方法把其中的数组提取出来。关于`sort`和`flatMap`方法的用法，同样可以参考我的这篇文章：[Swift数组变换](http://www.jianshu.com/p/7b1bb303ec45)。\n\n方法实现完了以后，再次调用它，查看结果。可怜的是还不如以前，这次直接崩溃了。根据崩溃提示，问题主要出在这一段：\n\n```swift\ndispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {\n    for i in (step * subArrayLength)..<((step + 1) * subArrayLength) {\n        stepResult += [transform(self[i])]\n    }\n    result += [(step, stepResult)]\n}\n```\n\n# 第三次尝试\n\n我在异步方法中向数组`result `添加新的元素，这样是很危险的。准确的说是程序几乎必定崩溃，具体原因可以参考这篇文章：[Swift数组扩容原理](http://www.jianshu.com/p/2fce6a0bb17b)。正确的做法是加一个锁，保证每次只有一个添加元素的操作在执行。另一种常见的方案是使用同步队列，它可以保证队列中所有的任务依次进行。\n\n另一个问题在于，在最外层的for循环中，step变量表示当前是第几步。它随着循环的进行，不断自增。如果在循环内部总是使用`step`，就有可能获取到错误的`step`值。这一点也要格外重视，在平时的编程中，for循环总是同步的，当前循环不结束就不会开始下一个循环。在多线程编程中就完全不是这样，循环内部调用了异步方法，所以每个循环会非常快的结束。正确的做法是在循环内部用一个临时常量保存`step`的值。\n\n最后一个问题是处理每一段子数组时，它的长度总是固定的，也就是`subArrayLength `的值。但是在处理最后一个子数组时可能导致下标越界，即使没有越界，这些操作也是多余的。\n\n\n解决这三个问题后，我完成了最终的`map`方法实现，具体的解释在下面：\n\n```swift\nfunc ktMap<T>(transform: (Element) -> T) -> [T] {\n    guard !self.isEmpty else { return [] }  // 如果数组为空就直接返回空数组\n    \n    var result: [(Int, [T])] = []\n    let group = dispatch_group_create()\n    let mutex = dispatch_semaphore_create(1)    // 1\n    let syncQueue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_SERIAL)    // 2\n    \n    let subArrayLength: Int = max(1, self.count / NSProcessInfo.processInfo().activeProcessorCount / 2)\n    \n    for var step = 0; step * subArrayLength < self.count; step++ {\n        let localStep = step\t// 3\n        var stepResult: [T] = []\n\n        dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {\n        \t// 4\n            for i in (localStep * subArrayLength)..<min(((localStep + 1) * subArrayLength), self.count) {\n                stepResult += [transform(self[i])]\n            }\n            \n            // 5\n            dispatch_semaphore_wait(mutex, DISPATCH_TIME_FOREVER)\n            result += [(localStep, stepResult)]\n            dispatch_semaphore_signal(mutex)\n            \n            // 6\n//          dispatch_group_async(group, syncQueue) {\n//              result += [(localStep, stepResult)]\n//          }\n        }\n    }\n    \n    dispatch_group_wait(group, DISPATCH_TIME_FOREVER)\n    return result.sort { $0.0 < $1.0 }.flatMap { $0.1 }\n}\n```\n\n1. 使用互斥锁保证不会有多个数组添加元素的操作同时进行\n2. 同步队列也是一种解决方式\n3. 在for循环体中用一个常量保存下来当前的`step`值，后面用`localStep `替代所有的`step`\n4. 数组的右边界进行一个判断，最多不超过`self.count`\n5. 这是使用互斥锁的解决方案\n6. 这里被注释了，可以替换掉上面那部分。必须使用`dispatch_group_async `，因为下面还用到`dispatch_group_wait `，必须确保group中所有操作执行完了才能排序。\n\n# 测试\n\n首先进行正确性测试，我使用了一些测试用例，目前来看没有问题，这里列出一个：\n\n```swift\nlet test = [1,2,3,4,5,6,7,8,9]\nlet result = test.ktMap { $0 * 2}\nprint(result)\t//输出结果：[2, 4, 6, 8, 10, 12, 14, 16]\n```\n为了进行性能测试，首先我定义了两个辅助函数：\n\n```swift\nfunc ktTimer<T>(description: String, @autoclosure task performTask: () -> T) -> Void {\n    let start = NSDate().timeIntervalSince1970\n    performTask()\n    \n    let duration = NSDate().timeIntervalSince1970 - start\n    print(\"Mission '\\(description)' completed in \\(duration * 1000) ms\")\n}\n\nfunc transformGenerater(duration duration: Float) -> Int -> Int {\n    return {\n        NSThread.sleepForTimeInterval(NSTimeInterval(duration))\n        return $0\n    }\n}\n```\n\n第一个函数用于计时，以毫秒为单位输出参数`performTask `的执行时间。\n\n第二个函数用于模拟耗时的计算，它的返回值类型是`Int -> Int`，可以作为`map`函数的参数。它的参数`delay `可以模拟计算所需要的时间。\n\n根据我的猜测，在处理少量数据时，多线程`map`的性能应该不如Swift自己实现的`map`，因为有一些额外的创建、切换线程以及同步操作。在数据量较大时，因为电脑上是八线程处理器(iPhone是4线程)，理论上`map`方法的耗时应该是自定义的`ktMap`方法的8倍。不过因为有这些固定的时间开销，实际上并不能达到理论上的优化效果。\n\n为了验证猜测，我进行了下面八组测试：\n\n```swift\nlet littleArray: Array<Int> = [1,2,3,4,5,6,7,8,9,10]   // 模拟数据量小的情况\nvar largeArray: Array<Int> = []   // 模拟数据量大的情况\n\nfor i in 0..<1000 {\n    largeArray.append(i)\n}\n\nktTimer(\"1.少量数据，多线程map方法，耗时计算\", task: littleArray.ktMap(transformGenerater(duration: 0.01)))\nktTimer(\"2.少量数据，普通map方法，耗时计算\", task: littleArray.map(transformGenerater(duration: 0.01)))\nktTimer(\"3.少量数据，多线程map方法，不耗时计算\", task:  littleArray.ktMap(transformGenerater(duration: 0)))\nktTimer(\"4.少量数据，普通map方法，不耗时计算\", task: littleArray.map(transformGenerater(duration: 0)))\nprint(\"\")\nktTimer(\"5.大量数据，多线程map方法，耗时计算\", task: largeArray.ktMap(transformGenerater(duration: 0.01)))\nktTimer(\"6.大量数据，普通map方法，耗时计算\", task: largeArray.map(transformGenerater(duration: 0.01)))\nktTimer(\"7.大量数据，多线程map方法，不耗时计算\", task: largeArray.ktMap(transformGenerater(duration: 0)))\nktTimer(\"8.大量数据，普通map方法，不耗时计算\", task: largeArray.map(transformGenerater(duration: 0)))\n```\n\n输出结果如下：\n\n```swift\nMission '1.少量数据，多线程map方法，耗时计算' completed in 15.394926071167 ms\nMission '2.少量数据，普通map方法，耗时计算' completed in 112.390041351318 ms\nMission '3.少量数据，多线程map方法，不耗时计算' completed in 0.3509521484375 ms\nMission '4.少量数据，普通map方法，不耗时计算' completed in 0.0109672546386719 ms\n\nMission '5.大量数据，多线程map方法，耗时计算' completed in 717.829942703247 ms\nMission '6.大量数据，普通map方法，耗时计算' completed in 11682.7671527863 ms\nMission '7.大量数据，多线程map方法，不耗时计算' completed in 2.37083435058594 ms\nMission '8.大量数据，普通map方法，不耗时计算' completed in 0.446796417236328 ms\n```\n\n每次运行的具体结果不同，通过对比可以发现：\n\n1. 对比1和2，假设`transform`的闭包执行时间是0.01秒，`ktMap`方法的耗时只有同步方法的7.3分之一。基本符合我之前的猜想。\n2. 对比3和4，如果只是把原来的元素翻倍，多线程方法的耗时反而是同步方法的35倍。而且即使数据量达到1000，对比7、8也可以发现同步方法快了好几倍\n\n于是得出一个结论：\n\n> 是否需要使用多线程map方法的依据不是数组元素的数量多少，而是元素变换操作的复杂度\n\n我简单的测试了几次，发现`duration `的值为`0.00001`的时候，两种函数耗时相似。而现在的CPU处理速度非常块，加减乘除运算用时几乎可以忽略不计。\n\n\n# 写在最后\n\n一定要找到实际使用中的性能瓶颈再进行优化，不要盲目臆造需求，重要的事说三遍：\n\n**过早的优化是万恶之源！**\n\n**过早的优化是万恶之源！**\n\n**过早的优化是万恶之源！**\n\n不仅`map`可以多线程实现，`filter`、`reduce`、`exists `等方法也可以使用多线程，实现原理与本文类似，有兴趣的读者可以自己研究研究。\n\n项目的demo在我的github：[ParallelMap](https://github.com/bestswifter/MySampleCode/tree/master/ParallelMap)，如果觉得不错还请随手点一个star😊","html":"<p>SequenceType协议中定义的<code>map</code>函数功能很强大，这个函数起源于函数式编程，能够很方便的对数组中的每个元素进行变换处理，关于它的实现原理和使用方法可以参考我的这篇文章：<a href=\"http://www.jianshu.com/p/7b1bb303ec45\">Swift数组变换</a>。今天突然想到，如果数组非常大，<code>map</code>方法会不会出现性能问题？如果使用多线程技术是否可以提高<code>map</code>方法的执行效率？带着这样的问题，我开始了本次实(zuo)验(si)。项目的demo在我的github：<a href=\"https://github.com/bestswifter/MySampleCode/tree/master/ParallelMap\">ParallelMap</a>，如果觉得不错还请随手点一个star😊</p>\n\n<h1 id=\"\">第一次尝试</h1>\n\n<p>虽然问题有些复杂，不过解决复杂的问题总是从处理简单问题开始的，我尝试直接使用异步多线程来处理：</p>\n\n<pre><code class=\"language-swift\">extension Array {  \n    func kt_map&lt;T&gt;(transform: (Element) -&gt; T) -&gt; [T] {\n        let asyncQueue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_CONCURRENT)\n        var result: [T] = []\n\n        dispatch_async(asyncQueue) { () -&gt; Void in\n            result = self.map(transform)\n        }\n        return result\n    }\n}\n\nlet test = [1,2,3,4,5,6,7,8,9]  \nlet result = kt_map { $0 * 2}  \nprint(result)     // 输出结果： []  \n</code></pre>\n\n<p>这显然是一个错的离谱的实现，最主要问题在于异步调用<code>self.map</code>方法后，没有等<code>result</code>变量被赋值就直接返回了(其实就是水平差)。不过，从第一次尝试中还是大概明确了方向，得出以下几个结论：</p>\n\n<ol>\n<li><p>方法内部肯定要用到多线程，但整体来说必须是同步的。必须等所有变换都执行结束，才能返回结果，Swift的<code>map</code>方法也是这么做的。</p></li>\n<li><p>因为方法是同步的，即使在方法内部新开一个线程，调用<code>self.map</code>，也不会节省任何时间，反而会因为线程切换浪费大量的时间。</p></li>\n<li><p>解决问题的思路应该是把数组拆成若干部分，在不同的线程中对不同的部分进行变换，最后再合并起来作为返回值。</p></li>\n</ol>\n\n<h1 id=\"\">第二次尝试</h1>\n\n<p>带着第一次尝试的收获，我开始了第二次尝试，这次代码比之前复杂一些，先上代码，标记数字的地方下面会有详细介绍：</p>\n\n<pre><code class=\"language-swift\">func ktMap&lt;T&gt;(transform: (Element) -&gt; T) -&gt; [T] { // 1  \n    guard !self.isEmpty else { return [] }  // 如果数组为空就直接返回空数组\n\n    var result: [(Int, [T])] = []   // 2\n    let group = dispatch_group_create()\n\n    // 3\n    let subArrayLength: Int = max(1, self.count / NSProcessInfo.processInfo().activeProcessorCount / 2)\n\n    for var step = 0; step * subArrayLength &lt; self.count; step++ {\n        var stepResult: [T] = []\n        // 4\n        dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {\n            for i in (step * subArrayLength)..&lt;((step + 1) * subArrayLength) {\n                stepResult += [transform(self[i])]\n            }\n            result += [(step, stepResult)]\n        }\n    }\n\n    dispatch_group_wait(group, DISPATCH_TIME_FOREVER)    // 5\n    return result.sort { $0.0 &lt; $1.0 }.flatMap { $0.1 }    // 6\n}\n</code></pre>\n\n<ol>\n<li><p>如果可以的话，我肯定仿照Swift对<code>map</code>方法的实现，把<code>transform</code>闭包声明为<code>@noescape</code>，可惜在GCD中要调用这个闭包，只能作罢。关于<code>@noescape</code>关键字的优点和限制，可以参考我的这篇博客：<a href=\"http://www.jianshu.com/p/f9ba4c41d9c7\">自动闭包和noescape</a>。</p></li>\n<li><p><code>result</code>是一个元组的数组。元组中第二个元素是<code>self</code>的子数组，第一个元素是这个子数组的序号。比如数组<code>[1,2,3,4,5,6]</code>有可能在<code>result</code>中表示为<code>[(0, [1,2,3]), (1, [4,5,6])]</code>。之所以这样拆分，是因为我要在多线程中分别处理每个子数组，最后再把他们合并成原来的数组。</p></li>\n<li><p><code>subArrayLength</code>表示每个子数组的长度。在整个除法表达式中，我们首先除以当前活跃的处理器核数，以iPhone6的A8处理器为例，它是双核的。因为一个核心对应两个线程，我希望能够在每个线程中处理一个子数组，所以又除以了2。其实这样做没有必要，因为不管我们在程序中开了多少个异步线程，真正对应到CPU的线程的过程是由GCD控制的。这就是操作系统中的“多对多”线程模型。不管怎么说，我们算出了每个子数组的长度。</p></li>\n<li><p>接下来是一个循环，在每一步中我们异步的执行一些操作（这些操作会在新线程里执行）。<code>stepResult</code>是一个子数组，用于存储这一段元素的变换结果。变换结束后，把<code>step</code>和<code>stepResult</code>分别作为元组的第一、二个元素，存入<code>result</code>数组中</p></li>\n<li><p>调用<code>dispatch_group_wait</code>，这样我们会一直等到所有<code>group</code>中的方法结束后，才执行下面的代码。因为之前所有的任务都是放在<code>group</code>中执行的，所以这就保证了整个<code>ktMap</code>方法是同步的。</p></li>\n<li><p>首先根据元组的第一个元素，也就是子数组序号排序，接着调用<code>flatMap</code>方法把其中的数组提取出来。关于<code>sort</code>和<code>flatMap</code>方法的用法，同样可以参考我的这篇文章：<a href=\"http://www.jianshu.com/p/7b1bb303ec45\">Swift数组变换</a>。</p></li>\n</ol>\n\n<p>方法实现完了以后，再次调用它，查看结果。可怜的是还不如以前，这次直接崩溃了。根据崩溃提示，问题主要出在这一段：</p>\n\n<pre><code class=\"language-swift\">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {  \n    for i in (step * subArrayLength)..&lt;((step + 1) * subArrayLength) {\n        stepResult += [transform(self[i])]\n    }\n    result += [(step, stepResult)]\n}\n</code></pre>\n\n<h1 id=\"\">第三次尝试</h1>\n\n<p>我在异步方法中向数组<code>result</code>添加新的元素，这样是很危险的。准确的说是程序几乎必定崩溃，具体原因可以参考这篇文章：<a href=\"http://www.jianshu.com/p/2fce6a0bb17b\">Swift数组扩容原理</a>。正确的做法是加一个锁，保证每次只有一个添加元素的操作在执行。另一种常见的方案是使用同步队列，它可以保证队列中所有的任务依次进行。</p>\n\n<p>另一个问题在于，在最外层的for循环中，step变量表示当前是第几步。它随着循环的进行，不断自增。如果在循环内部总是使用<code>step</code>，就有可能获取到错误的<code>step</code>值。这一点也要格外重视，在平时的编程中，for循环总是同步的，当前循环不结束就不会开始下一个循环。在多线程编程中就完全不是这样，循环内部调用了异步方法，所以每个循环会非常快的结束。正确的做法是在循环内部用一个临时常量保存<code>step</code>的值。</p>\n\n<p>最后一个问题是处理每一段子数组时，它的长度总是固定的，也就是<code>subArrayLength</code>的值。但是在处理最后一个子数组时可能导致下标越界，即使没有越界，这些操作也是多余的。</p>\n\n<p>解决这三个问题后，我完成了最终的<code>map</code>方法实现，具体的解释在下面：</p>\n\n<pre><code class=\"language-swift\">func ktMap&lt;T&gt;(transform: (Element) -&gt; T) -&gt; [T] {  \n    guard !self.isEmpty else { return [] }  // 如果数组为空就直接返回空数组\n\n    var result: [(Int, [T])] = []\n    let group = dispatch_group_create()\n    let mutex = dispatch_semaphore_create(1)    // 1\n    let syncQueue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_SERIAL)    // 2\n\n    let subArrayLength: Int = max(1, self.count / NSProcessInfo.processInfo().activeProcessorCount / 2)\n\n    for var step = 0; step * subArrayLength &lt; self.count; step++ {\n        let localStep = step    // 3\n        var stepResult: [T] = []\n\n        dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {\n            // 4\n            for i in (localStep * subArrayLength)..&lt;min(((localStep + 1) * subArrayLength), self.count) {\n                stepResult += [transform(self[i])]\n            }\n\n            // 5\n            dispatch_semaphore_wait(mutex, DISPATCH_TIME_FOREVER)\n            result += [(localStep, stepResult)]\n            dispatch_semaphore_signal(mutex)\n\n            // 6\n//          dispatch_group_async(group, syncQueue) {\n//              result += [(localStep, stepResult)]\n//          }\n        }\n    }\n\n    dispatch_group_wait(group, DISPATCH_TIME_FOREVER)\n    return result.sort { $0.0 &lt; $1.0 }.flatMap { $0.1 }\n}\n</code></pre>\n\n<ol>\n<li>使用互斥锁保证不会有多个数组添加元素的操作同时进行  </li>\n<li>同步队列也是一种解决方式  </li>\n<li>在for循环体中用一个常量保存下来当前的<code>step</code>值，后面用<code>localStep</code>替代所有的<code>step</code>  </li>\n<li>数组的右边界进行一个判断，最多不超过<code>self.count</code>  </li>\n<li>这是使用互斥锁的解决方案  </li>\n<li>这里被注释了，可以替换掉上面那部分。必须使用<code>dispatch_group_async</code>，因为下面还用到<code>dispatch_group_wait</code>，必须确保group中所有操作执行完了才能排序。</li>\n</ol>\n\n<h1 id=\"\">测试</h1>\n\n<p>首先进行正确性测试，我使用了一些测试用例，目前来看没有问题，这里列出一个：</p>\n\n<pre><code class=\"language-swift\">let test = [1,2,3,4,5,6,7,8,9]  \nlet result = test.ktMap { $0 * 2}  \nprint(result)    //输出结果：[2, 4, 6, 8, 10, 12, 14, 16]  \n</code></pre>\n\n<p>为了进行性能测试，首先我定义了两个辅助函数：</p>\n\n<pre><code class=\"language-swift\">func ktTimer&lt;T&gt;(description: String, @autoclosure task performTask: () -&gt; T) -&gt; Void {  \n    let start = NSDate().timeIntervalSince1970\n    performTask()\n\n    let duration = NSDate().timeIntervalSince1970 - start\n    print(\"Mission '\\(description)' completed in \\(duration * 1000) ms\")\n}\n\nfunc transformGenerater(duration duration: Float) -&gt; Int -&gt; Int {  \n    return {\n        NSThread.sleepForTimeInterval(NSTimeInterval(duration))\n        return $0\n    }\n}\n</code></pre>\n\n<p>第一个函数用于计时，以毫秒为单位输出参数<code>performTask</code>的执行时间。</p>\n\n<p>第二个函数用于模拟耗时的计算，它的返回值类型是<code>Int -&gt; Int</code>，可以作为<code>map</code>函数的参数。它的参数<code>delay</code>可以模拟计算所需要的时间。</p>\n\n<p>根据我的猜测，在处理少量数据时，多线程<code>map</code>的性能应该不如Swift自己实现的<code>map</code>，因为有一些额外的创建、切换线程以及同步操作。在数据量较大时，因为电脑上是八线程处理器(iPhone是4线程)，理论上<code>map</code>方法的耗时应该是自定义的<code>ktMap</code>方法的8倍。不过因为有这些固定的时间开销，实际上并不能达到理论上的优化效果。</p>\n\n<p>为了验证猜测，我进行了下面八组测试：</p>\n\n<pre><code class=\"language-swift\">let littleArray: Array&lt;Int&gt; = [1,2,3,4,5,6,7,8,9,10]   // 模拟数据量小的情况  \nvar largeArray: Array&lt;Int&gt; = []   // 模拟数据量大的情况\n\nfor i in 0..&lt;1000 {  \n    largeArray.append(i)\n}\n\nktTimer(\"1.少量数据，多线程map方法，耗时计算\", task: littleArray.ktMap(transformGenerater(duration: 0.01)))  \nktTimer(\"2.少量数据，普通map方法，耗时计算\", task: littleArray.map(transformGenerater(duration: 0.01)))  \nktTimer(\"3.少量数据，多线程map方法，不耗时计算\", task:  littleArray.ktMap(transformGenerater(duration: 0)))  \nktTimer(\"4.少量数据，普通map方法，不耗时计算\", task: littleArray.map(transformGenerater(duration: 0)))  \nprint(\"\")  \nktTimer(\"5.大量数据，多线程map方法，耗时计算\", task: largeArray.ktMap(transformGenerater(duration: 0.01)))  \nktTimer(\"6.大量数据，普通map方法，耗时计算\", task: largeArray.map(transformGenerater(duration: 0.01)))  \nktTimer(\"7.大量数据，多线程map方法，不耗时计算\", task: largeArray.ktMap(transformGenerater(duration: 0)))  \nktTimer(\"8.大量数据，普通map方法，不耗时计算\", task: largeArray.map(transformGenerater(duration: 0)))  \n</code></pre>\n\n<p>输出结果如下：</p>\n\n<pre><code class=\"language-swift\">Mission '1.少量数据，多线程map方法，耗时计算' completed in 15.394926071167 ms  \nMission '2.少量数据，普通map方法，耗时计算' completed in 112.390041351318 ms  \nMission '3.少量数据，多线程map方法，不耗时计算' completed in 0.3509521484375 ms  \nMission '4.少量数据，普通map方法，不耗时计算' completed in 0.0109672546386719 ms\n\nMission '5.大量数据，多线程map方法，耗时计算' completed in 717.829942703247 ms  \nMission '6.大量数据，普通map方法，耗时计算' completed in 11682.7671527863 ms  \nMission '7.大量数据，多线程map方法，不耗时计算' completed in 2.37083435058594 ms  \nMission '8.大量数据，普通map方法，不耗时计算' completed in 0.446796417236328 ms  \n</code></pre>\n\n<p>每次运行的具体结果不同，通过对比可以发现：</p>\n\n<ol>\n<li>对比1和2，假设<code>transform</code>的闭包执行时间是0.01秒，<code>ktMap</code>方法的耗时只有同步方法的7.3分之一。基本符合我之前的猜想。  </li>\n<li>对比3和4，如果只是把原来的元素翻倍，多线程方法的耗时反而是同步方法的35倍。而且即使数据量达到1000，对比7、8也可以发现同步方法快了好几倍</li>\n</ol>\n\n<p>于是得出一个结论：</p>\n\n<blockquote>\n  <p>是否需要使用多线程map方法的依据不是数组元素的数量多少，而是元素变换操作的复杂度</p>\n</blockquote>\n\n<p>我简单的测试了几次，发现<code>duration</code>的值为<code>0.00001</code>的时候，两种函数耗时相似。而现在的CPU处理速度非常块，加减乘除运算用时几乎可以忽略不计。</p>\n\n<h1 id=\"\">写在最后</h1>\n\n<p>一定要找到实际使用中的性能瓶颈再进行优化，不要盲目臆造需求，重要的事说三遍：</p>\n\n<p><strong>过早的优化是万恶之源！</strong></p>\n\n<p><strong>过早的优化是万恶之源！</strong></p>\n\n<p><strong>过早的优化是万恶之源！</strong></p>\n\n<p>不仅<code>map</code>可以多线程实现，<code>filter</code>、<code>reduce</code>、<code>exists</code>等方法也可以使用多线程，实现原理与本文类似，有兴趣的读者可以自己研究研究。</p>\n\n<p>项目的demo在我的github：<a href=\"https://github.com/bestswifter/MySampleCode/tree/master/ParallelMap\">ParallelMap</a>，如果觉得不错还请随手点一个star😊</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-16T05:52:10.000Z","created_by":1,"updated_at":"2016-01-28T16:31:14.000Z","updated_by":1,"published_at":"2016-01-16T05:52:36.000Z","published_by":1},{"id":17,"uuid":"cacba30f-d56c-4592-83fa-7899b91cd076","title":"Swift中字典的实现原理","slug":"dictionary-implemation","markdown":"本文翻译、整理自：[Exploring Swift Dictionary's Implementation](http://ankit.im/swift/2016/01/20/exploring-swift-dictionary-implementation/?utm_campaign=This%2BWeek%2Bin%2BSwift&utm_medium=email&utm_source=This_Week_in_Swift_71)\n\nSwift中字典具有以下特点：\n\n* 字典由两种范型类型组成，分别是Key（必须实现`Hashable `协议）和Value\n* 提供一组Key和Value，可以向字典中插入一条新的数据\n* 如果Key已经被插入字典，则可以通过Key获取到Value\n* 可以通过Key删除一条字典中的数据\n* 每个Key对应，且唯一对应字典中的一个Value\n\n有很多种方式可以用于存储这些Key-Value对，Swift中字典采用了使用线性探测的开放寻址法。\n\n我们知道，哈希表不可避免会出现的问题是哈希值冲突，也就是两个不同的Key可能具有相同的哈希值。线性探测是指，如果出现第二个Key的哈希值和第一个Key的哈希值冲突，则会检查第一个Key对应位置的后一个位置是否可用，如果可用则把第二个Key对应的Value放在这里，否则就继续向后寻找。\n\n一个容量为8的字典，它实际上只能存储7个Key-Value对，这是因为字典需要至少一个空位置作为插入和查找过程中的停止标记。我们把这个位置称为“**洞**”。\n\n举个例子，假设Key1和Key2具有相同的哈希值，它们都存储在字典中。现在我们查找Key3对应的值。Key3的哈希值和前两者相同，但它不存在于字典中。查找时，首先从Key1所在的位置开始比较，因为不匹配所以比较Key2所在的位置，而且从理论上来说只用比较这两个位置即可。如果Key2的后面是一个洞，就表示查找到此为止，否则还得继续向后查找。\n\n在实际内存中，它的布局看上去是这样的：\n\n![布局-1](http://upload-images.jianshu.io/upload_images/1171077-fff49929a64fe6ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n创建字典时会分配一段连续的内存，其大小很容易计算：\n\n`size = capacity * (sizeof(Bitmap) + sizeof(Keys) + sizeof(Values))`\n\n从逻辑上来看，字典的组成结构如下：\n\n![逻辑布局](http://upload-images.jianshu.io/upload_images/1171077-7c1ebba80e7ee0f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中每一列称为一个**bucket**，其中存储了三样东西：位图的值，Key和Value。bucket的概念其实已经有些类似于我们实际使用字典时，Key-Value对的概念了。\n\nbucket中位图的值用于表示这个bucket中的Key和Value是否是已初始化且有效的。如果不是，那么这个bucket就是一个洞。\n\n介绍完以上基本概念后，我们由底层向高层介绍字典的实现原理：\n\n## _HashedContainerStorageHeader（结构体）\n\n![_HashedContainerStorageHeader](http://upload-images.jianshu.io/upload_images/1171077-f2b8bf1f0474d534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这个结构体是字典所使用内存的头部，它有三个成员变量：\n\n* capacity：字典的容量，表示字典当前最多可以存储多少Key-Value对\n* count：字典中元素数量，表示字典当前实际存储的Key-Value对的数量\n* maxLoadFactorInverse：当字典需要扩容时使用到的因子，新的capacity是旧的capacity乘以这个因子。\n\n## _NativeDictionaryStorageImpl<Key, Value>（类）\n\n这个类是`ManagedBuffer<_HashedContainerStorageHeader, UInt8>`的子类。\n\n这个类的作用是为字典分配需要使用的内存，并且返回指向位图、Key和Value数组的指针。比如：\n\n```swift\ninternal var _values: UnsafeMutablePointer<Value> {\n  @warn_unused_result\n  get {\n    let start = UInt(Builtin.ptrtoint_Word(_keys._rawValue)) &+\n      UInt(_capacity) &* UInt(strideof(Key.self))\n    let alignment = UInt(alignof(Value))\n    let alignMask = alignment &- UInt(1)\n    return UnsafeMutablePointer<Value>(\n        bitPattern:(start &+ alignMask) & ~alignMask)\n  }\n}\n```\n\n由于位图、Key和Value数组所在的内存是连续分配的，所以Value数组的指针`values_pointer `等于`keys_pointer + capacity * keys_pointer`。\n\n分配字典所用内存的函数和下面的知识关系不大，所以这里略去不写，有兴趣的读者可以在原文中查看。\n\n在分配内存的过程中，位图数组中所有的元素值都是0，这就表示所有的bucket都是洞。另外需要强调的一点是，到目前为止(分配字典所用内存)范型Key不必实现`Hashable`协议。\n\n目前，字典的结构组成示意图如下：\n\n![_NativeDictionaryStorageImpl](http://upload-images.jianshu.io/upload_images/1171077-e6c5d0b841719cf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## _NativeDictionaryStorage<Key : Hashable, Value>（结构体）\n\n这个结构体将`_NativeDictionaryStorageImpl `结构体封装为自己的`buffer`属性，它还提供了一些方法将实际上有三个连续数组组成的字典内存转换成逻辑上的bucket数组。而且，这个结构体将bucket数组中的第一个bucket和最后一个bucket在逻辑上链接起来，从而形成了一个bucket环，也就是说当你到达bucket数组的末尾并且调用`next`方法时，你又会回到bucket数组的开头。\n\n在进行插入或查找操作时，我们需要算出这个Key对应哪个bucket。由于Key实现了`Hashable`，所以它一定实现了`hashValue`方法并返回一个整数值。但这个哈希值可能比字典容量还大，所以我们需要压缩这个哈希值，以确保它属于区间`[0, capacity)`：\n\n```swift\n@warn_unused_result\ninternal func _bucket(k: Key) -> Int {\n  return _squeezeHashValue(k.hashValue, 0..<capacity)\n}\n```\n\n通过`_next `和`_prev `函数，我们可以遍历整个bucket数组，这里虽然使用了溢出运算符，但实际上并不会发生溢出，个人猜测是为了性能优化：\n\n```swift\ninternal var _bucketMask: Int {\n  return capacity &- 1\n}\n\n@warn_unused_result\ninternal func _next(bucket: Int) -> Int {\n  return (bucket &+ 1) & _bucketMask\n}\n\n@warn_unused_result\ninternal func _prev(bucket: Int) -> Int {\n  return (bucket &- 1) & _bucketMask\n}\n```\n\n字典容量`capacity`一定可以表示为2的多少次方，因此`_bucketMask `这个属性如果用二进制表示，则一定全部由1组成。举个例子体验一下，假设`capacity = 8`：\n\n* bucket = 6，调用_next方法，返回值为 7 & 7，也就是7.\n* bucket = 7，调用_next方法，返回值为 8 & 7，二进制表示为1000 & 0111，因此返回值为0。也就是返回了数组的起始位置。\n* bucket = 0，调用_prev方法，返回值为 -1 & 7，二进制表示为1…1111 & 0…0111，因此返回值为111，也就是7，回到了数组的结束位置。\n\n在插入一个键值对时，我们首先计算出Key对应哪个bucket，然后调用下面的方法把Key和Value写入到bucket中，同时把位图的值设置为true：\n\n```swift\n@_transparent\ninternal func initializeKey(k: Key, value v: Value, at i: Int) {\n  _sanityCheck(!isInitializedEntry(i))\n\n  (keys + i).initialize(k)\n  (values + i).initialize(v)\n  initializedEntries[i] = true\n  _fixLifetime(self)\n}\n```\n\n另一个需要重点介绍的函数是`_find`：\n\n* `_find`函数用于找到Key对应的bucket\n* 需要指定需要指定从哪个bucket开始寻找，因此需要`_buckey(key)`函数的配合\n* 如果参数key和某个bucket中的Key匹配，则返回这个bucket的位置\n* 如果没有找到，则返回接下来的第一个洞，表示key可以插入到这里\n* 通过位图判断当前bucket是不是一个洞\n* 这种算法被称为线性探测\n\n```swift\n@warn_unused_result\ninternal\nfunc _find(key: Key, _ startBucket: Int) -> (pos: Index, found: Bool) {\n  var bucket = startBucket\n  while true {\n    let isHole = !isInitializedEntry(bucket)\n    if isHole {\n      return (Index(nativeStorage: self, offset: bucket), false)\n    }\n    if keyAt(bucket) == key {\n      return (Index(nativeStorage: self, offset: bucket), true)\n    }\n    bucket = _next(bucket)\n  }\n}\n```\n\n* 一般来说，`_squeezeHashValue `函数的返回值就是Key对应的bucket的下标，不过需要考虑不同的Key哈希值冲突的情况。\n* 在这种情况下，`_find`函数会找到下一个可用的洞，以便插入数据。\n\n## hashValue优化\n\n`_squeezeHashValue `函数的本质是对Key的哈希值再次求得哈希值，而一个优秀的哈希函数是提高性能的关键。`_squeezeHashValue `函数基本上符合要求，不过目前惟一的缺点是哈希变换的种子还是一个占位常量，有兴趣的读者可以阅读完整的函数实现，其中的`seed `就是一个值为`0xff51afd7ed558ccd `的常量：\n\n```swift\nfunc _squeezeHashValue(hashValue: Int, _ resultRange: Range<UInt>) -> UInt {\n  let mixedHashValue = UInt(bitPattern: _mixInt(hashValue))\n  let resultCardinality: UInt = resultRange.endIndex - resultRange.startIndex\n  if _isPowerOf2(resultCardinality) {\n    return mixedHashValue & (resultCardinality - 1)\n  }\n  return resultRange.startIndex + (mixedHashValue % resultCardinality)\n}\n\nfunc _mixUInt64(value: UInt64) -> UInt64 {\n  // Similar to hash_4to8_bytes but using a seed instead of length.\n  let seed: UInt64 = _HashingDetail.getExecutionSeed()\n  let low: UInt64 = value & 0xffff_ffff\n  let high: UInt64 = value >> 32\n  return _HashingDetail.hash16Bytes(seed &+ (low << 3), high)\n}\n\nstatic func getExecutionSeed() -> UInt64 {\n  // FIXME: This needs to be a per-execution seed. This is just a placeholder\n  // implementation.\n  let seed: UInt64 = 0xff51afd7ed558ccd\n  return _HashingDetail.fixedSeedOverride == 0 ? seed : fixedSeedOverride\n}\n\nstatic func hash16Bytes(low: UInt64, _ high: UInt64) -> UInt64 {\n  // Murmur-inspired hashing.\n  let mul: UInt64 = 0x9ddfea08eb382d69\n  var a: UInt64 = (low ^ high) &* mul\n  a ^= (a >> 47)\n  var b: UInt64 = (high ^ a) &* mul\n  b ^= (b >> 47)\n  b = b &* mul\n  return b\n}\n```\n\n目前，字典的结构总结如下：\n\n![](http://upload-images.jianshu.io/upload_images/1171077-7fb40bdc208d37f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## _NativeDictionaryStorageOwner（类）\n\n这个类被用于管理字典的引用计数，以支持写时复制(COW)特性。由于`Dictionary `和`DictionaryIndex `都会引用实际存储区域，所以引用计数为2。不过写时复制的唯一性检查不考虑由`DictionaryIndex `导致的引用，所以如果字典通过引用这个类的实例对象来管理引用计数值，问题就很容易处理。\n\n```swift\n/// This class is an artifact of the COW implementation.  This class only\n/// exists to keep separate retain counts separate for:\n/// - `Dictionary` and `NSDictionary`,\n/// - `DictionaryIndex`.\n///\n/// This is important because the uniqueness check for COW only cares about\n/// retain counts of the first kind.\n\n/// 这个类用于区分以下两种引用：\n/// - `Dictionary` and `NSDictionary`,\n/// - `DictionaryIndex`.\n/// 这是因为写时复制的唯一性检查只考虑第一种引用\n```\n\n现在，字典的结构变得有些复杂，难以理解了：\n\n![](http://upload-images.jianshu.io/upload_images/1171077-41f6569f1fdf458a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## _VariantDictionaryStorage<Key : Hashable, Value> (枚举)\n\n这个枚举类型中有两个成员，它们各自具有自己的关联值，分别表示Swift原生的字典和Cocoa的字典：\n\n```swift\ncase Native(_NativeDictionaryStorageOwner<Key, Value>)\ncase Cocoa(_CocoaDictionaryStorage)\n```\n\n这个枚举类型的主要功能是：\n\n1. 根据字典的不同类型（原生 or Cocoa）执行对应的增删改查函数\n2. 如果字典已经满了，则扩容\n3. 更新或初始化Key-Value对：\n\t\n```swift\ninternal mutating func nativeUpdateValue(\n\tvalue: Value, forKey key: Key\n) -> Value? {\n\tvar (i, found) = native._find(key, native._bucket(key))\n\t    \n\tlet minCapacity = found\n\t  ? native.capacity\n\t  : NativeStorage.getMinCapacity(\n\t\t  native.count + 1,\n\t\t  native.maxLoadFactorInverse)\n\t\t\n\tlet (_, capacityChanged) = ensureUniqueNativeStorage(minCapacity)\n\tif capacityChanged {\n\t    i = native._find(key, native._bucket(key)).pos\n\t}\n\t\t\n\tlet oldValue: Value? = found ? native.valueAt(i.offset) : nil\n\tif found {\n\t    native.setKey(key, value: value, at: i.offset)\n\t} else {\n\t    native.initializeKey(key, value: value, at: i.offset)\n\t    native.count += 1\n\t}\n\t\t\n\treturn oldValue\n}\n```\n\n4. 如果移除某个Key-Value对，就会在原地留下一个洞。下一次线性查找时有可能会提前停止，为了解决这个问题，我们需要在移除Key-Value对后，移动另一个Key-Value对补上这个洞，源码如下：\n\n```swift\n/// - parameter idealBucket: The ideal bucket for the element being deleted.\n/// - parameter offset: The offset of the element that will be deleted.\n/// Requires an initialized entry at offset.\ninternal mutating func nativeDeleteImpl(\n  \tnativeStorage: NativeStorage, idealBucket: Int, offset: Int\n) {\n\t_sanityCheck(\n\t  nativeStorage.isInitializedEntry(offset), \"expected initialized entry\")\n\t\n\t// remove the element\n\tnativeStorage.destroyEntryAt(offset)\n\tnativeStorage.count -= 1\n\t\n\t// If we've put a hole in a chain of contiguous elements, some\n\t// element after the hole may belong where the new hole is.\n\tvar hole = offset\n\t\n\t// Find the first bucket in the contiguous chain\n\tvar start = idealBucket\n\twhile nativeStorage.isInitializedEntry(nativeStorage._prev(start)) {\n\t\tstart = nativeStorage._prev(start)\n\t}\n\t\n\t// Find the last bucket in the contiguous chain\n\tvar lastInChain = hole\n\tvar b = nativeStorage._next(lastInChain)\n\twhile nativeStorage.isInitializedEntry(b) {\n\t\tlastInChain = b\n\t\tb = nativeStorage._next(b)\n\t}\n\t\n\t// Relocate out-of-place elements in the chain, repeating until\n\t// none are found.\n\twhile hole != lastInChain {\n\t\t// Walk backwards from the end of the chain looking for\n\t\t// something out-of-place.\n\t\tvar b = lastInChain\n\t\twhile b != hole {\n\t\t\tlet idealBucket = nativeStorage._bucket(nativeStorage.keyAt(b))\n\t\n\t\t\t// Does this element belong between start and hole?  We need\n\t\t\t// two separate tests depending on whether [start,hole] wraps\n\t\t\t// around the end of the buffer\n\t\t\tlet c0 = idealBucket >= start\n\t\t\tlet c1 = idealBucket <= hole\t\t\t\tif start <= hole ? (c0 && c1) : (c0 || c1) {\n\t\t\t\tbreak // Found it\n\t\t\t}\n\t\t\tb = nativeStorage._prev(b)\n\t\t}\n\t\n\t\tif b == hole { // No out-of-place elements found; we're done adjusting\n\t\t\tbreak\n\t\t}\n\t\n\t\t// Move the found element into the hole\n\t\tnativeStorage.moveInitializeFrom(nativeStorage, at: b, toEntryAt: hole)\n\t\thole = b\n\t}\n}\n```\n\n这段代码理解起来可能比较费力，我想举一个例子来说明就比较简单了，假设一开始有8个bucket，bucket中的value就是bucket的下标，最后一个bucket是洞：\n\n```swift\nBucket数组中元素下标:  {0, 1, 2, 3, 4, 5, 6, 7(Hole)}\nbucket中存储的Value:  {0, 1, 2, 3, 4, 5, 6,        }\n```\n\n接下来我们删除第五个bucket，这会在原地留下一个洞：\n\n```swift\nBucket数组中元素下标:  {0, 1, 2, 3, 4(Hole), 5, 6, 7(Hole)}\nbucket中存储的Value:  {0, 1, 2, 3,        , 5, 6         }\n```\n\n为了补上这个洞，我们把最后一个bucket中的内容移到这个洞里，现在第五个bucket就不是洞了：\n\n```swift\nBucket数组中元素下标:  {0, 1, 2, 3, 4, 5, 6(Hole), 7(Hole)}\nbucket中存储的Value:  {0, 1, 2, 3, 6, 5,        ,        }\n```\n\n![枚举](http://upload-images.jianshu.io/upload_images/1171077-5590943f50016dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 字典的完整结构\n\n`Dictionary`结构体持有一个`_VariantDictionaryStorage`类型的枚举，作为自己的成员属性，所以整个字典完整的组成结构如下图所示：\n\n\n![Swift字典结构](http://upload-images.jianshu.io/upload_images/1171077-ee0bbf3705805c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","html":"<p>本文翻译、整理自：<a href=\"http://ankit.im/swift/2016/01/20/exploring-swift-dictionary-implementation/?utm_campaign=This%2BWeek%2Bin%2BSwift&amp;utm_medium=email&amp;utm_source=This_Week_in_Swift_71\">Exploring Swift Dictionary's Implementation</a></p>\n\n<p>Swift中字典具有以下特点：</p>\n\n<ul>\n<li>字典由两种范型类型组成，分别是Key（必须实现<code>Hashable</code>协议）和Value</li>\n<li>提供一组Key和Value，可以向字典中插入一条新的数据</li>\n<li>如果Key已经被插入字典，则可以通过Key获取到Value</li>\n<li>可以通过Key删除一条字典中的数据</li>\n<li>每个Key对应，且唯一对应字典中的一个Value</li>\n</ul>\n\n<p>有很多种方式可以用于存储这些Key-Value对，Swift中字典采用了使用线性探测的开放寻址法。</p>\n\n<p>我们知道，哈希表不可避免会出现的问题是哈希值冲突，也就是两个不同的Key可能具有相同的哈希值。线性探测是指，如果出现第二个Key的哈希值和第一个Key的哈希值冲突，则会检查第一个Key对应位置的后一个位置是否可用，如果可用则把第二个Key对应的Value放在这里，否则就继续向后寻找。</p>\n\n<p>一个容量为8的字典，它实际上只能存储7个Key-Value对，这是因为字典需要至少一个空位置作为插入和查找过程中的停止标记。我们把这个位置称为“<strong>洞</strong>”。</p>\n\n<p>举个例子，假设Key1和Key2具有相同的哈希值，它们都存储在字典中。现在我们查找Key3对应的值。Key3的哈希值和前两者相同，但它不存在于字典中。查找时，首先从Key1所在的位置开始比较，因为不匹配所以比较Key2所在的位置，而且从理论上来说只用比较这两个位置即可。如果Key2的后面是一个洞，就表示查找到此为止，否则还得继续向后查找。</p>\n\n<p>在实际内存中，它的布局看上去是这样的：</p>\n\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1171077-fff49929a64fe6ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"布局-1\" /></p>\n\n<p>创建字典时会分配一段连续的内存，其大小很容易计算：</p>\n\n<p><code>size = capacity * (sizeof(Bitmap) + sizeof(Keys) + sizeof(Values))</code></p>\n\n<p>从逻辑上来看，字典的组成结构如下：</p>\n\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1171077-7c1ebba80e7ee0f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"逻辑布局\" /></p>\n\n<p>其中每一列称为一个<strong>bucket</strong>，其中存储了三样东西：位图的值，Key和Value。bucket的概念其实已经有些类似于我们实际使用字典时，Key-Value对的概念了。</p>\n\n<p>bucket中位图的值用于表示这个bucket中的Key和Value是否是已初始化且有效的。如果不是，那么这个bucket就是一个洞。</p>\n\n<p>介绍完以上基本概念后，我们由底层向高层介绍字典的实现原理：</p>\n\n<h2 id=\"_hashedcontainerstorageheader\">_HashedContainerStorageHeader（结构体）</h2>\n\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1171077-f2b8bf1f0474d534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"_HashedContainerStorageHeader\" /></p>\n\n<p>这个结构体是字典所使用内存的头部，它有三个成员变量：</p>\n\n<ul>\n<li>capacity：字典的容量，表示字典当前最多可以存储多少Key-Value对</li>\n<li>count：字典中元素数量，表示字典当前实际存储的Key-Value对的数量</li>\n<li>maxLoadFactorInverse：当字典需要扩容时使用到的因子，新的capacity是旧的capacity乘以这个因子。</li>\n</ul>\n\n<h2 id=\"_nativedictionarystorageimplkeyvalue\">_NativeDictionaryStorageImpl<Key, Value>（类）</h2>\n\n<p>这个类是<code>ManagedBuffer&lt;_HashedContainerStorageHeader, UInt8&gt;</code>的子类。</p>\n\n<p>这个类的作用是为字典分配需要使用的内存，并且返回指向位图、Key和Value数组的指针。比如：</p>\n\n<pre><code class=\"language-swift\">internal var _values: UnsafeMutablePointer&lt;Value&gt; {  \n  @warn_unused_result\n  get {\n    let start = UInt(Builtin.ptrtoint_Word(_keys._rawValue)) &amp;+\n      UInt(_capacity) &amp;* UInt(strideof(Key.self))\n    let alignment = UInt(alignof(Value))\n    let alignMask = alignment &amp;- UInt(1)\n    return UnsafeMutablePointer&lt;Value&gt;(\n        bitPattern:(start &amp;+ alignMask) &amp; ~alignMask)\n  }\n}\n</code></pre>\n\n<p>由于位图、Key和Value数组所在的内存是连续分配的，所以Value数组的指针<code>values_pointer</code>等于<code>keys_pointer + capacity * keys_pointer</code>。</p>\n\n<p>分配字典所用内存的函数和下面的知识关系不大，所以这里略去不写，有兴趣的读者可以在原文中查看。</p>\n\n<p>在分配内存的过程中，位图数组中所有的元素值都是0，这就表示所有的bucket都是洞。另外需要强调的一点是，到目前为止(分配字典所用内存)范型Key不必实现<code>Hashable</code>协议。</p>\n\n<p>目前，字典的结构组成示意图如下：</p>\n\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1171077-e6c5d0b841719cf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"_NativeDictionaryStorageImpl\" /></p>\n\n<h2 id=\"_nativedictionarystoragekeyhashablevalue\">_NativeDictionaryStorage<Key : Hashable, Value>（结构体）</h2>\n\n<p>这个结构体将<code>_NativeDictionaryStorageImpl</code>结构体封装为自己的<code>buffer</code>属性，它还提供了一些方法将实际上有三个连续数组组成的字典内存转换成逻辑上的bucket数组。而且，这个结构体将bucket数组中的第一个bucket和最后一个bucket在逻辑上链接起来，从而形成了一个bucket环，也就是说当你到达bucket数组的末尾并且调用<code>next</code>方法时，你又会回到bucket数组的开头。</p>\n\n<p>在进行插入或查找操作时，我们需要算出这个Key对应哪个bucket。由于Key实现了<code>Hashable</code>，所以它一定实现了<code>hashValue</code>方法并返回一个整数值。但这个哈希值可能比字典容量还大，所以我们需要压缩这个哈希值，以确保它属于区间<code>[0, capacity)</code>：</p>\n\n<pre><code class=\"language-swift\">@warn_unused_result\ninternal func _bucket(k: Key) -&gt; Int {  \n  return _squeezeHashValue(k.hashValue, 0..&lt;capacity)\n}\n</code></pre>\n\n<p>通过<code>_next</code>和<code>_prev</code>函数，我们可以遍历整个bucket数组，这里虽然使用了溢出运算符，但实际上并不会发生溢出，个人猜测是为了性能优化：</p>\n\n<pre><code class=\"language-swift\">internal var _bucketMask: Int {  \n  return capacity &amp;- 1\n}\n\n@warn_unused_result\ninternal func _next(bucket: Int) -&gt; Int {  \n  return (bucket &amp;+ 1) &amp; _bucketMask\n}\n\n@warn_unused_result\ninternal func _prev(bucket: Int) -&gt; Int {  \n  return (bucket &amp;- 1) &amp; _bucketMask\n}\n</code></pre>\n\n<p>字典容量<code>capacity</code>一定可以表示为2的多少次方，因此<code>_bucketMask</code>这个属性如果用二进制表示，则一定全部由1组成。举个例子体验一下，假设<code>capacity = 8</code>：</p>\n\n<ul>\n<li>bucket = 6，调用_next方法，返回值为 7 &amp; 7，也就是7.</li>\n<li>bucket = 7，调用_next方法，返回值为 8 &amp; 7，二进制表示为1000 &amp; 0111，因此返回值为0。也就是返回了数组的起始位置。</li>\n<li>bucket = 0，调用_prev方法，返回值为 -1 &amp; 7，二进制表示为1…1111 &amp; 0…0111，因此返回值为111，也就是7，回到了数组的结束位置。</li>\n</ul>\n\n<p>在插入一个键值对时，我们首先计算出Key对应哪个bucket，然后调用下面的方法把Key和Value写入到bucket中，同时把位图的值设置为true：</p>\n\n<pre><code class=\"language-swift\">@_transparent\ninternal func initializeKey(k: Key, value v: Value, at i: Int) {  \n  _sanityCheck(!isInitializedEntry(i))\n\n  (keys + i).initialize(k)\n  (values + i).initialize(v)\n  initializedEntries[i] = true\n  _fixLifetime(self)\n}\n</code></pre>\n\n<p>另一个需要重点介绍的函数是<code>_find</code>：</p>\n\n<ul>\n<li><code>_find</code>函数用于找到Key对应的bucket</li>\n<li>需要指定需要指定从哪个bucket开始寻找，因此需要<code>_buckey(key)</code>函数的配合</li>\n<li>如果参数key和某个bucket中的Key匹配，则返回这个bucket的位置</li>\n<li>如果没有找到，则返回接下来的第一个洞，表示key可以插入到这里</li>\n<li>通过位图判断当前bucket是不是一个洞</li>\n<li>这种算法被称为线性探测</li>\n</ul>\n\n<pre><code class=\"language-swift\">@warn_unused_result\ninternal  \nfunc _find(key: Key, _ startBucket: Int) -&gt; (pos: Index, found: Bool) {  \n  var bucket = startBucket\n  while true {\n    let isHole = !isInitializedEntry(bucket)\n    if isHole {\n      return (Index(nativeStorage: self, offset: bucket), false)\n    }\n    if keyAt(bucket) == key {\n      return (Index(nativeStorage: self, offset: bucket), true)\n    }\n    bucket = _next(bucket)\n  }\n}\n</code></pre>\n\n<ul>\n<li>一般来说，<code>_squeezeHashValue</code>函数的返回值就是Key对应的bucket的下标，不过需要考虑不同的Key哈希值冲突的情况。</li>\n<li>在这种情况下，<code>_find</code>函数会找到下一个可用的洞，以便插入数据。</li>\n</ul>\n\n<h2 id=\"hashvalue\">hashValue优化</h2>\n\n<p><code>_squeezeHashValue</code>函数的本质是对Key的哈希值再次求得哈希值，而一个优秀的哈希函数是提高性能的关键。<code>_squeezeHashValue</code>函数基本上符合要求，不过目前惟一的缺点是哈希变换的种子还是一个占位常量，有兴趣的读者可以阅读完整的函数实现，其中的<code>seed</code>就是一个值为<code>0xff51afd7ed558ccd</code>的常量：</p>\n\n<pre><code class=\"language-swift\">func _squeezeHashValue(hashValue: Int, _ resultRange: Range&lt;UInt&gt;) -&gt; UInt {  \n  let mixedHashValue = UInt(bitPattern: _mixInt(hashValue))\n  let resultCardinality: UInt = resultRange.endIndex - resultRange.startIndex\n  if _isPowerOf2(resultCardinality) {\n    return mixedHashValue &amp; (resultCardinality - 1)\n  }\n  return resultRange.startIndex + (mixedHashValue % resultCardinality)\n}\n\nfunc _mixUInt64(value: UInt64) -&gt; UInt64 {  \n  // Similar to hash_4to8_bytes but using a seed instead of length.\n  let seed: UInt64 = _HashingDetail.getExecutionSeed()\n  let low: UInt64 = value &amp; 0xffff_ffff\n  let high: UInt64 = value &gt;&gt; 32\n  return _HashingDetail.hash16Bytes(seed &amp;+ (low &lt;&lt; 3), high)\n}\n\nstatic func getExecutionSeed() -&gt; UInt64 {  \n  // FIXME: This needs to be a per-execution seed. This is just a placeholder\n  // implementation.\n  let seed: UInt64 = 0xff51afd7ed558ccd\n  return _HashingDetail.fixedSeedOverride == 0 ? seed : fixedSeedOverride\n}\n\nstatic func hash16Bytes(low: UInt64, _ high: UInt64) -&gt; UInt64 {  \n  // Murmur-inspired hashing.\n  let mul: UInt64 = 0x9ddfea08eb382d69\n  var a: UInt64 = (low ^ high) &amp;* mul\n  a ^= (a &gt;&gt; 47)\n  var b: UInt64 = (high ^ a) &amp;* mul\n  b ^= (b &gt;&gt; 47)\n  b = b &amp;* mul\n  return b\n}\n</code></pre>\n\n<p>目前，字典的结构总结如下：</p>\n\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1171077-7fb40bdc208d37f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\" /></p>\n\n<h2 id=\"_nativedictionarystorageowner\">_NativeDictionaryStorageOwner（类）</h2>\n\n<p>这个类被用于管理字典的引用计数，以支持写时复制(COW)特性。由于<code>Dictionary</code>和<code>DictionaryIndex</code>都会引用实际存储区域，所以引用计数为2。不过写时复制的唯一性检查不考虑由<code>DictionaryIndex</code>导致的引用，所以如果字典通过引用这个类的实例对象来管理引用计数值，问题就很容易处理。</p>\n\n<pre><code class=\"language-swift\">/// This class is an artifact of the COW implementation.  This class only\n/// exists to keep separate retain counts separate for:\n/// - `Dictionary` and `NSDictionary`,\n/// - `DictionaryIndex`.\n///\n/// This is important because the uniqueness check for COW only cares about\n/// retain counts of the first kind.\n\n/// 这个类用于区分以下两种引用：\n/// - `Dictionary` and `NSDictionary`,\n/// - `DictionaryIndex`.\n/// 这是因为写时复制的唯一性检查只考虑第一种引用\n</code></pre>\n\n<p>现在，字典的结构变得有些复杂，难以理解了：</p>\n\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1171077-41f6569f1fdf458a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\" /></p>\n\n<h2 id=\"_variantdictionarystoragekeyhashablevalue\">_VariantDictionaryStorage<Key : Hashable, Value> (枚举)</h2>\n\n<p>这个枚举类型中有两个成员，它们各自具有自己的关联值，分别表示Swift原生的字典和Cocoa的字典：</p>\n\n<pre><code class=\"language-swift\">case Native(_NativeDictionaryStorageOwner&lt;Key, Value&gt;)  \ncase Cocoa(_CocoaDictionaryStorage)  \n</code></pre>\n\n<p>这个枚举类型的主要功能是：</p>\n\n<ol>\n<li>根据字典的不同类型（原生 or Cocoa）执行对应的增删改查函数  </li>\n<li>如果字典已经满了，则扩容  </li>\n<li>更新或初始化Key-Value对：</li>\n</ol>\n\n<pre><code class=\"language-swift\">internal mutating func nativeUpdateValue(  \n    value: Value, forKey key: Key\n) -&gt; Value? {\n    var (i, found) = native._find(key, native._bucket(key))\n\n    let minCapacity = found\n      ? native.capacity\n      : NativeStorage.getMinCapacity(\n          native.count + 1,\n          native.maxLoadFactorInverse)\n\n    let (_, capacityChanged) = ensureUniqueNativeStorage(minCapacity)\n    if capacityChanged {\n        i = native._find(key, native._bucket(key)).pos\n    }\n\n    let oldValue: Value? = found ? native.valueAt(i.offset) : nil\n    if found {\n        native.setKey(key, value: value, at: i.offset)\n    } else {\n        native.initializeKey(key, value: value, at: i.offset)\n        native.count += 1\n    }\n\n    return oldValue\n}\n</code></pre>\n\n<ol>\n<li>如果移除某个Key-Value对，就会在原地留下一个洞。下一次线性查找时有可能会提前停止，为了解决这个问题，我们需要在移除Key-Value对后，移动另一个Key-Value对补上这个洞，源码如下：</li>\n</ol>\n\n<pre><code class=\"language-swift\">/// - parameter idealBucket: The ideal bucket for the element being deleted.\n/// - parameter offset: The offset of the element that will be deleted.\n/// Requires an initialized entry at offset.\ninternal mutating func nativeDeleteImpl(  \n      nativeStorage: NativeStorage, idealBucket: Int, offset: Int\n) {\n    _sanityCheck(\n      nativeStorage.isInitializedEntry(offset), \"expected initialized entry\")\n\n    // remove the element\n    nativeStorage.destroyEntryAt(offset)\n    nativeStorage.count -= 1\n\n    // If we've put a hole in a chain of contiguous elements, some\n    // element after the hole may belong where the new hole is.\n    var hole = offset\n\n    // Find the first bucket in the contiguous chain\n    var start = idealBucket\n    while nativeStorage.isInitializedEntry(nativeStorage._prev(start)) {\n        start = nativeStorage._prev(start)\n    }\n\n    // Find the last bucket in the contiguous chain\n    var lastInChain = hole\n    var b = nativeStorage._next(lastInChain)\n    while nativeStorage.isInitializedEntry(b) {\n        lastInChain = b\n        b = nativeStorage._next(b)\n    }\n\n    // Relocate out-of-place elements in the chain, repeating until\n    // none are found.\n    while hole != lastInChain {\n        // Walk backwards from the end of the chain looking for\n        // something out-of-place.\n        var b = lastInChain\n        while b != hole {\n            let idealBucket = nativeStorage._bucket(nativeStorage.keyAt(b))\n\n            // Does this element belong between start and hole?  We need\n            // two separate tests depending on whether [start,hole] wraps\n            // around the end of the buffer\n            let c0 = idealBucket &gt;= start\n            let c1 = idealBucket &lt;= hole                if start &lt;= hole ? (c0 &amp;&amp; c1) : (c0 || c1) {\n                break // Found it\n            }\n            b = nativeStorage._prev(b)\n        }\n\n        if b == hole { // No out-of-place elements found; we're done adjusting\n            break\n        }\n\n        // Move the found element into the hole\n        nativeStorage.moveInitializeFrom(nativeStorage, at: b, toEntryAt: hole)\n        hole = b\n    }\n}\n</code></pre>\n\n<p>这段代码理解起来可能比较费力，我想举一个例子来说明就比较简单了，假设一开始有8个bucket，bucket中的value就是bucket的下标，最后一个bucket是洞：</p>\n\n<pre><code class=\"language-swift\">Bucket数组中元素下标:  {0, 1, 2, 3, 4, 5, 6, 7(Hole)}  \nbucket中存储的Value:  {0, 1, 2, 3, 4, 5, 6,        }  \n</code></pre>\n\n<p>接下来我们删除第五个bucket，这会在原地留下一个洞：</p>\n\n<pre><code class=\"language-swift\">Bucket数组中元素下标:  {0, 1, 2, 3, 4(Hole), 5, 6, 7(Hole)}  \nbucket中存储的Value:  {0, 1, 2, 3,        , 5, 6         }  \n</code></pre>\n\n<p>为了补上这个洞，我们把最后一个bucket中的内容移到这个洞里，现在第五个bucket就不是洞了：</p>\n\n<pre><code class=\"language-swift\">Bucket数组中元素下标:  {0, 1, 2, 3, 4, 5, 6(Hole), 7(Hole)}  \nbucket中存储的Value:  {0, 1, 2, 3, 6, 5,        ,        }  \n</code></pre>\n\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1171077-5590943f50016dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"枚举\" /></p>\n\n<h2 id=\"\">字典的完整结构</h2>\n\n<p><code>Dictionary</code>结构体持有一个<code>_VariantDictionaryStorage</code>类型的枚举，作为自己的成员属性，所以整个字典完整的组成结构如下图所示：</p>\n\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1171077-ee0bbf3705805c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Swift字典结构\" /></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-28T15:46:50.000Z","created_by":1,"updated_at":"2016-01-28T16:30:43.000Z","updated_by":1,"published_at":"2016-01-28T15:48:03.000Z","published_by":1},{"id":18,"uuid":"53f0bbb5-b1d0-47e7-9b03-4b7372565271","title":"Swift中你应该知道的一些有用的tips","slug":"mysterious-tips","markdown":"本文会详细介绍一些Swift中不为大多数人知，又很有用的知识点。您不必一次性看完，不过或许哪一天这些知识就能派上用场，项目Demo在[我的github](https://github.com/bestswifter/MySampleCode/tree/master/SwiftMysterious)，您可以下载下来亲自实验一番，如果觉得有用还望点个star以示支持。\n\n本文主要的知识点有：\n\n* @noescape和@autoclosure\n* 内联lazy属性\n* 函数柯里化\n* 可变参数\n* dynamic关键字\n* 一些特殊的字面量\n* 循环标签\n\n## @noescape和@autoclosure\n\n关于这两个关键字的含义，在我此前的文章——[第六章——函数(自动闭包和内存)](http://www.jianshu.com/p/f9ba4c41d9c7)中已经有详细的解释，这里就简单总结概括一下：\n\n* @noescape：这个关键字告诉编译器，参数闭包只能在函数内部使用。它不能被赋值给临时变量，不能异步调用，也不能作为未标记为@noescape的参数传递给其他函数。总之您可以放心，它无法在这个函数作用域之外使用。\n\n\t除了安全性上的保证，swift还会为标记为@noescape的参数做一些优化，闭包内访问类的成员时您还可以省去`self.`的语法。\n\t\n* @autoclosure：这个关键字将表达式封装成闭包，优点在于延迟了表达式的执行，缺点是如果滥用会导致代码可读性降低。\n\n## 内联lazy属性\n\n标记为lazy的属性在对象初始化时不会被创建，它直到第一次被访问时才会创建，通常情况下它是这样实现的：\n\n```swift\nclass PersonOld {\n    lazy var expensiveObject: ExpensiveObject = {\n        return self.createExpensiveObject()    // 传统实现方式\n    }()\n    \n    private func createExpensiveObject() -> ExpensiveObject {\n        return ExpensiveObject()\n    }\n}\n```\n\nlazy属性本质上是一个闭包，闭包中的表达式只会调用一次。需要强调的是，虽然这个闭包中捕获了`self`，但是这样做并不会导致循环引用，猜测是Swift自动把`self`标记为unowned了。\n\n这样的写法其实可以进行简化，简化后的实现如下：\n\n```swift\nclass Person {\n    lazy var expensiveObject: ExpensiveObject = self.createExpensiveObject()\n    \n    private func createExpensiveObject() -> ExpensiveObject {\n        return ExpensiveObject()\n    }\n}\n```\n\n## 函数柯里化\n\n函数柯里化也是一个老生常谈的问题了，我的这篇文章——[第六章——函数（函数的便捷性）](http://www.jianshu.com/p/b2d21b85a387)对其有比较详细的解释。\n\n简单来说，柯里化函数处理一个参数，然后返回一个函数处理剩下来的所有参数。直观上来看，它避免了很多括号的嵌套，提高了代码的简洁性和可读性，比如这个函数：\n\n```swift\nfunc fourChainedFunctions(a: Int) -> (Int -> (Int -> (Int -> Int))) {\n    return { b in\n        return { c in\n            return { d in\n                return a + b + c + d\n            }\n        }\n    }\n}\nfourChainedFunctions(1)(2)(3)(4)\n```\n\n对比一下它的柯里化版本：\n\n```swift\nfunc fourChainedFunctions(a: Int)(b: Int)(c: Int)(d: Int) -> Int {\n    return a + b + c + d\n}\n```\n\n不过我不打算在这里过多的介绍函数柯里化，如果您对它还不了解，我甚至建议您不用了解了。因为Swift 3.0已经确定停止使用函数柯里化了(一些使用函数式编程的库哭晕在厕所)。\n\n您可以在[Swift Programming Language Evolution](https://github.com/apple/swift-evolution)中查看更多细节：\n\n![](http://images.bestswifter.com/20160129/evolution.png)\n\n或者您也可以点击这篇文章查看更多细节——[Removing currying func declaration syntax](https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md)\n\n## 可变参数\n\n如果在参数类型后面加上三个\".\"，表示参数的数量是可变的，如果您有过Java编程的经验，对此应该会比较熟悉：\n\n```swift\nfunc printEverythingWithAKrakenEmojiInBetween(objectsToPrint: Any...) {\n    for object in objectsToPrint {\n        print(\"\\(object)🐙\")\n    }\n}\nprintEverythingWithAKrakenEmojiInBetween(\"Hey\", \"Look\", \"At\", \"Me\", \"!\")\n```\n\n此时，参数可以当做`SequenceType`类型来使用，也就是说可以使用`for in`语法遍历其中的每一个参数。\n\n可变参数并不是什么罕见的语法，比如`print`函数就是用了可变参数，更多详细的分析请移步：[你其实真的不懂print(\"Hello,world\")](http://www.jianshu.com/p/abb55919c453)\n\n\n## dynamic关键字\n\n如果您有过OC的开发经验，那一定会对OC中@dynamic关键字比较熟悉，它告诉编译器不要为属性合成getter和setter方法。\n\nSwift中也有dynamic关键字，它可以用于修饰变量或函数，它的意思也与OC完全不同。它告诉编译器使用动态分发而不是静态分发。OC区别于其他语言的一个特点在于它的动态性，任何方法调用实际上都是消息分发，而Swift则尽可能做到静态分发。\n\n因此，标记为dynamic的变量/函数会隐式的加上@objc关键字，它会使用OC的runtime机制。\n\n虽然静态分发在效率上可能更好，不过一些app分析统计的库需要依赖动态分发的特性，动态的添加一些统计代码，这一点在Swift的静态分发机制下很难完成。这种情况下，虽然使用dynamic关键字会牺牲因为使用静态分发而获得的一些性能优化，但也依然是值得的。\n\n```swift\nclass Kraken {\n    dynamic var imADynamicallyDispatchedString: String\n\n    dynamic func imADynamicallyDispatchedFunction() {\n        //Hooray for dynamic dispatch!\n    }\n}\n```\n\n使用动态分发，您可以更好的与OC中runtime的一些特性（如CoreData，KVC/KVO）进行交互，不过如果您不能确定变量或函数会被动态的修改、添加或使用了Method-Swizzle，那么就不应该使用dynamic关键字，否则有可能程序崩溃。\n\n## 特殊的字面量\n\n在开发或调试过程中如果能用好下面这四个字面量，将会起到事半功倍的效果：\n\n* \\_\\_FILE__：当前代码在那个文件中\n* \\_\\_FUNCTION__：当前代码在该文件的那个函数中\n* \\_\\_LINE__：当前代码在该文件的第多少行\n* \\_\\_COLUMN__：当前代码在改行的多少列\n\n举个实际例子，您可以在demo中运行体验一番：\n\n```swift\nfunc specialLitertalExpression() {\n    print(__FILE__)\n    print(__FUNCTION__)\n    print(__LINE__)\n    print(__COLUMN__)   // 输出结果为11，因为有4个空格，print是五个字符，还有一个左括号。\n}\n```\n\n一般情况下最常用的字面量是`__FUNCTION__ `，它可以很容易让程序员明白自己调用的方法的方法名。\n\n## 循环标签\n\n通常意义上的循环标签主要是`continue`和`break`，不过swift在此基础上做了一些拓展，比如下面这段代码：\n\n```swift\nlet firstNames = [\"Neil\",\"Kt\",\"Bob\"]\nlet lastNames = [\"Zhou\",\"Zhang\",\"Wang\",\"Li\"]\nfor firstName in firstNames {\n    var isFound = false\n    for lastName in lastNames {\n        if firstName == \"Kt\" && lastName == \"Zhang\" {\n            isFound = true\n            break\n        }\n        print(firstName + \" \" + lastName)\n    }\n    \n    if isFound {\n        break\n    }\n}\n```\n\n目的是希望找到分别在两个数组中找到字符串\"Kt\"和\"Zhang\"，在此之前会打印所有遍历到的字符。\n\n在结束内层循环后，我希望外层循环也随之立刻停止，为了实现这个功能，我不得不引入了`isFound `参数。然而实际上我需要的只是可以指定停止哪个循环而已：\n\n```swift\noutsideloop: for firstName in firstNames {\n    innerloop: for lastName in lastNames {\n        if firstName == \"Kt\" && lastName == \"Zhang\" {\n            break outsideloop\t//人为指定break外层循环\n        }\n        print(firstName + \" \" + lastName)\n    }\n}\n```\n\n以上两段代码等价，可以看到使用了循环标签后，代码明显简洁了很多。","html":"<p>本文会详细介绍一些Swift中不为大多数人知，又很有用的知识点。您不必一次性看完，不过或许哪一天这些知识就能派上用场，项目Demo在<a href=\"https://github.com/bestswifter/MySampleCode/tree/master/SwiftMysterious\">我的github</a>，您可以下载下来亲自实验一番，如果觉得有用还望点个star以示支持。</p>\n\n<p>本文主要的知识点有：</p>\n\n<ul>\n<li>@noescape和@autoclosure</li>\n<li>内联lazy属性</li>\n<li>函数柯里化</li>\n<li>可变参数</li>\n<li>dynamic关键字</li>\n<li>一些特殊的字面量</li>\n<li>循环标签</li>\n</ul>\n\n<h2 id=\"noescapeautoclosure\">@noescape和@autoclosure</h2>\n\n<p>关于这两个关键字的含义，在我此前的文章——<a href=\"http://www.jianshu.com/p/f9ba4c41d9c7\">第六章——函数(自动闭包和内存)</a>中已经有详细的解释，这里就简单总结概括一下：</p>\n\n<ul>\n<li><p>@noescape：这个关键字告诉编译器，参数闭包只能在函数内部使用。它不能被赋值给临时变量，不能异步调用，也不能作为未标记为@noescape的参数传递给其他函数。总之您可以放心，它无法在这个函数作用域之外使用。</p>\n\n<p>除了安全性上的保证，swift还会为标记为@noescape的参数做一些优化，闭包内访问类的成员时您还可以省去<code>self.</code>的语法。</p></li>\n<li><p>@autoclosure：这个关键字将表达式封装成闭包，优点在于延迟了表达式的执行，缺点是如果滥用会导致代码可读性降低。</p></li>\n</ul>\n\n<h2 id=\"lazy\">内联lazy属性</h2>\n\n<p>标记为lazy的属性在对象初始化时不会被创建，它直到第一次被访问时才会创建，通常情况下它是这样实现的：</p>\n\n<pre><code class=\"language-swift\">class PersonOld {  \n    lazy var expensiveObject: ExpensiveObject = {\n        return self.createExpensiveObject()    // 传统实现方式\n    }()\n\n    private func createExpensiveObject() -&gt; ExpensiveObject {\n        return ExpensiveObject()\n    }\n}\n</code></pre>\n\n<p>lazy属性本质上是一个闭包，闭包中的表达式只会调用一次。需要强调的是，虽然这个闭包中捕获了<code>self</code>，但是这样做并不会导致循环引用，猜测是Swift自动把<code>self</code>标记为unowned了。</p>\n\n<p>这样的写法其实可以进行简化，简化后的实现如下：</p>\n\n<pre><code class=\"language-swift\">class Person {  \n    lazy var expensiveObject: ExpensiveObject = self.createExpensiveObject()\n\n    private func createExpensiveObject() -&gt; ExpensiveObject {\n        return ExpensiveObject()\n    }\n}\n</code></pre>\n\n<h2 id=\"\">函数柯里化</h2>\n\n<p>函数柯里化也是一个老生常谈的问题了，我的这篇文章——<a href=\"http://www.jianshu.com/p/b2d21b85a387\">第六章——函数（函数的便捷性）</a>对其有比较详细的解释。</p>\n\n<p>简单来说，柯里化函数处理一个参数，然后返回一个函数处理剩下来的所有参数。直观上来看，它避免了很多括号的嵌套，提高了代码的简洁性和可读性，比如这个函数：</p>\n\n<pre><code class=\"language-swift\">func fourChainedFunctions(a: Int) -&gt; (Int -&gt; (Int -&gt; (Int -&gt; Int))) {  \n    return { b in\n        return { c in\n            return { d in\n                return a + b + c + d\n            }\n        }\n    }\n}\nfourChainedFunctions(1)(2)(3)(4)  \n</code></pre>\n\n<p>对比一下它的柯里化版本：</p>\n\n<pre><code class=\"language-swift\">func fourChainedFunctions(a: Int)(b: Int)(c: Int)(d: Int) -&gt; Int {  \n    return a + b + c + d\n}\n</code></pre>\n\n<p>不过我不打算在这里过多的介绍函数柯里化，如果您对它还不了解，我甚至建议您不用了解了。因为Swift 3.0已经确定停止使用函数柯里化了(一些使用函数式编程的库哭晕在厕所)。</p>\n\n<p>您可以在<a href=\"https://github.com/apple/swift-evolution\">Swift Programming Language Evolution</a>中查看更多细节：</p>\n\n<p><img src=\"http://images.bestswifter.com/20160129/evolution.png\" alt=\"\" /></p>\n\n<p>或者您也可以点击这篇文章查看更多细节——<a href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md\">Removing currying func declaration syntax</a></p>\n\n<h2 id=\"\">可变参数</h2>\n\n<p>如果在参数类型后面加上三个\".\"，表示参数的数量是可变的，如果您有过Java编程的经验，对此应该会比较熟悉：</p>\n\n<pre><code class=\"language-swift\">func printEverythingWithAKrakenEmojiInBetween(objectsToPrint: Any...) {  \n    for object in objectsToPrint {\n        print(\"\\(object)🐙\")\n    }\n}\nprintEverythingWithAKrakenEmojiInBetween(\"Hey\", \"Look\", \"At\", \"Me\", \"!\")  \n</code></pre>\n\n<p>此时，参数可以当做<code>SequenceType</code>类型来使用，也就是说可以使用<code>for in</code>语法遍历其中的每一个参数。</p>\n\n<p>可变参数并不是什么罕见的语法，比如<code>print</code>函数就是用了可变参数，更多详细的分析请移步：<a href=\"http://www.jianshu.com/p/abb55919c453\">你其实真的不懂print(\"Hello,world\")</a></p>\n\n<h2 id=\"dynamic\">dynamic关键字</h2>\n\n<p>如果您有过OC的开发经验，那一定会对OC中@dynamic关键字比较熟悉，它告诉编译器不要为属性合成getter和setter方法。</p>\n\n<p>Swift中也有dynamic关键字，它可以用于修饰变量或函数，它的意思也与OC完全不同。它告诉编译器使用动态分发而不是静态分发。OC区别于其他语言的一个特点在于它的动态性，任何方法调用实际上都是消息分发，而Swift则尽可能做到静态分发。</p>\n\n<p>因此，标记为dynamic的变量/函数会隐式的加上@objc关键字，它会使用OC的runtime机制。</p>\n\n<p>虽然静态分发在效率上可能更好，不过一些app分析统计的库需要依赖动态分发的特性，动态的添加一些统计代码，这一点在Swift的静态分发机制下很难完成。这种情况下，虽然使用dynamic关键字会牺牲因为使用静态分发而获得的一些性能优化，但也依然是值得的。</p>\n\n<pre><code class=\"language-swift\">class Kraken {  \n    dynamic var imADynamicallyDispatchedString: String\n\n    dynamic func imADynamicallyDispatchedFunction() {\n        //Hooray for dynamic dispatch!\n    }\n}\n</code></pre>\n\n<p>使用动态分发，您可以更好的与OC中runtime的一些特性（如CoreData，KVC/KVO）进行交互，不过如果您不能确定变量或函数会被动态的修改、添加或使用了Method-Swizzle，那么就不应该使用dynamic关键字，否则有可能程序崩溃。</p>\n\n<h2 id=\"\">特殊的字面量</h2>\n\n<p>在开发或调试过程中如果能用好下面这四个字面量，将会起到事半功倍的效果：</p>\n\n<ul>\n<li>__FILE__：当前代码在那个文件中</li>\n<li>__FUNCTION__：当前代码在该文件的那个函数中</li>\n<li>__LINE__：当前代码在该文件的第多少行</li>\n<li>__COLUMN__：当前代码在改行的多少列</li>\n</ul>\n\n<p>举个实际例子，您可以在demo中运行体验一番：</p>\n\n<pre><code class=\"language-swift\">func specialLitertalExpression() {  \n    print(__FILE__)\n    print(__FUNCTION__)\n    print(__LINE__)\n    print(__COLUMN__)   // 输出结果为11，因为有4个空格，print是五个字符，还有一个左括号。\n}\n</code></pre>\n\n<p>一般情况下最常用的字面量是<code>__FUNCTION__</code>，它可以很容易让程序员明白自己调用的方法的方法名。</p>\n\n<h2 id=\"\">循环标签</h2>\n\n<p>通常意义上的循环标签主要是<code>continue</code>和<code>break</code>，不过swift在此基础上做了一些拓展，比如下面这段代码：</p>\n\n<pre><code class=\"language-swift\">let firstNames = [\"Neil\",\"Kt\",\"Bob\"]  \nlet lastNames = [\"Zhou\",\"Zhang\",\"Wang\",\"Li\"]  \nfor firstName in firstNames {  \n    var isFound = false\n    for lastName in lastNames {\n        if firstName == \"Kt\" &amp;&amp; lastName == \"Zhang\" {\n            isFound = true\n            break\n        }\n        print(firstName + \" \" + lastName)\n    }\n\n    if isFound {\n        break\n    }\n}\n</code></pre>\n\n<p>目的是希望找到分别在两个数组中找到字符串\"Kt\"和\"Zhang\"，在此之前会打印所有遍历到的字符。</p>\n\n<p>在结束内层循环后，我希望外层循环也随之立刻停止，为了实现这个功能，我不得不引入了<code>isFound</code>参数。然而实际上我需要的只是可以指定停止哪个循环而已：</p>\n\n<pre><code class=\"language-swift\">outsideloop: for firstName in firstNames {  \n    innerloop: for lastName in lastNames {\n        if firstName == \"Kt\" &amp;&amp; lastName == \"Zhang\" {\n            break outsideloop    //人为指定break外层循环\n        }\n        print(firstName + \" \" + lastName)\n    }\n}\n</code></pre>\n\n<p>以上两段代码等价，可以看到使用了循环标签后，代码明显简洁了很多。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-29T14:19:24.000Z","created_by":1,"updated_at":"2016-01-29T14:20:00.000Z","updated_by":1,"published_at":"2016-01-29T14:20:00.000Z","published_by":1},{"id":19,"uuid":"20d7818d-dcbc-4a1d-8743-36f18e8e87e3","title":"细说OC中的load和initialize方法","slug":"load-and-initialize","markdown":"OC中有两个特殊的类方法，分别是`load`和`initialize`。本文总结一下这两个方法的区别于联系、使用场景和注意事项。Demo可以在我的Github上找到——[load和initialize](https://github.com/bestswifter/MySampleCode/tree/master/load)，如果觉得有帮助还望点个star以示支持，总结在文章末尾。\n\n# load\n\n顾名思义，`load`方法在这个文件被程序装载时调用。只要是在Compile Sources中出现的文件总是会被装载，这与这个类是否被用到无关，因此`load`方法总是在`main`函数之前调用。\n\n### 调用规则\n \n如果一个类实现了`load`方法，在调用这个方法前会首先调用父类的`load`方法。而且这个过程是自动完成的，并不需要我们手动实现：\n\n```objc\n// In Parent.m\n+ (void)load {\n    NSLog(@\"Load Class Parent\");\n}\n\n// In Child.m，继承自Parent\n+ (void)load {\n    NSLog(@\"Load Class Child\");\n}\n\n// In Child+load.m，Child类的分类\n+ (void)load {\n    NSLog(@\"Load Class Child+load\");\n}\n\n// 运行结果：\n/*\n\t2016-02-01 21:28:14.379 load[11789:1435378] Load Class Parent\n\t2016-02-01 21:28:14.380 load[11789:1435378] Load Class Child\n\t2016-02-01 22:28:14.381 load[11789:1435378] Load Class Child+load\n*/\n```\n\n如果一个类没有实现`load`方法，那么就不会调用它父类的`load`方法，这一点与正常的类继承和方法调用不一样，需要额外注意一下。\n\n### 执行顺序\n\n`load`方法调用时，系统处于脆弱状态，如果调用别的类的方法，且该方法依赖于那个类的`load`方法进行初始化设置，那么必须确保那个类的`load`方法已经调用了，比如demo中的这段代码，打印出的字符串就为`null`：\n\n```objc\n// In Child.m\n+ (void)load {\n    NSLog(@\"Load Class Child\");\n    \n    Other *other = [Other new];\n    [other originalFunc];\n    \n    // 如果不先调用other的load，下面这行代码就无效，打印出null\n    [Other printName];\n}\n```\n\n`load`方法的调用顺序其实有迹可循，我们看到demo的项目设置如下：\n\n![执行顺序](http://images.bestswifter.com/load/order.png)\n\n在Compile Sources中，文件的排放顺序就是其转载顺序，自然也就是`load`方法调用的顺序。这一点也证明了`load`方法中会自动调用父类的方法，因为在demo的输出结果中，`Parent`的`load`方法先于`Child`调用，而它的装载顺序其实在`Child`之后。\n\n虽然在这种简单情况下我们可以辨别出各个类的`load`方法调用的顺序，但**永远不要**依赖这个顺序完成你的代码逻辑。一方面，这在后期的开发中极容易导致错误，另一方面，你实际上并不需要这么做。\n\n### 使用场景\n\n由于调用`load`方法时的环境很不安全，我们应该尽量减少`load`方法的逻辑。另一个原因是`load`方法是线程安全的，它内部使用了锁，所以我们应该避免线程阻塞在`load`方法中。\n\n一个常见的使用场景是在`load`方法中实现Method Swizzle：\n\n```objc\n// In Other.m\n+ (void)load {\n    Method originalFunc = class_getInstanceMethod([self class], @selector(originalFunc));\n    Method swizzledFunc = class_getInstanceMethod([self class], @selector(swizzledFunc));\n    \n    method_exchangeImplementations(originalFunc, swizzledFunc);\n}\n```\n\n在`Child`类的`load`方法中，由于还没调用`Other`的`load`方法，所以输出结果是\"Original Output\"，而在main函数中，输出结果自然就变成了\"Swizzled Output\"。\n\n一般来说，除了Method Swizzle，别的逻辑都不应该放在`load`方法中实现。\n\n# initialize\n\n这个方法在第一次给某个类发送消息时调用（比如实例化一个对象），并且只会调用一次。`initialize`方法实际上是一种惰性调用，也就是说如果一个类一直没被用到，那它的`initialize`方法也不会被调用，这一点有利用节约资源。\n\n### 调用规则\n\n与`load`方法类似的是，在`initialize`方法内部也会调用父类的方法，而且不需要我们显示的写出来。与`load`方法不同之处在于，即使子类没有实现`initialize`方法，也会调用父类的方法，这会导致一个很严重的问题：\n\n```objc\n// In Parent.m\n+ (void)initialize {\n    NSLog(@\"Initialize Parent, caller Class %@\", [self class]);\n}\n\n// In Child.m\n// 注释掉initialize方法\n\n// In main.m\nChild *child = [Child new];\n```\n\n运行后发现父类的`initialize`方法竟然调用了两次：\n\n```objc\n2016-02-01 22:57:02.985 load[12772:1509345] Initialize Parent, caller Class Parent\n2016-02-01 22:57:02.985 load[12772:1509345] Initialize Parent, caller Class Child\n```\n\n这是因为在创建子类对象时，首先要创建父类对象，所以会调用一次父类的`initialize`方法，然后创建子类时，尽管自己没有实现`initialize`方法，但还是会调用到父类的方法。\n\n虽然`initialize`方法对一个类而言只会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求。正确使用`initialize`方法的姿势如下：\n\n```objc\n// In Parent.m\n+ (void)initialize {\n    if (self == [Parent class]) {\n        NSLog(@\"Initialize Parent, caller Class %@\", [self class]);\n    }\n}\n```\n\n加上判断后，就不会因为子类而调用到自己的`initialize`方法了。\n\n### 使用场景\n\n`initialize`方法主要用来对一些不方便在编译期初始化的对象进行赋值。比如`NSMutableArray`这种类型的实例化依赖于runtime的消息发送，所以显然无法在编译器初始化：\n\n```objc\n// In Parent.m\nstatic int someNumber = 0;\t // int类型可以在编译期赋值\nstatic NSMutableArray *someObjects;\n\n+ (void)initialize {\n    if (self == [Parent class]) {\n\t    // 不方便编译期复制的对象在这里赋值\n        someObjects = [[NSMutableArray alloc] init];\n    }\n}\n```\n\n# 总结\n\n1. `load`和`initialize`方法都会在实例化对象之前调用，以main函数为分水岭，前者在main函数之前调用，后者在之后调用。这两个方法会被自动调用，不能手动调用它们。\n2. `load`和`initialize`方法都不用显式的调用父类的方法而是自动调用，即使子类没有`initialize`方法也会调用父类的方法，而`load`方法则不会调用父类。\n3. `load`方法通常用来进行Method Swizzle，`initialize`方法一般用于初始化全局变量或静态变量。\n4. `load`和`initialize`方法内部使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁。","html":"<p>OC中有两个特殊的类方法，分别是<code>load</code>和<code>initialize</code>。本文总结一下这两个方法的区别于联系、使用场景和注意事项。Demo可以在我的Github上找到——<a href=\"https://github.com/bestswifter/MySampleCode/tree/master/load\">load和initialize</a>，如果觉得有帮助还望点个star以示支持，总结在文章末尾。</p>\n\n<h1 id=\"load\">load</h1>\n\n<p>顾名思义，<code>load</code>方法在这个文件被程序装载时调用。只要是在Compile Sources中出现的文件总是会被装载，这与这个类是否被用到无关，因此<code>load</code>方法总是在<code>main</code>函数之前调用。</p>\n\n<h3 id=\"\">调用规则</h3>\n\n<p>如果一个类实现了<code>load</code>方法，在调用这个方法前会首先调用父类的<code>load</code>方法。而且这个过程是自动完成的，并不需要我们手动实现：</p>\n\n<pre><code class=\"language-objc\">// In Parent.m\n+ (void)load {\n    NSLog(@\"Load Class Parent\");\n}\n\n// In Child.m，继承自Parent\n+ (void)load {\n    NSLog(@\"Load Class Child\");\n}\n\n// In Child+load.m，Child类的分类\n+ (void)load {\n    NSLog(@\"Load Class Child+load\");\n}\n\n// 运行结果：\n/*\n    2016-02-01 21:28:14.379 load[11789:1435378] Load Class Parent\n    2016-02-01 21:28:14.380 load[11789:1435378] Load Class Child\n    2016-02-01 22:28:14.381 load[11789:1435378] Load Class Child+load\n*/\n</code></pre>\n\n<p>如果一个类没有实现<code>load</code>方法，那么就不会调用它父类的<code>load</code>方法，这一点与正常的类继承和方法调用不一样，需要额外注意一下。</p>\n\n<h3 id=\"\">执行顺序</h3>\n\n<p><code>load</code>方法调用时，系统处于脆弱状态，如果调用别的类的方法，且该方法依赖于那个类的<code>load</code>方法进行初始化设置，那么必须确保那个类的<code>load</code>方法已经调用了，比如demo中的这段代码，打印出的字符串就为<code>null</code>：</p>\n\n<pre><code class=\"language-objc\">// In Child.m\n+ (void)load {\n    NSLog(@\"Load Class Child\");\n\n    Other *other = [Other new];\n    [other originalFunc];\n\n    // 如果不先调用other的load，下面这行代码就无效，打印出null\n    [Other printName];\n}\n</code></pre>\n\n<p><code>load</code>方法的调用顺序其实有迹可循，我们看到demo的项目设置如下：</p>\n\n<p><img src=\"http://images.bestswifter.com/load/order.png\" alt=\"执行顺序\" /></p>\n\n<p>在Compile Sources中，文件的排放顺序就是其转载顺序，自然也就是<code>load</code>方法调用的顺序。这一点也证明了<code>load</code>方法中会自动调用父类的方法，因为在demo的输出结果中，<code>Parent</code>的<code>load</code>方法先于<code>Child</code>调用，而它的装载顺序其实在<code>Child</code>之后。</p>\n\n<p>虽然在这种简单情况下我们可以辨别出各个类的<code>load</code>方法调用的顺序，但<strong>永远不要</strong>依赖这个顺序完成你的代码逻辑。一方面，这在后期的开发中极容易导致错误，另一方面，你实际上并不需要这么做。</p>\n\n<h3 id=\"\">使用场景</h3>\n\n<p>由于调用<code>load</code>方法时的环境很不安全，我们应该尽量减少<code>load</code>方法的逻辑。另一个原因是<code>load</code>方法是线程安全的，它内部使用了锁，所以我们应该避免线程阻塞在<code>load</code>方法中。</p>\n\n<p>一个常见的使用场景是在<code>load</code>方法中实现Method Swizzle：</p>\n\n<pre><code class=\"language-objc\">// In Other.m\n+ (void)load {\n    Method originalFunc = class_getInstanceMethod([self class], @selector(originalFunc));\n    Method swizzledFunc = class_getInstanceMethod([self class], @selector(swizzledFunc));\n\n    method_exchangeImplementations(originalFunc, swizzledFunc);\n}\n</code></pre>\n\n<p>在<code>Child</code>类的<code>load</code>方法中，由于还没调用<code>Other</code>的<code>load</code>方法，所以输出结果是\"Original Output\"，而在main函数中，输出结果自然就变成了\"Swizzled Output\"。</p>\n\n<p>一般来说，除了Method Swizzle，别的逻辑都不应该放在<code>load</code>方法中实现。</p>\n\n<h1 id=\"initialize\">initialize</h1>\n\n<p>这个方法在第一次给某个类发送消息时调用（比如实例化一个对象），并且只会调用一次。<code>initialize</code>方法实际上是一种惰性调用，也就是说如果一个类一直没被用到，那它的<code>initialize</code>方法也不会被调用，这一点有利用节约资源。</p>\n\n<h3 id=\"\">调用规则</h3>\n\n<p>与<code>load</code>方法类似的是，在<code>initialize</code>方法内部也会调用父类的方法，而且不需要我们显示的写出来。与<code>load</code>方法不同之处在于，即使子类没有实现<code>initialize</code>方法，也会调用父类的方法，这会导致一个很严重的问题：</p>\n\n<pre><code class=\"language-objc\">// In Parent.m\n+ (void)initialize {\n    NSLog(@\"Initialize Parent, caller Class %@\", [self class]);\n}\n\n// In Child.m\n// 注释掉initialize方法\n\n// In main.m\nChild *child = [Child new];  \n</code></pre>\n\n<p>运行后发现父类的<code>initialize</code>方法竟然调用了两次：</p>\n\n<pre><code class=\"language-objc\">2016-02-01 22:57:02.985 load[12772:1509345] Initialize Parent, caller Class Parent  \n2016-02-01 22:57:02.985 load[12772:1509345] Initialize Parent, caller Class Child  \n</code></pre>\n\n<p>这是因为在创建子类对象时，首先要创建父类对象，所以会调用一次父类的<code>initialize</code>方法，然后创建子类时，尽管自己没有实现<code>initialize</code>方法，但还是会调用到父类的方法。</p>\n\n<p>虽然<code>initialize</code>方法对一个类而言只会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求。正确使用<code>initialize</code>方法的姿势如下：</p>\n\n<pre><code class=\"language-objc\">// In Parent.m\n+ (void)initialize {\n    if (self == [Parent class]) {\n        NSLog(@\"Initialize Parent, caller Class %@\", [self class]);\n    }\n}\n</code></pre>\n\n<p>加上判断后，就不会因为子类而调用到自己的<code>initialize</code>方法了。</p>\n\n<h3 id=\"\">使用场景</h3>\n\n<p><code>initialize</code>方法主要用来对一些不方便在编译期初始化的对象进行赋值。比如<code>NSMutableArray</code>这种类型的实例化依赖于runtime的消息发送，所以显然无法在编译器初始化：</p>\n\n<pre><code class=\"language-objc\">// In Parent.m\nstatic int someNumber = 0;     // int类型可以在编译期赋值  \nstatic NSMutableArray *someObjects;\n\n+ (void)initialize {\n    if (self == [Parent class]) {\n        // 不方便编译期复制的对象在这里赋值\n        someObjects = [[NSMutableArray alloc] init];\n    }\n}\n</code></pre>\n\n<h1 id=\"\">总结</h1>\n\n<ol>\n<li><code>load</code>和<code>initialize</code>方法都会在实例化对象之前调用，以main函数为分水岭，前者在main函数之前调用，后者在之后调用。这两个方法会被自动调用，不能手动调用它们。  </li>\n<li><code>load</code>和<code>initialize</code>方法都不用显式的调用父类的方法而是自动调用，即使子类没有<code>initialize</code>方法也会调用父类的方法，而<code>load</code>方法则不会调用父类。  </li>\n<li><code>load</code>方法通常用来进行Method Swizzle，<code>initialize</code>方法一般用于初始化全局变量或静态变量。  </li>\n<li><code>load</code>和<code>initialize</code>方法内部使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁。</li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-02-01T15:31:51.000Z","created_by":1,"updated_at":"2016-02-12T02:19:38.000Z","updated_by":1,"published_at":"2016-02-01T15:32:29.000Z","published_by":1},{"id":20,"uuid":"eb3952d1-f4de-41ed-b4da-8f1bbe672098","title":"iOS自定义转场动画实战讲解","slug":"custom-transition-animation","markdown":"转场动画这事，说简单也简单，可以通过`presentViewController:animated:completion:`和`dismissViewControllerAnimated:completion:`这一组函数以模态视图的方式展现、隐藏视图。如果用到了`navigationController`，还可以调用`pushViewController:animated:`和`popViewController`这一组函数将新的视图控制器压栈、弹栈。\n\n下图中所有转场动画都是自定义的动画，这些效果如果不用自定义动画则很难甚至无法实现：\n\n![demo演示](http://images.bestswifter.com/CustomTransition/demo.gif)\n\n由于录屏的原因，有些效果无法完全展现，比如它其实还支持横屏。\n\n自定义转场动画的效果实现起来比较复杂，如果仅仅是拷贝一份能够运行的代码却不懂其中原理，就有可能带来各种隐藏的bug。本文由浅入深介绍下面几个知识：\n\n1. 传统的基于闭包的实现方式及其缺点\n2. 自定义present转场动画\n3. 交互式(Interactive)转场动画\n4. 转场协调器与UIModalPresentationCustom\n5. UINavigationController转场动画\n\n我为这篇教程制作了一个demo，您可以去在我的github上clone下来：[CustomTransition](https://github.com/bestswifter/MySampleCode/tree/master/CustomTransition)，如果觉得有帮助还望给个star以示支持。本文以Swift+纯代码实现，对应的OC+Storyboard版本在demo中也可以找到，那是苹果的官方示范代码，正确性更有保证。demo中用到了CocoaPods，您也许需要执行`pod install`命令并打开`.xcworkspace`文件。\n\n在开始正式的教程前，您首先需要下载demo，在代码面前文字是苍白的，demo中包含的注释足以解释本文所有的知识点。其次，您还得了解这几个背景知识。\n\n### From和To\n\n在代码和文字中，经常会出现`fromView`和`toView`。如果错误的理解它们的含义会导致动画逻辑完全错误。`fromView`表示当前视图，`toView`表示要跳转到的视图。如果是从A视图控制器present到B，则A是from，B是to。从B视图控制器dismiss到A时，B变成了from，A是to。用一张图表示：\n\n![from和to](http://images.bestswifter.com/CustomTransition/fromto.png)\n\n### Presented和Presenting\n\n这也是一组相对的概念，它容易与`fromView`和`toView`混淆。简单来说，它不受present或dismiss的影响，如果是从A视图控制器present到B，那么A总是B的`presentingViewController`,B总是A的`presentedViewController`。\n### modalPresentationStyle\n\n这是一个枚举类型，表示present时动画的类型。其中可以自定义动画效果的只有两种：`FullScreen `和`Custom`，两者的区别在于`FullScreen `会移除`fromView`，而`Custom`不会。比如文章开头的gif中，第三个动画效果就是`Custom`。\n\n# 基于block的动画\n\n最简单的转场动画是使用`transitionFromViewController`方法：\n\n![传统的转场动画实现](http://images.bestswifter.com/CustomTransition/blockbased_animation.png)\n\n这个方法虽然已经过时，但是对它的分析有助于后面知识的理解。它一共有6个参数，前两个表示从哪个VC开始，跳转到哪个VC，中间两个参数表示动画的时间和选项。最后两个参数表示动画的具体实现细节和回调闭包。\n\n这六个参数其实就是一次转场动画所必备的六个元素。它们可以分为两组，前两个参数为一组，表示页面的跳转关系，后面四个为一组，表示动画的执行逻辑。\n\n这个方法的缺点之一是可自定义程度不高(在后面您会发现能自定义的不仅仅是动画方式)，另一个缺点则是重用性不好，也可以说是耦合度比较大。\n\n在最后两个闭包参数中，可以预见的是`fromViewController`和`toViewController`参数都会被用到，而且他们是动画的关键。假设视图控制器A可以跳转到B、C、D、E、F，而且跳转动画基本相似，您会发现`transitionFromViewController`方法要被复制多次，每次只会修改少量内容。\n\n# 自定义present转场动画\n\n出于解耦和提高可自定义程度的考虑，我们来学习转场动画的正确使用姿势。\n\n首先要了解一个关键概念：转场动画代理，它是一个实现了`UIViewControllerTransitioningDelegate`协议的对象。我们需要自己实现这个对象，它的作用是为UIKit提供以下几个对象中的一个或多个：\n\n1. Animator：\n\t\n\t它是实现了`UIViewControllerAnimatedTransitioning `协议的对象，用于控制动画的持续时间和动画展示逻辑，代理可以为present和dismiss过程分别提供Animator，也可以提供同一个Animator。\n\t\n2. 交互式Animator：和Animator类似，不过它是交互式的，后面会有详细介绍\n3. Presentation控制器：\n\n\t它可以对present过程更加彻底的自定义，比如修改被展示视图的大小，新增自定义视图等，后面会有详细介绍。\n\t\n![转场动画代理](http://images.bestswifter.com/CustomTransition/delegate.png)\n\t\n在这一小节中，我们首先介绍最简单的Animator。回顾一下转场动画必备的6个元素，它们被分为两组，彼此之间没有关联。Animator的作用等同于第二组的四个元素，也就是说对于同一个Animator，可以适用于A跳转B，也可以适用于A跳转C。它表示一种通用的页面跳转时的动画逻辑，不受限于具体的视图控制器。\n\n如果您读懂了这段话，整个自定义的转场动画逻辑就很清楚了，以视图控制器A跳转到B为例：\n\n1. 创建动画代理，在事情比较简单时，A自己就可以作为代理\n2. 设置B的transitioningDelegate为步骤1中创建的代理对象\n3. 调用`presentViewController:animated:completion:`并把参数animated设置为true\n4. 系统会找到代理中提供的Animator，由Animator负责动画逻辑\n\n用具体的例子解释就是：\n\n```swift\n// 这个类相当于A\nclass CrossDissolveFirstViewController: UIViewController, UIViewControllerTransitioningDelegate {\n\t// 这个对象相当于B\n\tcrossDissolveSecondViewController.transitioningDelegate = self  \n\t\n\t// 点击按钮触发的函数\n\tfunc animationButtonDidClicked() {\n        self.presentViewController(crossDissolveSecondViewController, \n        \t\t\t\t animated: true, completion: nil)\n    }\n    \n    // 下面这两个函数定义在UIViewControllerTransitioningDelegate协议中\n    // 用于为present和dismiss提供animator\n    func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n//        也可以使用CrossDissolveAnimator，动画效果各有不同\n//        return CrossDissolveAnimator()\n        return HalfWaySpringAnimator()\n    }\n    \n    func animationControllerForDismissedController(dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        return CrossDissolveAnimator()\n    }\n}\n```\n\n动画的关键在于animator如何实现，它实现了`UIViewControllerAnimatedTransitioning `协议，至少需要实现两个方法，我建议您仔细阅读`animateTransition`方法中的注释，它是整个动画逻辑的核心：\n\n```swift\nclass HalfWaySpringAnimator: NSObject, UIViewControllerAnimatedTransitioning {\n    /// 设置动画的持续时间\n    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -> NSTimeInterval {\n        return 2\n    }\n    \n    /// 设置动画的进行方式，附有详细注释，demo中其他地方的这个方法不再解释\n    func animateTransition(transitionContext: UIViewControllerContextTransitioning) {\n        let fromViewController = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)\n        let toViewController = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)\n        let containerView = transitionContext.containerView()\n        \n        // 需要关注一下from/to和presented/presenting的关系\n        // For a Presentation:\n        //      fromView = The presenting view.\n        //      toView   = The presented view.\n        // For a Dismissal:\n        //      fromView = The presented view.\n        //      toView   = The presenting view.\n        \n        var fromView = fromViewController?.view\n        var toView = toViewController?.view\n        \n        // iOS8引入了viewForKey方法，尽可能使用这个方法而不是直接访问controller的view属性\n        // 比如在form sheet样式中，我们为presentedViewController的view添加阴影或其他decoration，animator会对整个decoration view\n        // 添加动画效果，而此时presentedViewController的view只是decoration view的一个子视图\n        if transitionContext.respondsToSelector(Selector(\"viewForKey:\")) {\n            fromView = transitionContext.viewForKey(UITransitionContextFromViewKey)\n            toView = transitionContext.viewForKey(UITransitionContextToViewKey)\n        }\n        \n        // 我们让toview的origin.y在屏幕的一半处，这样它从屏幕的中间位置弹起而不是从屏幕底部弹起，弹起过程中逐渐变为不透明\n        toView?.frame = CGRectMake(fromView!.frame.origin.x, fromView!.frame.maxY / 2, fromView!.frame.width, fromView!.frame.height)\n        toView?.alpha = 0.0\n        \n        // 在present和，dismiss时，必须将toview添加到视图层次中\n        containerView?.addSubview(toView!)\n        \n        let transitionDuration = self.transitionDuration(transitionContext)\n        // 使用spring动画，有弹簧效果，动画结束后一定要调用completeTransition方法\n        UIView.animateWithDuration(transitionDuration, delay: 0, usingSpringWithDamping: 0.6, initialSpringVelocity: 0, options: .CurveLinear, animations: { () -> Void in\n            toView!.alpha = 1.0     // 逐渐变为不透明\n            toView?.frame = transitionContext.finalFrameForViewController(toViewController!)    // 移动到指定位置\n            }) { (finished: Bool) -> Void in\n                let wasCancelled = transitionContext.transitionWasCancelled()\n                transitionContext.completeTransition(!wasCancelled)\n        }\n    }\n}\n```\n\n`animateTransition`方法的核心则是从转场动画上下文获取必要的信息以完成动画。上下文是一个实现了`UIViewControllerContextTransitioning`的对象，它的作用在于为`animateTransition`方法提供必备的信息。您不应该缓存任何关于动画的信息，而是应该总是从转场动画上下文中获取(比如fromView和toView)，这样可以保证总是获取到最新的、正确的信息。\n\n![转场动画上下文](http://images.bestswifter.com/CustomTransition/context.png)\n\n获取到足够信息后，我们调用`UIView.animateWithDuration `方法把动画交给Core Animation处理。千万不要忘记在动画调用结束后，执行`completeTransition `方法。\n\n本节的知识在Demo的**Cross Dissolve**文件夹中有详细的代码。其中有两个animator文件，这说明我们可以为present和dismiss提供同一个animator，或者分别提供各自对应的animator。如果两者动画效果类似，您可以共用同一个animator，惟一的区别在于：\n\n1. present时，要把`toView`加入到container的视图层级。\n2. dismiss时，要把`fromView`从container的视图层级中移除。\n\n如果您被前面这一大段代码和知识弄晕了，或者暂时用不到这些具体的知识，您至少需要记住自定义动画的基本原理和流程：\n\n1. 设置将要跳转到的视图控制器(`presentedViewController`)的`transitioningDelegate`\n2. 充当代理的对象可以是源视图控制器(`presentingViewController`)，也可以是自己创建的对象，它需要为转场动画提供一个animator对象。\n3. animator对象的`animateTransition `是整个动画的核心逻辑。\n\n# 交互式(Interactive)转场动画\n\n刚刚我们说到，设置了`toViewController`的`transitioningDelegate`属性并且present时，UIKit会从代理处获取animator，其实这里还有一个细节：UIKit还会调用代理的`interactionControllerForPresentation: `方法来获取交互式控制器，如果得到了nil则执行非交互式动画，这就回到了上一节的内容。\n\n如果获取到了不是nil的对象，那么UIKit不会调用animator的`animateTransition `方法，而是调用交互式控制器(还记得前面介绍动画代理的示意图么，交互式动画控制器和animator是平级关系)的`startInteractiveTransition:`方法。\n\n所谓的交互式动画，通常是基于手势驱动，产生一个动画完成的百分比来控制动画效果(文章开头的gif中第二个动画效果)。整个动画不再是一次性、连贯的完成，而是在任何时候都可以改变百分比甚至取消。这需要一个实现了`UIPercentDrivenInteractiveTransition `协议的交互式动画控制器和animator协同工作。这看上去是一个非常复杂的任务，但UIKit已经封装了足够多细节，我们只需要在交互式动画控制器和中定义一个时间处理函数(比如处理滑动手势)，然后在接收到新的事件时，计算动画完成的百分比并且调用`updateInteractiveTransition`来更新动画进度即可。\n\n用下面这段代码简单表示一下整个流程(删除了部分细节和注释，请不要以此为正确参考)，完整的代码请参考demo中的**Interactivity**文件夹：\n\n```swift\n// 这个相当于fromViewController\nclass InteractivityFirstViewController: UIViewController {\n\t // 这个相当于toViewController\n    lazy var interactivitySecondViewController: InteractivitySecondViewController = InteractivitySecondViewController()\n    // 定义了一个InteractivityTransitionDelegate类作为代理\n    lazy var customTransitionDelegate: InteractivityTransitionDelegate = InteractivityTransitionDelegate()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupView() // 主要是一些UI控件的布局，可以无视其实现细节\n        \n        /// 设置动画代理，这个代理比较复杂，所以我们新建了一个代理对象而不是让self作为代理\n        interactivitySecondViewController.transitioningDelegate = customTransitionDelegate\n    }\n    \n    // 触发手势时，也会调用animationButtonDidClicked方法\n    func interactiveTransitionRecognizerAction(sender: UIScreenEdgePanGestureRecognizer) {\n        if sender.state == .Began {\n            self.animationButtonDidClicked(sender)\n        }\n    }\n   \n    func animationButtonDidClicked(sender: AnyObject) {\n        self.presentViewController(interactivitySecondViewController, animated: true, completion: nil)\n    }\n}\n```\n\n非交互式的动画代理只需要为present和dismiss提供animator即可，但是在交互式的动画代理中，还需要为present和dismiss提供交互式动画控制器：\n\n```swift\nclass InteractivityTransitionDelegate: NSObject, UIViewControllerTransitioningDelegate {\n    func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        return InteractivityTransitionAnimator(targetEdge: targetEdge)\n    }\n    \n    func animationControllerForDismissedController(dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        return InteractivityTransitionAnimator(targetEdge: targetEdge)\n    }\n    \n    /// 前两个函数和淡入淡出demo中的实现一致\n    /// 后两个函数用于实现交互式动画\n    \n    func interactionControllerForPresentation(animator: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {\n        return TransitionInteractionController(gestureRecognizer: gestureRecognizer, edgeForDragging: targetEdge)\n    }\n    \n    func interactionControllerForDismissal(animator: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {\n\t\treturn TransitionInteractionController(gestureRecognizer: gestureRecognizer, edgeForDragging: targetEdge)\n    }\n}\n```\n\nanimator中的代码略去，它和非交互式动画中的animator类似。因为交互式的动画只是一种锦上添花，它必须支持非交互式的动画，比如这个例子中，点击按钮依然出发的是非交互式的动画，只是手势滑动才会触发交互式动画。\n\n```swift\nclass TransitionInteractionController: UIPercentDrivenInteractiveTransition {\n\t/// 当手势有滑动时触发这个函数\n    func gestureRecognizeDidUpdate(gestureRecognizer: UIScreenEdgePanGestureRecognizer) {\n        switch gestureRecognizer.state {\n        case .Began: break\n        case .Changed: self.updateInteractiveTransition(self.percentForGesture(gestureRecognizer))  //手势滑动，更新百分比\n        case .Ended:    // 滑动结束，判断是否超过一半，如果是则完成剩下的动画，否则取消动画\n            if self.percentForGesture(gestureRecognizer) >= 0.5 {\n                self.finishInteractiveTransition()\n            }\n            else {\n                self.cancelInteractiveTransition()\n            }\n        default: self.cancelInteractiveTransition()\n        }\n    }\n    private func percentForGesture(gesture: UIScreenEdgePanGestureRecognizer) -> CGFloat {\n    \tlet percent = 根据gesture计算得出\n\t\treturn percent\n    }\n}\n```\n\n交互式动画是在非交互式动画的基础上实现的，我们需要创建一个继承自`UIPercentDrivenInteractiveTransition `类型的子类，并且在动画代理中返回这个类型的实例对象。\n\n在这个类型中，监听手势(或者下载进度等等)的时间变化，然后调用`percentForGesture`方法更新动画进度即可。\n\n# 转场协调器与UIModalPresentationCustom\n\n在进行转场动画的同时，您还可以进行一些同步的，额外的动画，比如文章开头gif中的第三个例子。`presentedView`和`presentingView`可以更改自身的视图层级，添加额外的效果(阴影，圆角)。UIKit使用转成协调器来管理这些额外的动画。您可以通过需要产生动画效果的视图控制器的`transitionCoordinator`属性来获取转场协调器，转场协调器只在转场动画的执行过程中存在。\n\n![转场动画协调器](http://images.bestswifter.com/CustomTransition/coordinator.png)\n\n想要完成gif中第三个例子的效果，我们还需要使用`UIModalPresentationStyle.Custom`来代替`.FullScreen`。因为后者会移除`fromViewController`，这显然不符合需求。\n\n当present的方式为`.Custom`时，我们还可以使用`UIPresentationController`更加彻底的控制转场动画的效果。一个 presentation controller具备以下几个功能：\n\n1. 设置`presentedViewController`的视图大小\n2. 添加自定义视图来改变`presentedView`的外观\n3. 为任何自定义的视图提供转场动画效果\n4. 根据size class进行响应式布局\n\n您可以认为，`. FullScreen `以及其他present风格都是swift为我们实现提供好的，它们是`.Custom`的特例。而`.Custom`允许我们更加自由的定义转场动画效果。\n\n`UIPresentationController`提供了四个函数来定义present和dismiss动画开始前后的操作：\n\n1. `presentationTransitionWillBegin`: present将要执行时\n2. `presentationTransitionDidEnd`：present执行结束后\n3. `dismissalTransitionWillBegin`：dismiss将要执行时\n4. `dismissalTransitionDidEnd`：dismiss执行结束后\n\n下面的代码简要描述了gif中第三个动画效果的实现原理，您可以在demo的**Custom Presentation**文件夹下查看完成代码：\n\n```swift\n// 这个相当于fromViewController\nclass CustomPresentationFirstViewController: UIViewController {\n\t// 这个相当于toViewController\n    lazy var customPresentationSecondViewController: CustomPresentationSecondViewController = CustomPresentationSecondViewController()\n    // 创建PresentationController\n    lazy var customPresentationController: CustomPresentationController = CustomPresentationController(presentedViewController: self.customPresentationSecondViewController, presentingViewController: self)\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupView() // 主要是一些UI控件的布局，可以无视其实现细节\n        \n        // 设置转场动画代理\n        customPresentationSecondViewController.transitioningDelegate = customPresentationController\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n    \n    func animationButtonDidClicked() {\n        self.presentViewController(customPresentationSecondViewController, animated: true, completion: nil)\n    }\n}\n```\n\n重点在于如何实现`CustomPresentationController `这个类：\n\n```swift\nclass CustomPresentationController: UIPresentationController, UIViewControllerTransitioningDelegate {\n\tvar presentationWrappingView: UIView?  // 这个视图封装了原视图，添加了阴影和圆角效果\n\tvar dimmingView: UIView? = nil  // alpha为0.5的黑色蒙版\n\t\n\t// 告诉UIKit为哪个视图添加动画效果\n\toverride func presentedView() -> UIView? {\n        return self.presentationWrappingView\n    }\n}\n\n// 四个方法自定义转场动画发生前后的操作\nextension CustomPresentationController {\n\toverride func presentationTransitionWillBegin() {\n\t\t// 设置presentationWrappingView和dimmingView的UI效果\n\t\tlet transitionCoordinator = self.presentingViewController.transitionCoordinator()\n        self.dimmingView?.alpha = 0\n\t\t// 通过转场协调器执行同步的动画效果\n        transitionCoordinator?.animateAlongsideTransition({ (context: UIViewControllerTransitionCoordinatorContext) -> Void in\n            self.dimmingView?.alpha = 0.5\n            }, completion: nil)\n\t}\n\t\n\t/// present结束时，把dimmingView和wrappingView都清空，这些临时视图用不到了\n    override func presentationTransitionDidEnd(completed: Bool) {\n        if !completed {\n            self.presentationWrappingView = nil\n            self.dimmingView = nil\n        }\n    }\n    \n    /// dismiss开始时，让dimmingView完全透明，这个动画和animator中的动画同时发生\n    override func dismissalTransitionWillBegin() {\n        let transitionCoordinator = self.presentingViewController.transitionCoordinator()\n        transitionCoordinator?.animateAlongsideTransition({ (context: UIViewControllerTransitionCoordinatorContext) -> Void in\n            self.dimmingView?.alpha = 0\n            }, completion: nil)\n    }\n    \n    /// dismiss结束时，把dimmingView和wrappingView都清空，这些临时视图用不到了\n    override func dismissalTransitionDidEnd(completed: Bool) {\n        if completed {\n            self.presentationWrappingView = nil\n            self.dimmingView = nil\n        }\n    }\n}\n\nextension CustomPresentationController {\n}\n```\n\n除此以外，这个类还要处理子视图布局相关的逻辑。它作为动画代理，还需要为动画提供animator对象，详细代码请在demo的**Custom Presentation**文件夹下阅读。\n\n# UINavigationController转场动画\n\n到目前为止，所有转场动画都是适用于present和dismiss的，其实`UINavigationController `也可以自定义转场动画。两者是平行关系，很多都可以类比过来：\n\n```swift\nclass FromViewController: UIViewController, UINavigationControllerDelegate {\n   let toViewController: ToViewController = ToViewController()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupView() // 主要是一些UI控件的布局，可以无视其实现细节\n        \n        self.navigationController.delegate = self\n    }\n}    \n```\n\n与present/dismiss不同的时，现在视图控制器实现的是`UINavigationControllerDelegate `协议，让自己成为`navigationController`的代理。这个协议类似于此前的`UIViewControllerTransitioningDelegate `协议。\n\n`FromViewController `实现`UINavigationControllerDelegate `协议的具体操作如下：\n\n```swift\nfunc navigationController(navigationController: UINavigationController, \n\t animationControllerForOperation operation: UINavigationControllerOperation, \n\t\t\t\t\t fromViewController fromVC: UIViewController, \n\t\t\t\t\t\t toViewController toVC: UIViewController) \n\t\t\t\t\t\t-> UIViewControllerAnimatedTransitioning? {\n        if operation == .Push {\n            return PushAnimator()\n        }\n        if operation == .Pop {\n            return PopAnimator()\n        }\n        return nil;\n    }\n```\n\n至于animator，就和此前没有任何区别了。可见，一个封装得很好的animator，不仅能在present/dismiss时使用，甚至还可以在push/pop时使用。\n\nUINavigationController也可以添加交互式转场动画，原理也和此前类似。\n\n# 总结\n\n对于非交互式动画，需要设置`presentedViewController`的`transitioningDelegate`属性，这个代理需要为present和dismiss提供animator。在animator中规定了动画的持续时间和表现逻辑。\n\n对于交互式动画，需要在此前的基础上，由`transitioningDelegate`属性提供交互式动画控制器。在控制器中进行事件处理，然后更新动画完成进度。\n\n对于自定义动画，可以通过`UIPresentationController `中的四个函数自定义动画执行前后的效果，可以修改`presentedViewController `的大小、外观并同步执行其他的动画。\n\n自定义动画的水还是比较深，本文仅适合做入门学习用，欢迎互相交流。这里是本文所参考的资料和其他优秀的中文教程：\n\n1. [WWDC 2013 Session 218](https://developer.apple.com/videos/play/wwdc2013-218/)\n2. [Customizing the Transition Animations](https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/CustomizingtheTransitionAnimations.html)\n3. [Creating Custom Presentations](https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/DefiningCustomPresentations.html#//apple_ref/doc/uid/TP40007457-CH25-SW1)\n4. [Navigation controller custom transition animation](http://stackoverflow.com/questions/26569488/navigation-controller-custom-transition-animation)\n5. [WWDC 2013 Session笔记 - iOS7中的ViewController切换](http://onevcat.com/2013/10/vc-transition-in-ios7/)\n6. [自定义 ViewController 容器转场](http://objccn.io/issue-12-3/)","html":"<p>转场动画这事，说简单也简单，可以通过<code>presentViewController:animated:completion:</code>和<code>dismissViewControllerAnimated:completion:</code>这一组函数以模态视图的方式展现、隐藏视图。如果用到了<code>navigationController</code>，还可以调用<code>pushViewController:animated:</code>和<code>popViewController</code>这一组函数将新的视图控制器压栈、弹栈。</p>\n\n<p>下图中所有转场动画都是自定义的动画，这些效果如果不用自定义动画则很难甚至无法实现：</p>\n\n<p><img src=\"http://images.bestswifter.com/CustomTransition/demo.gif\" alt=\"demo演示\" /></p>\n\n<p>由于录屏的原因，有些效果无法完全展现，比如它其实还支持横屏。</p>\n\n<p>自定义转场动画的效果实现起来比较复杂，如果仅仅是拷贝一份能够运行的代码却不懂其中原理，就有可能带来各种隐藏的bug。本文由浅入深介绍下面几个知识：</p>\n\n<ol>\n<li>传统的基于闭包的实现方式及其缺点  </li>\n<li>自定义present转场动画  </li>\n<li>交互式(Interactive)转场动画  </li>\n<li>转场协调器与UIModalPresentationCustom  </li>\n<li>UINavigationController转场动画</li>\n</ol>\n\n<p>我为这篇教程制作了一个demo，您可以去在我的github上clone下来：<a href=\"https://github.com/bestswifter/MySampleCode/tree/master/CustomTransition\">CustomTransition</a>，如果觉得有帮助还望给个star以示支持。本文以Swift+纯代码实现，对应的OC+Storyboard版本在demo中也可以找到，那是苹果的官方示范代码，正确性更有保证。demo中用到了CocoaPods，您也许需要执行<code>pod install</code>命令并打开<code>.xcworkspace</code>文件。</p>\n\n<p>在开始正式的教程前，您首先需要下载demo，在代码面前文字是苍白的，demo中包含的注释足以解释本文所有的知识点。其次，您还得了解这几个背景知识。</p>\n\n<h3 id=\"fromto\">From和To</h3>\n\n<p>在代码和文字中，经常会出现<code>fromView</code>和<code>toView</code>。如果错误的理解它们的含义会导致动画逻辑完全错误。<code>fromView</code>表示当前视图，<code>toView</code>表示要跳转到的视图。如果是从A视图控制器present到B，则A是from，B是to。从B视图控制器dismiss到A时，B变成了from，A是to。用一张图表示：</p>\n\n<p><img src=\"http://images.bestswifter.com/CustomTransition/fromto.png\" alt=\"from和to\" /></p>\n\n<h3 id=\"presentedpresenting\">Presented和Presenting</h3>\n\n<p>这也是一组相对的概念，它容易与<code>fromView</code>和<code>toView</code>混淆。简单来说，它不受present或dismiss的影响，如果是从A视图控制器present到B，那么A总是B的<code>presentingViewController</code>,B总是A的<code>presentedViewController</code>。</p>\n\n<h3 id=\"modalpresentationstyle\">modalPresentationStyle</h3>\n\n<p>这是一个枚举类型，表示present时动画的类型。其中可以自定义动画效果的只有两种：<code>FullScreen</code>和<code>Custom</code>，两者的区别在于<code>FullScreen</code>会移除<code>fromView</code>，而<code>Custom</code>不会。比如文章开头的gif中，第三个动画效果就是<code>Custom</code>。</p>\n\n<h1 id=\"block\">基于block的动画</h1>\n\n<p>最简单的转场动画是使用<code>transitionFromViewController</code>方法：</p>\n\n<p><img src=\"http://images.bestswifter.com/CustomTransition/blockbased_animation.png\" alt=\"传统的转场动画实现\" /></p>\n\n<p>这个方法虽然已经过时，但是对它的分析有助于后面知识的理解。它一共有6个参数，前两个表示从哪个VC开始，跳转到哪个VC，中间两个参数表示动画的时间和选项。最后两个参数表示动画的具体实现细节和回调闭包。</p>\n\n<p>这六个参数其实就是一次转场动画所必备的六个元素。它们可以分为两组，前两个参数为一组，表示页面的跳转关系，后面四个为一组，表示动画的执行逻辑。</p>\n\n<p>这个方法的缺点之一是可自定义程度不高(在后面您会发现能自定义的不仅仅是动画方式)，另一个缺点则是重用性不好，也可以说是耦合度比较大。</p>\n\n<p>在最后两个闭包参数中，可以预见的是<code>fromViewController</code>和<code>toViewController</code>参数都会被用到，而且他们是动画的关键。假设视图控制器A可以跳转到B、C、D、E、F，而且跳转动画基本相似，您会发现<code>transitionFromViewController</code>方法要被复制多次，每次只会修改少量内容。</p>\n\n<h1 id=\"present\">自定义present转场动画</h1>\n\n<p>出于解耦和提高可自定义程度的考虑，我们来学习转场动画的正确使用姿势。</p>\n\n<p>首先要了解一个关键概念：转场动画代理，它是一个实现了<code>UIViewControllerTransitioningDelegate</code>协议的对象。我们需要自己实现这个对象，它的作用是为UIKit提供以下几个对象中的一个或多个：</p>\n\n<ol>\n<li><p>Animator：</p>\n\n<p>它是实现了<code>UIViewControllerAnimatedTransitioning</code>协议的对象，用于控制动画的持续时间和动画展示逻辑，代理可以为present和dismiss过程分别提供Animator，也可以提供同一个Animator。</p></li>\n<li><p>交互式Animator：和Animator类似，不过它是交互式的，后面会有详细介绍  </p></li>\n<li><p>Presentation控制器：</p>\n\n<p>它可以对present过程更加彻底的自定义，比如修改被展示视图的大小，新增自定义视图等，后面会有详细介绍。</p></li>\n</ol>\n\n<p><img src=\"http://images.bestswifter.com/CustomTransition/delegate.png\" alt=\"转场动画代理\" /></p>\n\n<p>在这一小节中，我们首先介绍最简单的Animator。回顾一下转场动画必备的6个元素，它们被分为两组，彼此之间没有关联。Animator的作用等同于第二组的四个元素，也就是说对于同一个Animator，可以适用于A跳转B，也可以适用于A跳转C。它表示一种通用的页面跳转时的动画逻辑，不受限于具体的视图控制器。</p>\n\n<p>如果您读懂了这段话，整个自定义的转场动画逻辑就很清楚了，以视图控制器A跳转到B为例：</p>\n\n<ol>\n<li>创建动画代理，在事情比较简单时，A自己就可以作为代理  </li>\n<li>设置B的transitioningDelegate为步骤1中创建的代理对象  </li>\n<li>调用<code>presentViewController:animated:completion:</code>并把参数animated设置为true  </li>\n<li>系统会找到代理中提供的Animator，由Animator负责动画逻辑</li>\n</ol>\n\n<p>用具体的例子解释就是：</p>\n\n<pre><code class=\"language-swift\">// 这个类相当于A\nclass CrossDissolveFirstViewController: UIViewController, UIViewControllerTransitioningDelegate {  \n    // 这个对象相当于B\n    crossDissolveSecondViewController.transitioningDelegate = self  \n\n    // 点击按钮触发的函数\n    func animationButtonDidClicked() {\n        self.presentViewController(crossDissolveSecondViewController, \n                         animated: true, completion: nil)\n    }\n\n    // 下面这两个函数定义在UIViewControllerTransitioningDelegate协议中\n    // 用于为present和dismiss提供animator\n    func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {\n//        也可以使用CrossDissolveAnimator，动画效果各有不同\n//        return CrossDissolveAnimator()\n        return HalfWaySpringAnimator()\n    }\n\n    func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {\n        return CrossDissolveAnimator()\n    }\n}\n</code></pre>\n\n<p>动画的关键在于animator如何实现，它实现了<code>UIViewControllerAnimatedTransitioning</code>协议，至少需要实现两个方法，我建议您仔细阅读<code>animateTransition</code>方法中的注释，它是整个动画逻辑的核心：</p>\n\n<pre><code class=\"language-swift\">class HalfWaySpringAnimator: NSObject, UIViewControllerAnimatedTransitioning {  \n    /// 设置动画的持续时间\n    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval {\n        return 2\n    }\n\n    /// 设置动画的进行方式，附有详细注释，demo中其他地方的这个方法不再解释\n    func animateTransition(transitionContext: UIViewControllerContextTransitioning) {\n        let fromViewController = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)\n        let toViewController = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)\n        let containerView = transitionContext.containerView()\n\n        // 需要关注一下from/to和presented/presenting的关系\n        // For a Presentation:\n        //      fromView = The presenting view.\n        //      toView   = The presented view.\n        // For a Dismissal:\n        //      fromView = The presented view.\n        //      toView   = The presenting view.\n\n        var fromView = fromViewController?.view\n        var toView = toViewController?.view\n\n        // iOS8引入了viewForKey方法，尽可能使用这个方法而不是直接访问controller的view属性\n        // 比如在form sheet样式中，我们为presentedViewController的view添加阴影或其他decoration，animator会对整个decoration view\n        // 添加动画效果，而此时presentedViewController的view只是decoration view的一个子视图\n        if transitionContext.respondsToSelector(Selector(\"viewForKey:\")) {\n            fromView = transitionContext.viewForKey(UITransitionContextFromViewKey)\n            toView = transitionContext.viewForKey(UITransitionContextToViewKey)\n        }\n\n        // 我们让toview的origin.y在屏幕的一半处，这样它从屏幕的中间位置弹起而不是从屏幕底部弹起，弹起过程中逐渐变为不透明\n        toView?.frame = CGRectMake(fromView!.frame.origin.x, fromView!.frame.maxY / 2, fromView!.frame.width, fromView!.frame.height)\n        toView?.alpha = 0.0\n\n        // 在present和，dismiss时，必须将toview添加到视图层次中\n        containerView?.addSubview(toView!)\n\n        let transitionDuration = self.transitionDuration(transitionContext)\n        // 使用spring动画，有弹簧效果，动画结束后一定要调用completeTransition方法\n        UIView.animateWithDuration(transitionDuration, delay: 0, usingSpringWithDamping: 0.6, initialSpringVelocity: 0, options: .CurveLinear, animations: { () -&gt; Void in\n            toView!.alpha = 1.0     // 逐渐变为不透明\n            toView?.frame = transitionContext.finalFrameForViewController(toViewController!)    // 移动到指定位置\n            }) { (finished: Bool) -&gt; Void in\n                let wasCancelled = transitionContext.transitionWasCancelled()\n                transitionContext.completeTransition(!wasCancelled)\n        }\n    }\n}\n</code></pre>\n\n<p><code>animateTransition</code>方法的核心则是从转场动画上下文获取必要的信息以完成动画。上下文是一个实现了<code>UIViewControllerContextTransitioning</code>的对象，它的作用在于为<code>animateTransition</code>方法提供必备的信息。您不应该缓存任何关于动画的信息，而是应该总是从转场动画上下文中获取(比如fromView和toView)，这样可以保证总是获取到最新的、正确的信息。</p>\n\n<p><img src=\"http://images.bestswifter.com/CustomTransition/context.png\" alt=\"转场动画上下文\" /></p>\n\n<p>获取到足够信息后，我们调用<code>UIView.animateWithDuration</code>方法把动画交给Core Animation处理。千万不要忘记在动画调用结束后，执行<code>completeTransition</code>方法。</p>\n\n<p>本节的知识在Demo的<strong>Cross Dissolve</strong>文件夹中有详细的代码。其中有两个animator文件，这说明我们可以为present和dismiss提供同一个animator，或者分别提供各自对应的animator。如果两者动画效果类似，您可以共用同一个animator，惟一的区别在于：</p>\n\n<ol>\n<li>present时，要把<code>toView</code>加入到container的视图层级。  </li>\n<li>dismiss时，要把<code>fromView</code>从container的视图层级中移除。</li>\n</ol>\n\n<p>如果您被前面这一大段代码和知识弄晕了，或者暂时用不到这些具体的知识，您至少需要记住自定义动画的基本原理和流程：</p>\n\n<ol>\n<li>设置将要跳转到的视图控制器(<code>presentedViewController</code>)的<code>transitioningDelegate</code>  </li>\n<li>充当代理的对象可以是源视图控制器(<code>presentingViewController</code>)，也可以是自己创建的对象，它需要为转场动画提供一个animator对象。  </li>\n<li>animator对象的<code>animateTransition</code>是整个动画的核心逻辑。</li>\n</ol>\n\n<h1 id=\"interactive\">交互式(Interactive)转场动画</h1>\n\n<p>刚刚我们说到，设置了<code>toViewController</code>的<code>transitioningDelegate</code>属性并且present时，UIKit会从代理处获取animator，其实这里还有一个细节：UIKit还会调用代理的<code>interactionControllerForPresentation:</code>方法来获取交互式控制器，如果得到了nil则执行非交互式动画，这就回到了上一节的内容。</p>\n\n<p>如果获取到了不是nil的对象，那么UIKit不会调用animator的<code>animateTransition</code>方法，而是调用交互式控制器(还记得前面介绍动画代理的示意图么，交互式动画控制器和animator是平级关系)的<code>startInteractiveTransition:</code>方法。</p>\n\n<p>所谓的交互式动画，通常是基于手势驱动，产生一个动画完成的百分比来控制动画效果(文章开头的gif中第二个动画效果)。整个动画不再是一次性、连贯的完成，而是在任何时候都可以改变百分比甚至取消。这需要一个实现了<code>UIPercentDrivenInteractiveTransition</code>协议的交互式动画控制器和animator协同工作。这看上去是一个非常复杂的任务，但UIKit已经封装了足够多细节，我们只需要在交互式动画控制器和中定义一个时间处理函数(比如处理滑动手势)，然后在接收到新的事件时，计算动画完成的百分比并且调用<code>updateInteractiveTransition</code>来更新动画进度即可。</p>\n\n<p>用下面这段代码简单表示一下整个流程(删除了部分细节和注释，请不要以此为正确参考)，完整的代码请参考demo中的<strong>Interactivity</strong>文件夹：</p>\n\n<pre><code class=\"language-swift\">// 这个相当于fromViewController\nclass InteractivityFirstViewController: UIViewController {  \n     // 这个相当于toViewController\n    lazy var interactivitySecondViewController: InteractivitySecondViewController = InteractivitySecondViewController()\n    // 定义了一个InteractivityTransitionDelegate类作为代理\n    lazy var customTransitionDelegate: InteractivityTransitionDelegate = InteractivityTransitionDelegate()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupView() // 主要是一些UI控件的布局，可以无视其实现细节\n\n        /// 设置动画代理，这个代理比较复杂，所以我们新建了一个代理对象而不是让self作为代理\n        interactivitySecondViewController.transitioningDelegate = customTransitionDelegate\n    }\n\n    // 触发手势时，也会调用animationButtonDidClicked方法\n    func interactiveTransitionRecognizerAction(sender: UIScreenEdgePanGestureRecognizer) {\n        if sender.state == .Began {\n            self.animationButtonDidClicked(sender)\n        }\n    }\n\n    func animationButtonDidClicked(sender: AnyObject) {\n        self.presentViewController(interactivitySecondViewController, animated: true, completion: nil)\n    }\n}\n</code></pre>\n\n<p>非交互式的动画代理只需要为present和dismiss提供animator即可，但是在交互式的动画代理中，还需要为present和dismiss提供交互式动画控制器：</p>\n\n<pre><code class=\"language-swift\">class InteractivityTransitionDelegate: NSObject, UIViewControllerTransitioningDelegate {  \n    func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {\n        return InteractivityTransitionAnimator(targetEdge: targetEdge)\n    }\n\n    func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {\n        return InteractivityTransitionAnimator(targetEdge: targetEdge)\n    }\n\n    /// 前两个函数和淡入淡出demo中的实现一致\n    /// 后两个函数用于实现交互式动画\n\n    func interactionControllerForPresentation(animator: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? {\n        return TransitionInteractionController(gestureRecognizer: gestureRecognizer, edgeForDragging: targetEdge)\n    }\n\n    func interactionControllerForDismissal(animator: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? {\n        return TransitionInteractionController(gestureRecognizer: gestureRecognizer, edgeForDragging: targetEdge)\n    }\n}\n</code></pre>\n\n<p>animator中的代码略去，它和非交互式动画中的animator类似。因为交互式的动画只是一种锦上添花，它必须支持非交互式的动画，比如这个例子中，点击按钮依然出发的是非交互式的动画，只是手势滑动才会触发交互式动画。</p>\n\n<pre><code class=\"language-swift\">class TransitionInteractionController: UIPercentDrivenInteractiveTransition {  \n    /// 当手势有滑动时触发这个函数\n    func gestureRecognizeDidUpdate(gestureRecognizer: UIScreenEdgePanGestureRecognizer) {\n        switch gestureRecognizer.state {\n        case .Began: break\n        case .Changed: self.updateInteractiveTransition(self.percentForGesture(gestureRecognizer))  //手势滑动，更新百分比\n        case .Ended:    // 滑动结束，判断是否超过一半，如果是则完成剩下的动画，否则取消动画\n            if self.percentForGesture(gestureRecognizer) &gt;= 0.5 {\n                self.finishInteractiveTransition()\n            }\n            else {\n                self.cancelInteractiveTransition()\n            }\n        default: self.cancelInteractiveTransition()\n        }\n    }\n    private func percentForGesture(gesture: UIScreenEdgePanGestureRecognizer) -&gt; CGFloat {\n        let percent = 根据gesture计算得出\n        return percent\n    }\n}\n</code></pre>\n\n<p>交互式动画是在非交互式动画的基础上实现的，我们需要创建一个继承自<code>UIPercentDrivenInteractiveTransition</code>类型的子类，并且在动画代理中返回这个类型的实例对象。</p>\n\n<p>在这个类型中，监听手势(或者下载进度等等)的时间变化，然后调用<code>percentForGesture</code>方法更新动画进度即可。</p>\n\n<h1 id=\"uimodalpresentationcustom\">转场协调器与UIModalPresentationCustom</h1>\n\n<p>在进行转场动画的同时，您还可以进行一些同步的，额外的动画，比如文章开头gif中的第三个例子。<code>presentedView</code>和<code>presentingView</code>可以更改自身的视图层级，添加额外的效果(阴影，圆角)。UIKit使用转成协调器来管理这些额外的动画。您可以通过需要产生动画效果的视图控制器的<code>transitionCoordinator</code>属性来获取转场协调器，转场协调器只在转场动画的执行过程中存在。</p>\n\n<p><img src=\"http://images.bestswifter.com/CustomTransition/coordinator.png\" alt=\"转场动画协调器\" /></p>\n\n<p>想要完成gif中第三个例子的效果，我们还需要使用<code>UIModalPresentationStyle.Custom</code>来代替<code>.FullScreen</code>。因为后者会移除<code>fromViewController</code>，这显然不符合需求。</p>\n\n<p>当present的方式为<code>.Custom</code>时，我们还可以使用<code>UIPresentationController</code>更加彻底的控制转场动画的效果。一个 presentation controller具备以下几个功能：</p>\n\n<ol>\n<li>设置<code>presentedViewController</code>的视图大小  </li>\n<li>添加自定义视图来改变<code>presentedView</code>的外观  </li>\n<li>为任何自定义的视图提供转场动画效果  </li>\n<li>根据size class进行响应式布局</li>\n</ol>\n\n<p>您可以认为，<code>. FullScreen</code>以及其他present风格都是swift为我们实现提供好的，它们是<code>.Custom</code>的特例。而<code>.Custom</code>允许我们更加自由的定义转场动画效果。</p>\n\n<p><code>UIPresentationController</code>提供了四个函数来定义present和dismiss动画开始前后的操作：</p>\n\n<ol>\n<li><code>presentationTransitionWillBegin</code>: present将要执行时  </li>\n<li><code>presentationTransitionDidEnd</code>：present执行结束后  </li>\n<li><code>dismissalTransitionWillBegin</code>：dismiss将要执行时  </li>\n<li><code>dismissalTransitionDidEnd</code>：dismiss执行结束后</li>\n</ol>\n\n<p>下面的代码简要描述了gif中第三个动画效果的实现原理，您可以在demo的<strong>Custom Presentation</strong>文件夹下查看完成代码：</p>\n\n<pre><code class=\"language-swift\">// 这个相当于fromViewController\nclass CustomPresentationFirstViewController: UIViewController {  \n    // 这个相当于toViewController\n    lazy var customPresentationSecondViewController: CustomPresentationSecondViewController = CustomPresentationSecondViewController()\n    // 创建PresentationController\n    lazy var customPresentationController: CustomPresentationController = CustomPresentationController(presentedViewController: self.customPresentationSecondViewController, presentingViewController: self)\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupView() // 主要是一些UI控件的布局，可以无视其实现细节\n\n        // 设置转场动画代理\n        customPresentationSecondViewController.transitioningDelegate = customPresentationController\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n\n    func animationButtonDidClicked() {\n        self.presentViewController(customPresentationSecondViewController, animated: true, completion: nil)\n    }\n}\n</code></pre>\n\n<p>重点在于如何实现<code>CustomPresentationController</code>这个类：</p>\n\n<pre><code class=\"language-swift\">class CustomPresentationController: UIPresentationController, UIViewControllerTransitioningDelegate {  \n    var presentationWrappingView: UIView?  // 这个视图封装了原视图，添加了阴影和圆角效果\n    var dimmingView: UIView? = nil  // alpha为0.5的黑色蒙版\n\n    // 告诉UIKit为哪个视图添加动画效果\n    override func presentedView() -&gt; UIView? {\n        return self.presentationWrappingView\n    }\n}\n\n// 四个方法自定义转场动画发生前后的操作\nextension CustomPresentationController {  \n    override func presentationTransitionWillBegin() {\n        // 设置presentationWrappingView和dimmingView的UI效果\n        let transitionCoordinator = self.presentingViewController.transitionCoordinator()\n        self.dimmingView?.alpha = 0\n        // 通过转场协调器执行同步的动画效果\n        transitionCoordinator?.animateAlongsideTransition({ (context: UIViewControllerTransitionCoordinatorContext) -&gt; Void in\n            self.dimmingView?.alpha = 0.5\n            }, completion: nil)\n    }\n\n    /// present结束时，把dimmingView和wrappingView都清空，这些临时视图用不到了\n    override func presentationTransitionDidEnd(completed: Bool) {\n        if !completed {\n            self.presentationWrappingView = nil\n            self.dimmingView = nil\n        }\n    }\n\n    /// dismiss开始时，让dimmingView完全透明，这个动画和animator中的动画同时发生\n    override func dismissalTransitionWillBegin() {\n        let transitionCoordinator = self.presentingViewController.transitionCoordinator()\n        transitionCoordinator?.animateAlongsideTransition({ (context: UIViewControllerTransitionCoordinatorContext) -&gt; Void in\n            self.dimmingView?.alpha = 0\n            }, completion: nil)\n    }\n\n    /// dismiss结束时，把dimmingView和wrappingView都清空，这些临时视图用不到了\n    override func dismissalTransitionDidEnd(completed: Bool) {\n        if completed {\n            self.presentationWrappingView = nil\n            self.dimmingView = nil\n        }\n    }\n}\n\nextension CustomPresentationController {  \n}\n</code></pre>\n\n<p>除此以外，这个类还要处理子视图布局相关的逻辑。它作为动画代理，还需要为动画提供animator对象，详细代码请在demo的<strong>Custom Presentation</strong>文件夹下阅读。</p>\n\n<h1 id=\"uinavigationcontroller\">UINavigationController转场动画</h1>\n\n<p>到目前为止，所有转场动画都是适用于present和dismiss的，其实<code>UINavigationController</code>也可以自定义转场动画。两者是平行关系，很多都可以类比过来：</p>\n\n<pre><code class=\"language-swift\">class FromViewController: UIViewController, UINavigationControllerDelegate {  \n   let toViewController: ToViewController = ToViewController()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupView() // 主要是一些UI控件的布局，可以无视其实现细节\n\n        self.navigationController.delegate = self\n    }\n}    \n</code></pre>\n\n<p>与present/dismiss不同的时，现在视图控制器实现的是<code>UINavigationControllerDelegate</code>协议，让自己成为<code>navigationController</code>的代理。这个协议类似于此前的<code>UIViewControllerTransitioningDelegate</code>协议。</p>\n\n<p><code>FromViewController</code>实现<code>UINavigationControllerDelegate</code>协议的具体操作如下：</p>\n\n<pre><code class=\"language-swift\">func navigationController(navigationController: UINavigationController,  \n     animationControllerForOperation operation: UINavigationControllerOperation, \n                     fromViewController fromVC: UIViewController, \n                         toViewController toVC: UIViewController) \n                        -&gt; UIViewControllerAnimatedTransitioning? {\n        if operation == .Push {\n            return PushAnimator()\n        }\n        if operation == .Pop {\n            return PopAnimator()\n        }\n        return nil;\n    }\n</code></pre>\n\n<p>至于animator，就和此前没有任何区别了。可见，一个封装得很好的animator，不仅能在present/dismiss时使用，甚至还可以在push/pop时使用。</p>\n\n<p>UINavigationController也可以添加交互式转场动画，原理也和此前类似。</p>\n\n<h1 id=\"\">总结</h1>\n\n<p>对于非交互式动画，需要设置<code>presentedViewController</code>的<code>transitioningDelegate</code>属性，这个代理需要为present和dismiss提供animator。在animator中规定了动画的持续时间和表现逻辑。</p>\n\n<p>对于交互式动画，需要在此前的基础上，由<code>transitioningDelegate</code>属性提供交互式动画控制器。在控制器中进行事件处理，然后更新动画完成进度。</p>\n\n<p>对于自定义动画，可以通过<code>UIPresentationController</code>中的四个函数自定义动画执行前后的效果，可以修改<code>presentedViewController</code>的大小、外观并同步执行其他的动画。</p>\n\n<p>自定义动画的水还是比较深，本文仅适合做入门学习用，欢迎互相交流。这里是本文所参考的资料和其他优秀的中文教程：</p>\n\n<ol>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2013-218/\">WWDC 2013 Session 218</a>  </li>\n<li><a href=\"https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/CustomizingtheTransitionAnimations.html\">Customizing the Transition Animations</a>  </li>\n<li><a href=\"https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/DefiningCustomPresentations.html#//apple_ref/doc/uid/TP40007457-CH25-SW1\">Creating Custom Presentations</a>  </li>\n<li><a href=\"http://stackoverflow.com/questions/26569488/navigation-controller-custom-transition-animation\">Navigation controller custom transition animation</a>  </li>\n<li><a href=\"http://onevcat.com/2013/10/vc-transition-in-ios7/\">WWDC 2013 Session笔记 - iOS7中的ViewController切换</a>  </li>\n<li><a href=\"http://objccn.io/issue-12-3/\">自定义 ViewController 容器转场</a></li>\n</ol>","image":null,"featured":1,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-02-11T06:02:47.000Z","created_by":1,"updated_at":"2016-02-14T07:09:42.000Z","updated_by":1,"published_at":"2016-02-11T06:03:29.000Z","published_by":1},{"id":21,"uuid":"f0d1c2ea-ab26-4d38-9082-d1ecfa864561","title":"当UIColor遇上Swift","slug":"uicolorliteral","markdown":"我为这篇文章制作了demo，已经上传到我的GitHub：[KTColor](https://github.com/bestswifter/MySampleCode/tree/master/KtColor)，如果觉得有帮助还望给个star以示支持。\n\n`UIColor` 提供了几个默认的颜色，要想创建除此以外的颜色，一般是通过RGB和alpha值创建(十六进制的颜色其实也是被转换成RGB)。在 Objective-C 中，这可以通过自定义宏来完成，在 Swift 中，我们可以利用 Swift 的一些语法特性来简化创建 `UIColor` 对象的过程。我想，最理想的解决方案应该是这样：\n\n```swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n   \n    self.view.backgroundColor = \"224, 222, 255\"\n}\n```\n\n# 变通方案\n\n然而很不幸的是，在目前的 Swift 版本(2.1)中，这种写法暂时无法实现。据我所知，Swift3.0 也不支持这种写法，原因会在稍后分析。目前，我们可以使用两种变通方案：\n\n```swift\nself.view.backgroundColor = \"224, 222, 255\".ktColor    // 方案1\nself.view.backgroundColor = \"224, 222, 255\" as KtColor    // 方案2\n```\n\n两者写法类似，但实现原理实际上完全不同。第一种方案是通过拓展 `String` 类型实现的，第二种方案则是通过继承 `UIColor` 实现。\n\n方案1有更好的代码提示，但它对 `String` 类型作了修改，我的demo中有完整的实现，它支持以下输入：\n\n```swift\nself.view.backgroundColor = \"224, 222, 255, 0.5\".ktcolor // 这个是完整版\nself.view.backgroundColor = \"224, 222, 255\".ktcolor // alpha值默认为1\nself.view.backgroundColor = \"224,222,255\".ktcolor // 可以用逗号分割\nself.view.backgroundColor = \"224 222 255\".ktcolor // 可以用空格分割\nself.view.backgroundColor = \"#DC143C\".ktcolor  // 可以使用16进制数字\nself.view.backgroundColor = \"#dc143c\".ktcolor  // 字母可以小写\nself.view.backgroundColor = \"SkyBlue\".ktcolor  // 可以直接使用颜色的英文名字\n```\n\n虽然方案2不会对现有代码做修改，但它并不适用于所有系统类型，比如 `NSDate` 或 `NSURL` 类型，出于这种考虑，demo中仅实现了关键逻辑。但这种实现方法最接近于理想的解决方案，一旦时机合适，我们就可以去掉丑陋的 `as KtColor`。\n\n# 拓展字符串\n\n第一种方案通过拓展 `String` 类型实现，它添加了一个 `ktcolor` 计算属性，主要涉及到字符串的分割与处理，还有一些容错、判断等，这些就不是本文的重点了，如果有兴趣，读者可以通过阅读源码获得更加深入的了解。\n\n这种方案的好处在于它还适用于 `NSDate`、`NSURL`等类型。比如，下面的代码可以通过类似的技术实现：\n\n```swift\nlet date = \"2016-02-17 24:00:00\".ktdate\nlet url = \"http://bestswifter.com\".kturl\n```\n\n不过，方案一选择的技术注定了它没有再简化的空间了。如果不能显著的减少代码量，它就没有理由取代原生的方案。\n\n# 字符串字面量\n\n方案二和理想方案采用的都是同一个思路：“利用字符串字面量创建对象”。在我的[这篇文章](http://www.jianshu.com/p/07cf2a6ad917)中对此有比较详细的解释。\n\n简单来说，我们要做的只是为 `UIColor` 类型添加如下的拓展：\n\n```swift\nextension UIColor: StringLiteralConvertible {\n    public init(stringLiteral value: String) {\n    \t//这里的数字是随便写的，实际上需要解析字符串\n        self.init(red: 0.5, green: 0.8, blue: 0.25, alpha: 1)\n    }\n    \n    public init(extendedGraphemeClusterLiteral value: String) {\n        self.init(stringLiteral: value)\n    }\n    \n    public init(unicodeScalarLiteral value: String) {\n        self.init(stringLiteral: value)\n    }\n}\n```\n\n不过你会收到这样的报错：\n\n> Initializer requirement 'init(stringLiteral:)' can only be satisfied by a `required` initializer in the definition of non-final class 'UIColor'\n\nXcode 的报错有时候不爱说人话，其实这句话的意思是说，'UIColor' 不是一个标记为 `final` 的类，也就是它还可以被继承。因此 `init(stringLiteral:)` 函数需要被标记为 `required` 以确保所有子类都实现了这个函数。否则，如果有子类没有实现它，那么子类就不满足 `StringLiteralConvertible ` 协议。\n\n好吧，我们听从 Xcode 的指示，把每个函数都标记为 `required`，新的问题又出现了：\n\n> 'required' initializer must be declared directly in class 'UIColor' (not in an extension)\n\n这是因为 Swift 不允许在类型拓展中声明 `required` 函数。`required` 函数必须被直接声明在类的内部。\n\n这就导致了一个死循环，因此目前理想方案无法实现，除非未来 Swift 允许在拓展中声明`required` 函数。\n\n# 继承\n\n方案二采用了变通的解决方案。首先创建一个 `UIColor` 的子类，我们可以让这个子类实现 `StringLiteralConvertible ` 协议，然后将子类对象赋值给父类：\n\n```swift\nclass KtColor: UIColor, StringLiteralConvertible {\n    required init(stringLiteral value: String) {\n    \t//这里的数字是随便写的，实际上需要解析字符串\n        super.init(red: 0.5, green: 0.8, blue: 0.25, alpha: 1)\n    }\n    \n    required convenience init(extendedGraphemeClusterLiteral value: String) {\n        self.init(stringLiteral: value)\n    }\n    \n    required convenience init(unicodeScalarLiteral value: String) {\n        self.init(stringLiteral: value)\n    }\n\n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n\n    required convenience init(colorLiteralRed red: Float, green: Float, blue: Float, alpha: Float) {\n        self.init(colorLiteralRed: red, green: green, blue: blue, alpha: alpha)\n    }\n}\n\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    \n    self.view.backgroundColor = \"224, 222, 255\" as KtColor\n}\n```\n\n这种方法有一个显而易见的好处，一旦 Swift 做出了修改，比如允许在拓展中声明`required` 函数，我们只需要微小的改动就可以实现理想方案。\n\n# 局限性\n\n继承 UIKit 中的类并不总是一种可行的方法。比如 `NSDate` 类其实是一个类簇，官网对它有如下解释：\n\n> The major reason for subclassing NSDate is to create a class with convenience methods for working with a particular calendrical system. But you could also require a custom NSDate class for other reasons, such as to get a date and time value that provides a finer temporal granularity. If you want to subclass NSDate to obtain behavior different than that provided by the private or public subclasses, you must do these things:\n> \n> 列出了一大串你根本不想去做的事，省略一万字。。。。。。\n\n简单来说，如果你想继承 `NSDate`，就必须重新实现它。\n\n除了类簇，像 `NSURL` 这样，指定构造函数是可失败构造函数的类也无法使用继承：\n\n```swift\nclass KtURL : NSURL, StringLiteralConvertible {\n    required init(stringLiteral value: StringLiteralType) {\n        super.init(string: value, relativeToURL: nil)\n    }\n    // 其他的函数略\n}\n```\n\n`StringLiteralConvertible`协议中定义的构造函数是不可失败构造函数，它不会返回 `nil`。在它的内部调用了父类，也就是 `NSURL` 的 `init(string:relativetoURL:)`，这是可失败构造函数。Swift不允许出现这种情况，否则如果传入的参数 `value` 不合法，你会得到 `nil`么，如果不是 `nil` 那么会得到什么？\n\n# 总结\n\n完全使用字符串字面量创建已有类的实例变量在目前是无法实现的，一种想法类似但是存在局限性的方法是使用子类。或者也可以拓展 `String`类型，但如果相比于原生实现，不能较大幅度的减少代码量，我不建议这么做。\n\n参考资料：\n\n1. [https://devforums.apple.com/message/1057368#1057368](https://devforums.apple.com/message/1057368#1057368)：这个好像是喵神提的问题。\n\n2. [Swift: Simple, Safe, Inflexible](https://medium.com/bloc-posts/swift-simple-safe-inflexible-68ff6fa927dc#.5ymodxskm)","html":"<p>我为这篇文章制作了demo，已经上传到我的GitHub：<a href=\"https://github.com/bestswifter/MySampleCode/tree/master/KtColor\">KTColor</a>，如果觉得有帮助还望给个star以示支持。</p>\n\n<p><code>UIColor</code> 提供了几个默认的颜色，要想创建除此以外的颜色，一般是通过RGB和alpha值创建(十六进制的颜色其实也是被转换成RGB)。在 Objective-C 中，这可以通过自定义宏来完成，在 Swift 中，我们可以利用 Swift 的一些语法特性来简化创建 <code>UIColor</code> 对象的过程。我想，最理想的解决方案应该是这样：</p>\n\n<pre><code class=\"language-swift\">override func viewDidLoad() {  \n    super.viewDidLoad()\n\n    self.view.backgroundColor = \"224, 222, 255\"\n}\n</code></pre>\n\n<h1 id=\"\">变通方案</h1>\n\n<p>然而很不幸的是，在目前的 Swift 版本(2.1)中，这种写法暂时无法实现。据我所知，Swift3.0 也不支持这种写法，原因会在稍后分析。目前，我们可以使用两种变通方案：</p>\n\n<pre><code class=\"language-swift\">self.view.backgroundColor = \"224, 222, 255\".ktColor    // 方案1  \nself.view.backgroundColor = \"224, 222, 255\" as KtColor    // 方案2  \n</code></pre>\n\n<p>两者写法类似，但实现原理实际上完全不同。第一种方案是通过拓展 <code>String</code> 类型实现的，第二种方案则是通过继承 <code>UIColor</code> 实现。</p>\n\n<p>方案1有更好的代码提示，但它对 <code>String</code> 类型作了修改，我的demo中有完整的实现，它支持以下输入：</p>\n\n<pre><code class=\"language-swift\">self.view.backgroundColor = \"224, 222, 255, 0.5\".ktcolor // 这个是完整版  \nself.view.backgroundColor = \"224, 222, 255\".ktcolor // alpha值默认为1  \nself.view.backgroundColor = \"224,222,255\".ktcolor // 可以用逗号分割  \nself.view.backgroundColor = \"224 222 255\".ktcolor // 可以用空格分割  \nself.view.backgroundColor = \"#DC143C\".ktcolor  // 可以使用16进制数字  \nself.view.backgroundColor = \"#dc143c\".ktcolor  // 字母可以小写  \nself.view.backgroundColor = \"SkyBlue\".ktcolor  // 可以直接使用颜色的英文名字  \n</code></pre>\n\n<p>虽然方案2不会对现有代码做修改，但它并不适用于所有系统类型，比如 <code>NSDate</code> 或 <code>NSURL</code> 类型，出于这种考虑，demo中仅实现了关键逻辑。但这种实现方法最接近于理想的解决方案，一旦时机合适，我们就可以去掉丑陋的 <code>as KtColor</code>。</p>\n\n<h1 id=\"\">拓展字符串</h1>\n\n<p>第一种方案通过拓展 <code>String</code> 类型实现，它添加了一个 <code>ktcolor</code> 计算属性，主要涉及到字符串的分割与处理，还有一些容错、判断等，这些就不是本文的重点了，如果有兴趣，读者可以通过阅读源码获得更加深入的了解。</p>\n\n<p>这种方案的好处在于它还适用于 <code>NSDate</code>、<code>NSURL</code>等类型。比如，下面的代码可以通过类似的技术实现：</p>\n\n<pre><code class=\"language-swift\">let date = \"2016-02-17 24:00:00\".ktdate  \nlet url = \"http://bestswifter.com\".kturl  \n</code></pre>\n\n<p>不过，方案一选择的技术注定了它没有再简化的空间了。如果不能显著的减少代码量，它就没有理由取代原生的方案。</p>\n\n<h1 id=\"\">字符串字面量</h1>\n\n<p>方案二和理想方案采用的都是同一个思路：“利用字符串字面量创建对象”。在我的<a href=\"http://www.jianshu.com/p/07cf2a6ad917\">这篇文章</a>中对此有比较详细的解释。</p>\n\n<p>简单来说，我们要做的只是为 <code>UIColor</code> 类型添加如下的拓展：</p>\n\n<pre><code class=\"language-swift\">extension UIColor: StringLiteralConvertible {  \n    public init(stringLiteral value: String) {\n        //这里的数字是随便写的，实际上需要解析字符串\n        self.init(red: 0.5, green: 0.8, blue: 0.25, alpha: 1)\n    }\n\n    public init(extendedGraphemeClusterLiteral value: String) {\n        self.init(stringLiteral: value)\n    }\n\n    public init(unicodeScalarLiteral value: String) {\n        self.init(stringLiteral: value)\n    }\n}\n</code></pre>\n\n<p>不过你会收到这样的报错：</p>\n\n<blockquote>\n  <p>Initializer requirement 'init(stringLiteral:)' can only be satisfied by a <code>required</code> initializer in the definition of non-final class 'UIColor'</p>\n</blockquote>\n\n<p>Xcode 的报错有时候不爱说人话，其实这句话的意思是说，'UIColor' 不是一个标记为 <code>final</code> 的类，也就是它还可以被继承。因此 <code>init(stringLiteral:)</code> 函数需要被标记为 <code>required</code> 以确保所有子类都实现了这个函数。否则，如果有子类没有实现它，那么子类就不满足 <code>StringLiteralConvertible</code> 协议。</p>\n\n<p>好吧，我们听从 Xcode 的指示，把每个函数都标记为 <code>required</code>，新的问题又出现了：</p>\n\n<blockquote>\n  <p>'required' initializer must be declared directly in class 'UIColor' (not in an extension)</p>\n</blockquote>\n\n<p>这是因为 Swift 不允许在类型拓展中声明 <code>required</code> 函数。<code>required</code> 函数必须被直接声明在类的内部。</p>\n\n<p>这就导致了一个死循环，因此目前理想方案无法实现，除非未来 Swift 允许在拓展中声明<code>required</code> 函数。</p>\n\n<h1 id=\"\">继承</h1>\n\n<p>方案二采用了变通的解决方案。首先创建一个 <code>UIColor</code> 的子类，我们可以让这个子类实现 <code>StringLiteralConvertible</code> 协议，然后将子类对象赋值给父类：</p>\n\n<pre><code class=\"language-swift\">class KtColor: UIColor, StringLiteralConvertible {  \n    required init(stringLiteral value: String) {\n        //这里的数字是随便写的，实际上需要解析字符串\n        super.init(red: 0.5, green: 0.8, blue: 0.25, alpha: 1)\n    }\n\n    required convenience init(extendedGraphemeClusterLiteral value: String) {\n        self.init(stringLiteral: value)\n    }\n\n    required convenience init(unicodeScalarLiteral value: String) {\n        self.init(stringLiteral: value)\n    }\n\n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n\n    required convenience init(colorLiteralRed red: Float, green: Float, blue: Float, alpha: Float) {\n        self.init(colorLiteralRed: red, green: green, blue: blue, alpha: alpha)\n    }\n}\n\noverride func viewDidLoad() {  \n    super.viewDidLoad()\n\n    self.view.backgroundColor = \"224, 222, 255\" as KtColor\n}\n</code></pre>\n\n<p>这种方法有一个显而易见的好处，一旦 Swift 做出了修改，比如允许在拓展中声明<code>required</code> 函数，我们只需要微小的改动就可以实现理想方案。</p>\n\n<h1 id=\"\">局限性</h1>\n\n<p>继承 UIKit 中的类并不总是一种可行的方法。比如 <code>NSDate</code> 类其实是一个类簇，官网对它有如下解释：</p>\n\n<blockquote>\n  <p>The major reason for subclassing NSDate is to create a class with convenience methods for working with a particular calendrical system. But you could also require a custom NSDate class for other reasons, such as to get a date and time value that provides a finer temporal granularity. If you want to subclass NSDate to obtain behavior different than that provided by the private or public subclasses, you must do these things:</p>\n  \n  <p>列出了一大串你根本不想去做的事，省略一万字。。。。。。</p>\n</blockquote>\n\n<p>简单来说，如果你想继承 <code>NSDate</code>，就必须重新实现它。</p>\n\n<p>除了类簇，像 <code>NSURL</code> 这样，指定构造函数是可失败构造函数的类也无法使用继承：</p>\n\n<pre><code class=\"language-swift\">class KtURL : NSURL, StringLiteralConvertible {  \n    required init(stringLiteral value: StringLiteralType) {\n        super.init(string: value, relativeToURL: nil)\n    }\n    // 其他的函数略\n}\n</code></pre>\n\n<p><code>StringLiteralConvertible</code>协议中定义的构造函数是不可失败构造函数，它不会返回 <code>nil</code>。在它的内部调用了父类，也就是 <code>NSURL</code> 的 <code>init(string:relativetoURL:)</code>，这是可失败构造函数。Swift不允许出现这种情况，否则如果传入的参数 <code>value</code> 不合法，你会得到 <code>nil</code>么，如果不是 <code>nil</code> 那么会得到什么？</p>\n\n<h1 id=\"\">总结</h1>\n\n<p>完全使用字符串字面量创建已有类的实例变量在目前是无法实现的，一种想法类似但是存在局限性的方法是使用子类。或者也可以拓展 <code>String</code>类型，但如果相比于原生实现，不能较大幅度的减少代码量，我不建议这么做。</p>\n\n<p>参考资料：</p>\n\n<ol>\n<li><p><a href=\"https://devforums.apple.com/message/1057368#1057368\">https://devforums.apple.com/message/1057368#1057368</a>：这个好像是喵神提的问题。</p></li>\n<li><p><a href=\"https://medium.com/bloc-posts/swift-simple-safe-inflexible-68ff6fa927dc#.5ymodxskm\">Swift: Simple, Safe, Inflexible</a></p></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-02-18T00:24:43.000Z","created_by":1,"updated_at":"2016-02-18T00:30:42.000Z","updated_by":1,"published_at":"2016-02-18T00:30:42.000Z","published_by":1},{"id":22,"uuid":"cddd9d6b-779b-43be-9e44-cb26805cf05e","title":"iOS 高效添加圆角效果实战讲解","slug":"efficient-rounded-corner","markdown":"圆角（RounderCorner）是一种很常见的视图效果，相比于直角，它更加柔和优美，易于接受。但很多人并不清楚如何设置圆角的正确方式和原理。设置圆角会带来一定的性能损耗，如何提高性能是另一个需要重点讨论的话题。我查阅了一些现有的资料，收获良多的同时也发现了一些误导人错误。本文总结整理了一些知识点，概括如下：\n\n* 设置圆角的正确姿势及其原理\n* 设置圆角的性能损耗\n* 其他设置圆角的方法，以及最优选择\n\n我为本文制作了一个 demo，读者可以在我的 github 上 clone 下来：[CornerRadius](https://github.com/bestswifter/MySampleCode/tree/master/CornerRadius)，如果觉得有帮助还望给个star以示支持。项目由 Swift 实现，但请务必相信我即使你只会 Objective-C，也可以看懂它。因为其中的关键知识与 Swift 无关。\n\n# 正确姿势\n\n首先，我想要声明的一点是：\n\n> **设置圆角很简单，它不会带来任何性能损耗**\n\n因为这件事本来就很简单，它只需要一行代码：\n\n```swift\nview.layer.cornerRadius = 5\n```\n\n先别急着关掉网页，也别急着回复，我们让事实说话。打开 Instuments，选择 **Core Animation** 调试，你会发现既没有 Off-Screen Render，也没有降低帧数。关于使用 Instuments 分析应用，你可以参考我的这篇文章：[UIKit性能调优实战讲解](http://www.jianshu.com/p/619cf14640f3)。从截图中可以看到第三个棕色视图**确确实实**设置了圆角：\n\n![圆角效果](http://upload-images.jianshu.io/upload_images/1171077-ce706c8797fdcdef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不过查看一下代码可以发现，有一个 `UILabel` 也设置了圆角，但是没有表现出任何变化。关于这一点，你可以查看 `cornerRadius` 属性的注释：\n\n> By default, the corner radius does not apply to the image in the layer’s contents property; it applies only to the background color and border of the layer. However, setting the masksToBounds property to true causes the content to be clipped to the rounded corners.\n\n也就是说在默认情况下，这个属性只会影响视图的背景颜色和 border。对于 `UILabel` 这样内部还有子视图的控件就无能为力了。所以很多情况下我们会看到这样的代码：\n\n```swift\nlabel.layer.cornerRadius = 5\nlabel.layer.masksToBounds = true\n```\n\n我们把第二行代码添加到 `CustomTableViewCell` 的构造方法中，再次运行 Instument，就可以看到圆角效果了。\n\n# 性能损耗\n\n如果你勾选上 **Color Offscreen-Rendered Yellow**，就会发现 label 的四周出现了黄色的标记，说明这里出现了离屏渲染。关于离屏渲染的介绍，同样可以参考：[UIKit性能调优实战讲解](http://www.jianshu.com/p/619cf14640f3)，就不在本文赘述了。\n\n需要强调的一点是，**离屏渲染并非由设置圆角导致的！**通过控制变量的方法很容易得出这个结论，因为 UIView 只是设置了 `cornerRadius`，但它没有出现离屏渲染。某些比较权威的文章，比如 [Stackoverflow](http://stackoverflow.com/questions/13158796/what-triggers-offscreen-rendering-blending-and-layoutsubviews-in-ios) 和 [CodeReview](http://www.reviewcode.cn/article.html?reviewId=7) 都提到设置 `cornerRadius` 会导致离屏渲染从而影响性能，我想这实在是冤枉了可爱的 `cornerRadius` 变量，也误导了别人。\n\n虽然设置 `masksToBounds` 会导致离屏渲染，从而影响性能，但是这个影响到底会有多大？在我的 iPhone6 上，即使出现了 17 个带有圆角的视图，滑动时的帧数依然在 58 - 59 fps 左右波动。\n\n然而，这并非说明 iOS 9 做了什么特殊优化，或者是离屏渲染的影响不大，其主要原因在于**圆角不够多**。当我将一个 `UIImageView` 也设置成圆角，也就是屏幕上的圆角视图达到 34 个时，fps 大幅度下降，大约只有 33 左右。基本上已经达到了影响用户体验的范围。因此，一切不讲依据的优化都是耍流氓，如果你的圆角视图不多，cell 不复杂，就不要费力气折腾了。\n\n# 高效地设置圆角\n\n假设现在圆角视图非常多（比如在 UICollectionView 中），那么如何为视图高效的添加圆角呢？网上的教程大多没有说全，因为这个事要分两种情况考虑。为普通的 `UIView` 设置圆角，和为 `UIImageView` 设置圆角的原理截然不同。\n\n有一种做法是这样的，这种写法试图实现 `cornerRadius = 3` 的效果：\n\n```swift\noverride func drawRect(rect: CGRect) {\n    let maskPath = UIBezierPath(roundedRect: rect,\n                                byRoundingCorners: .AllCorners,\n                                cornerRadii: CGSize(width: 3, height: 3))\n    let maskLayer = CAShapeLayer()\n    maskLayer.frame = self.bounds\n    maskLayer.path = maskPath.CGPath\n    self.layer.mask = maskLayer\n}\n```\n\n**不过这是一种错的离谱的写法！**\n\n首先，我们应该尽量避免重写 `drawRect` 方法。不恰当的使用这个方法会导致内存暴增。举个例子，iPhone6 上与屏幕等大的 `UIView`，即使重写一个空的 `drawRect` 方法，它也至少占用 `750 * 1134 * 4 字节 ≈ 3.4 Mb` 的内存。在 [内存恶鬼drawRect](http://bihongbo.com/2016/01/03/memoryGhostdrawRect/) 及其后续中，作者详细介绍了其中原理，据他测试，在 iPhone6 上空的、与屏幕等大的视图重写 `drawRect` 方法会消耗 5.2 Mb 内存。总之，能避免重写 `drawRect` 方法就尽可能避免。\n\n其次，这种方法本质上是用遮罩层 `mask` 来实现，因此同样无可避免的会导致离屏渲染。我试着将此前 34 个视图的圆角改用这种方法实现，结果 fps 掉到 11 左右。已经属于卡出翔的节奏了。\n\n忘掉这种写法吧，下面介绍正确的高效设置圆角的姿势。\n\n## 为 UIView 添加圆角\n\n这种做法的原理是手动画出圆角。虽然我们之前说过，为普通的视图直接设置 `cornerRadius` 属性即可。但万一不可避免的需要使用 `masksToBounds`，就可以使用下面这种方法，它的核心代码如下：\n\n```swift\nfunc kt_drawRectWithRoundedCorner(radius radius: CGFloat,\n                                  borderWidth: CGFloat,\n                                  backgroundColor: UIColor,\n                                  borderColor: UIColor) -> UIImage {    \n    UIGraphicsBeginImageContextWithOptions(sizeToFit, false, UIScreen.mainScreen().scale)\n    let context = UIGraphicsGetCurrentContext()\n    \n    CGContextMoveToPoint(context, 开始位置);  // 开始坐标右边开始\n    CGContextAddArcToPoint(context, x1, y1, x2, y2, radius);  // 这种类型的代码重复四次\n    \n    CGContextDrawPath(UIGraphicsGetCurrentContext(), .FillStroke)\n    let output = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return output\n}\n```\n\n这个方法返回的是 `UIImage`，也就是说我们利用 Core Graphics 自己画出了一个圆角矩形。除了一些必要的代码外，最核心的就是 `CGContextAddArcToPoint ` 函数。它中间的四个参数表示曲线的起点和终点坐标，最后一个参数表示半径。调用了四次函数后，就可以画出圆角矩形。最后再从当前的绘图上下文中获取图片并返回。\n\n有了这个图片后，我们创建一个 `UIImageView` 并插入到视图层级的底部：\n\n```swift\nextension UIView {\n    func kt_addCorner(radius radius: CGFloat,\n                      borderWidth: CGFloat,\n                      backgroundColor: UIColor,\n                      borderColor: UIColor) {\n        let imageView = UIImageView(image: kt_drawRectWithRoundedCorner(radius: radius,\n                                    borderWidth: borderWidth,\n                                    backgroundColor: backgroundColor,\n                                    borderColor: borderColor))\n        self.insertSubview(imageView, atIndex: 0)\n    }\n}\n```\n\n完整的代码可以在项目中找到，使用时，你只需要这样写：\n\n```swift\nlet view = UIView(frame: CGRectMake(1,2,3,4))\nview.kt_addCorner(radius: 6)\n```\n\n## 为 UIImageView 添加圆角\n\n相比于上面一种实现方法，为 `UIImageView` 添加圆角更为常用。它的实现思路是直接截取图片：\n\n```swift\nextension UIImage {\n    func kt_drawRectWithRoundedCorner(radius radius: CGFloat, _ sizetoFit: CGSize) -> UIImage {\n        let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: sizetoFit)\n        \n        UIGraphicsBeginImageContextWithOptions(rect.size, false, UIScreen.mainScreen().scale)\n        CGContextAddPath(UIGraphicsGetCurrentContext(),\n            UIBezierPath(roundedRect: rect, byRoundingCorners: UIRectCorner.AllCorners,\n                cornerRadii: CGSize(width: radius, height: radius)).CGPath)\n        CGContextClip(UIGraphicsGetCurrentContext())\n        \n        self.drawInRect(rect)\n        CGContextDrawPath(UIGraphicsGetCurrentContext(), .FillStroke)\n        let output = UIGraphicsGetImageFromCurrentImageContext();\n        UIGraphicsEndImageContext();\n        \n        return output\n    }\n}\n```\n\n圆角路径直接用贝塞尔曲线绘制，一个意外的 bonus 是还可以选择哪几个角有圆角效果。这个函数的效果是将原来的 `UIImage` 剪裁出圆角。配合着这函数，我们可以为 UIImageView 拓展一个设置圆角的方法：\n\n```swift\nextension UIImageView {\n    /**\n     / !!!只有当 imageView 不为nil 时，调用此方法才有效果\n     \n     :param: radius 圆角半径\n     */\n    override func kt_addCorner(radius radius: CGFloat) {\n        self.image = self.image?.kt_drawRectWithRoundedCorner(radius: radius, self.bounds.size)\n    }\n}\n```\n\n完整的代码可以在项目中找到，使用时，你只需要这样写：\n\n```swift\nlet imageView = let imgView1 = UIImageView(image: UIImage(name: \"\"))\nimageView.kt_addCorner(radius: 6)\n```\n\n### 提醒\n\n无论使用上面哪种方法，你都需要小心使用背景颜色。因为此时我们没有设置 `masksToBounds`，因此超出圆角的部分依然会被显示。因此，你不应该再使用背景颜色，可以在绘制圆角矩形时设置填充颜色来达到类似效果。\n\n在为 `UIImageView` 添加圆角时，请确保 `image` 属性不是 `nil`，否则这个设置将会无效。\n\n# 实战测试\n\n回到 demo 中，测试一下刚刚定义的这两个设置圆角的方法。首先在 `setupContent` 方法中把这两行代码的注释取消掉：\n\n```swift\nimgView1.kt_addCorner(radius: 5)\nimgView2.kt_addCorner(radius: 5)\n\n```\n\n然后使用自定义的方法为 label 和 view 设置圆角：\n\n```swift\nview.kt_addCorner(radius: 6)\nlabel.kt_addCorner(radius: 6)\n```\n\n现在，我们不仅成功的添加了圆角效果，同时还保证了性能不受影响：\n\n![性能测试](http://upload-images.jianshu.io/upload_images/1171077-331ca6074d5b02c2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n# 总结\n\n1. 如果能够只用 `cornerRadius` 解决问题，就不用优化。\n2. 如果必须设置 `masksToBounds`，可以参考圆角视图的数量，如果数量较少（一页只有几个）也可以考虑不用优化。\n3. `UIImageView` 的圆角通过直接截取图片实现，其它视图的圆角可以通过 Core Graphics 画出圆角矩形实现。\n\n# 参考资料\n\n1. [小心别让圆角成了你列表的帧数杀手](http://www.cocoachina.com/ios/20150803/12873.html)\n2. [关于性能的一些问题](http://www.reviewcode.cn/article.html?reviewId=7)","html":"<p>圆角（RounderCorner）是一种很常见的视图效果，相比于直角，它更加柔和优美，易于接受。但很多人并不清楚如何设置圆角的正确方式和原理。设置圆角会带来一定的性能损耗，如何提高性能是另一个需要重点讨论的话题。我查阅了一些现有的资料，收获良多的同时也发现了一些误导人错误。本文总结整理了一些知识点，概括如下：</p>\n\n<ul>\n<li>设置圆角的正确姿势及其原理</li>\n<li>设置圆角的性能损耗</li>\n<li>其他设置圆角的方法，以及最优选择</li>\n</ul>\n\n<p>我为本文制作了一个 demo，读者可以在我的 github 上 clone 下来：<a href=\"https://github.com/bestswifter/MySampleCode/tree/master/CornerRadius\">CornerRadius</a>，如果觉得有帮助还望给个star以示支持。项目由 Swift 实现，但请务必相信我即使你只会 Objective-C，也可以看懂它。因为其中的关键知识与 Swift 无关。</p>\n\n<h1 id=\"\">正确姿势</h1>\n\n<p>首先，我想要声明的一点是：</p>\n\n<blockquote>\n  <p><strong>设置圆角很简单，它不会带来任何性能损耗</strong></p>\n</blockquote>\n\n<p>因为这件事本来就很简单，它只需要一行代码：</p>\n\n<pre><code class=\"language-swift\">view.layer.cornerRadius = 5  \n</code></pre>\n\n<p>先别急着关掉网页，也别急着回复，我们让事实说话。打开 Instuments，选择 <strong>Core Animation</strong> 调试，你会发现既没有 Off-Screen Render，也没有降低帧数。关于使用 Instuments 分析应用，你可以参考我的这篇文章：<a href=\"http://www.jianshu.com/p/619cf14640f3\">UIKit性能调优实战讲解</a>。从截图中可以看到第三个棕色视图<strong>确确实实</strong>设置了圆角：</p>\n\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1171077-ce706c8797fdcdef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"圆角效果\" /></p>\n\n<p>不过查看一下代码可以发现，有一个 <code>UILabel</code> 也设置了圆角，但是没有表现出任何变化。关于这一点，你可以查看 <code>cornerRadius</code> 属性的注释：</p>\n\n<blockquote>\n  <p>By default, the corner radius does not apply to the image in the layer’s contents property; it applies only to the background color and border of the layer. However, setting the masksToBounds property to true causes the content to be clipped to the rounded corners.</p>\n</blockquote>\n\n<p>也就是说在默认情况下，这个属性只会影响视图的背景颜色和 border。对于 <code>UILabel</code> 这样内部还有子视图的控件就无能为力了。所以很多情况下我们会看到这样的代码：</p>\n\n<pre><code class=\"language-swift\">label.layer.cornerRadius = 5  \nlabel.layer.masksToBounds = true  \n</code></pre>\n\n<p>我们把第二行代码添加到 <code>CustomTableViewCell</code> 的构造方法中，再次运行 Instument，就可以看到圆角效果了。</p>\n\n<h1 id=\"\">性能损耗</h1>\n\n<p>如果你勾选上 <strong>Color Offscreen-Rendered Yellow</strong>，就会发现 label 的四周出现了黄色的标记，说明这里出现了离屏渲染。关于离屏渲染的介绍，同样可以参考：<a href=\"http://www.jianshu.com/p/619cf14640f3\">UIKit性能调优实战讲解</a>，就不在本文赘述了。</p>\n\n<p>需要强调的一点是，<strong>离屏渲染并非由设置圆角导致的！</strong>通过控制变量的方法很容易得出这个结论，因为 UIView 只是设置了 <code>cornerRadius</code>，但它没有出现离屏渲染。某些比较权威的文章，比如 <a href=\"http://stackoverflow.com/questions/13158796/what-triggers-offscreen-rendering-blending-and-layoutsubviews-in-ios\">Stackoverflow</a> 和 <a href=\"http://www.reviewcode.cn/article.html?reviewId=7\">CodeReview</a> 都提到设置 <code>cornerRadius</code> 会导致离屏渲染从而影响性能，我想这实在是冤枉了可爱的 <code>cornerRadius</code> 变量，也误导了别人。</p>\n\n<p>虽然设置 <code>masksToBounds</code> 会导致离屏渲染，从而影响性能，但是这个影响到底会有多大？在我的 iPhone6 上，即使出现了 17 个带有圆角的视图，滑动时的帧数依然在 58 - 59 fps 左右波动。</p>\n\n<p>然而，这并非说明 iOS 9 做了什么特殊优化，或者是离屏渲染的影响不大，其主要原因在于<strong>圆角不够多</strong>。当我将一个 <code>UIImageView</code> 也设置成圆角，也就是屏幕上的圆角视图达到 34 个时，fps 大幅度下降，大约只有 33 左右。基本上已经达到了影响用户体验的范围。因此，一切不讲依据的优化都是耍流氓，如果你的圆角视图不多，cell 不复杂，就不要费力气折腾了。</p>\n\n<h1 id=\"\">高效地设置圆角</h1>\n\n<p>假设现在圆角视图非常多（比如在 UICollectionView 中），那么如何为视图高效的添加圆角呢？网上的教程大多没有说全，因为这个事要分两种情况考虑。为普通的 <code>UIView</code> 设置圆角，和为 <code>UIImageView</code> 设置圆角的原理截然不同。</p>\n\n<p>有一种做法是这样的，这种写法试图实现 <code>cornerRadius = 3</code> 的效果：</p>\n\n<pre><code class=\"language-swift\">override func drawRect(rect: CGRect) {  \n    let maskPath = UIBezierPath(roundedRect: rect,\n                                byRoundingCorners: .AllCorners,\n                                cornerRadii: CGSize(width: 3, height: 3))\n    let maskLayer = CAShapeLayer()\n    maskLayer.frame = self.bounds\n    maskLayer.path = maskPath.CGPath\n    self.layer.mask = maskLayer\n}\n</code></pre>\n\n<p><strong>不过这是一种错的离谱的写法！</strong></p>\n\n<p>首先，我们应该尽量避免重写 <code>drawRect</code> 方法。不恰当的使用这个方法会导致内存暴增。举个例子，iPhone6 上与屏幕等大的 <code>UIView</code>，即使重写一个空的 <code>drawRect</code> 方法，它也至少占用 <code>750 * 1134 * 4 字节 ≈ 3.4 Mb</code> 的内存。在 <a href=\"http://bihongbo.com/2016/01/03/memoryGhostdrawRect/\">内存恶鬼drawRect</a> 及其后续中，作者详细介绍了其中原理，据他测试，在 iPhone6 上空的、与屏幕等大的视图重写 <code>drawRect</code> 方法会消耗 5.2 Mb 内存。总之，能避免重写 <code>drawRect</code> 方法就尽可能避免。</p>\n\n<p>其次，这种方法本质上是用遮罩层 <code>mask</code> 来实现，因此同样无可避免的会导致离屏渲染。我试着将此前 34 个视图的圆角改用这种方法实现，结果 fps 掉到 11 左右。已经属于卡出翔的节奏了。</p>\n\n<p>忘掉这种写法吧，下面介绍正确的高效设置圆角的姿势。</p>\n\n<h2 id=\"uiview\">为 UIView 添加圆角</h2>\n\n<p>这种做法的原理是手动画出圆角。虽然我们之前说过，为普通的视图直接设置 <code>cornerRadius</code> 属性即可。但万一不可避免的需要使用 <code>masksToBounds</code>，就可以使用下面这种方法，它的核心代码如下：</p>\n\n<pre><code class=\"language-swift\">func kt_drawRectWithRoundedCorner(radius radius: CGFloat,  \n                                  borderWidth: CGFloat,\n                                  backgroundColor: UIColor,\n                                  borderColor: UIColor) -&gt; UIImage {    \n    UIGraphicsBeginImageContextWithOptions(sizeToFit, false, UIScreen.mainScreen().scale)\n    let context = UIGraphicsGetCurrentContext()\n\n    CGContextMoveToPoint(context, 开始位置);  // 开始坐标右边开始\n    CGContextAddArcToPoint(context, x1, y1, x2, y2, radius);  // 这种类型的代码重复四次\n\n    CGContextDrawPath(UIGraphicsGetCurrentContext(), .FillStroke)\n    let output = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return output\n}\n</code></pre>\n\n<p>这个方法返回的是 <code>UIImage</code>，也就是说我们利用 Core Graphics 自己画出了一个圆角矩形。除了一些必要的代码外，最核心的就是 <code>CGContextAddArcToPoint</code> 函数。它中间的四个参数表示曲线的起点和终点坐标，最后一个参数表示半径。调用了四次函数后，就可以画出圆角矩形。最后再从当前的绘图上下文中获取图片并返回。</p>\n\n<p>有了这个图片后，我们创建一个 <code>UIImageView</code> 并插入到视图层级的底部：</p>\n\n<pre><code class=\"language-swift\">extension UIView {  \n    func kt_addCorner(radius radius: CGFloat,\n                      borderWidth: CGFloat,\n                      backgroundColor: UIColor,\n                      borderColor: UIColor) {\n        let imageView = UIImageView(image: kt_drawRectWithRoundedCorner(radius: radius,\n                                    borderWidth: borderWidth,\n                                    backgroundColor: backgroundColor,\n                                    borderColor: borderColor))\n        self.insertSubview(imageView, atIndex: 0)\n    }\n}\n</code></pre>\n\n<p>完整的代码可以在项目中找到，使用时，你只需要这样写：</p>\n\n<pre><code class=\"language-swift\">let view = UIView(frame: CGRectMake(1,2,3,4))  \nview.kt_addCorner(radius: 6)  \n</code></pre>\n\n<h2 id=\"uiimageview\">为 UIImageView 添加圆角</h2>\n\n<p>相比于上面一种实现方法，为 <code>UIImageView</code> 添加圆角更为常用。它的实现思路是直接截取图片：</p>\n\n<pre><code class=\"language-swift\">extension UIImage {  \n    func kt_drawRectWithRoundedCorner(radius radius: CGFloat, _ sizetoFit: CGSize) -&gt; UIImage {\n        let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: sizetoFit)\n\n        UIGraphicsBeginImageContextWithOptions(rect.size, false, UIScreen.mainScreen().scale)\n        CGContextAddPath(UIGraphicsGetCurrentContext(),\n            UIBezierPath(roundedRect: rect, byRoundingCorners: UIRectCorner.AllCorners,\n                cornerRadii: CGSize(width: radius, height: radius)).CGPath)\n        CGContextClip(UIGraphicsGetCurrentContext())\n\n        self.drawInRect(rect)\n        CGContextDrawPath(UIGraphicsGetCurrentContext(), .FillStroke)\n        let output = UIGraphicsGetImageFromCurrentImageContext();\n        UIGraphicsEndImageContext();\n\n        return output\n    }\n}\n</code></pre>\n\n<p>圆角路径直接用贝塞尔曲线绘制，一个意外的 bonus 是还可以选择哪几个角有圆角效果。这个函数的效果是将原来的 <code>UIImage</code> 剪裁出圆角。配合着这函数，我们可以为 UIImageView 拓展一个设置圆角的方法：</p>\n\n<pre><code class=\"language-swift\">extension UIImageView {  \n    /**\n     / !!!只有当 imageView 不为nil 时，调用此方法才有效果\n\n     :param: radius 圆角半径\n     */\n    override func kt_addCorner(radius radius: CGFloat) {\n        self.image = self.image?.kt_drawRectWithRoundedCorner(radius: radius, self.bounds.size)\n    }\n}\n</code></pre>\n\n<p>完整的代码可以在项目中找到，使用时，你只需要这样写：</p>\n\n<pre><code class=\"language-swift\">let imageView = let imgView1 = UIImageView(image: UIImage(name: \"\"))  \nimageView.kt_addCorner(radius: 6)  \n</code></pre>\n\n<h3 id=\"\">提醒</h3>\n\n<p>无论使用上面哪种方法，你都需要小心使用背景颜色。因为此时我们没有设置 <code>masksToBounds</code>，因此超出圆角的部分依然会被显示。因此，你不应该再使用背景颜色，可以在绘制圆角矩形时设置填充颜色来达到类似效果。</p>\n\n<p>在为 <code>UIImageView</code> 添加圆角时，请确保 <code>image</code> 属性不是 <code>nil</code>，否则这个设置将会无效。</p>\n\n<h1 id=\"\">实战测试</h1>\n\n<p>回到 demo 中，测试一下刚刚定义的这两个设置圆角的方法。首先在 <code>setupContent</code> 方法中把这两行代码的注释取消掉：</p>\n\n<pre><code class=\"language-swift\">imgView1.kt_addCorner(radius: 5)  \nimgView2.kt_addCorner(radius: 5)\n</code></pre>\n\n<p>然后使用自定义的方法为 label 和 view 设置圆角：</p>\n\n<pre><code class=\"language-swift\">view.kt_addCorner(radius: 6)  \nlabel.kt_addCorner(radius: 6)  \n</code></pre>\n\n<p>现在，我们不仅成功的添加了圆角效果，同时还保证了性能不受影响：</p>\n\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1171077-331ca6074d5b02c2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"性能测试\" /></p>\n\n<h1 id=\"\">总结</h1>\n\n<ol>\n<li>如果能够只用 <code>cornerRadius</code> 解决问题，就不用优化。  </li>\n<li>如果必须设置 <code>masksToBounds</code>，可以参考圆角视图的数量，如果数量较少（一页只有几个）也可以考虑不用优化。  </li>\n<li><code>UIImageView</code> 的圆角通过直接截取图片实现，其它视图的圆角可以通过 Core Graphics 画出圆角矩形实现。</li>\n</ol>\n\n<h1 id=\"\">参考资料</h1>\n\n<ol>\n<li><a href=\"http://www.cocoachina.com/ios/20150803/12873.html\">小心别让圆角成了你列表的帧数杀手</a>  </li>\n<li><a href=\"http://www.reviewcode.cn/article.html?reviewId=7\">关于性能的一些问题</a></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-02-28T09:45:24.000Z","created_by":1,"updated_at":"2016-02-28T09:46:12.000Z","updated_by":1,"published_at":"2016-02-28T09:45:41.000Z","published_by":1}],"posts_tags":[{"id":2,"post_id":2,"tag_id":2,"sort_order":0},{"id":3,"post_id":3,"tag_id":3,"sort_order":0},{"id":4,"post_id":3,"tag_id":4,"sort_order":1},{"id":5,"post_id":4,"tag_id":5,"sort_order":0},{"id":6,"post_id":5,"tag_id":6,"sort_order":0},{"id":7,"post_id":5,"tag_id":7,"sort_order":1},{"id":8,"post_id":5,"tag_id":8,"sort_order":2},{"id":9,"post_id":7,"tag_id":9,"sort_order":0},{"id":10,"post_id":7,"tag_id":10,"sort_order":1},{"id":11,"post_id":7,"tag_id":11,"sort_order":2},{"id":12,"post_id":6,"tag_id":9,"sort_order":0},{"id":13,"post_id":6,"tag_id":10,"sort_order":1},{"id":14,"post_id":6,"tag_id":11,"sort_order":2},{"id":15,"post_id":8,"tag_id":9,"sort_order":0},{"id":16,"post_id":9,"tag_id":3,"sort_order":0},{"id":17,"post_id":9,"tag_id":12,"sort_order":1},{"id":18,"post_id":10,"tag_id":13,"sort_order":0},{"id":19,"post_id":10,"tag_id":2,"sort_order":1},{"id":20,"post_id":11,"tag_id":9,"sort_order":0},{"id":21,"post_id":11,"tag_id":14,"sort_order":1},{"id":22,"post_id":11,"tag_id":15,"sort_order":2},{"id":23,"post_id":12,"tag_id":14,"sort_order":0},{"id":24,"post_id":12,"tag_id":9,"sort_order":1},{"id":25,"post_id":13,"tag_id":16,"sort_order":0},{"id":26,"post_id":14,"tag_id":9,"sort_order":0},{"id":27,"post_id":14,"tag_id":8,"sort_order":1},{"id":28,"post_id":15,"tag_id":3,"sort_order":0},{"id":29,"post_id":15,"tag_id":4,"sort_order":1},{"id":30,"post_id":16,"tag_id":9,"sort_order":0},{"id":31,"post_id":16,"tag_id":11,"sort_order":1},{"id":32,"post_id":17,"tag_id":9,"sort_order":0},{"id":33,"post_id":17,"tag_id":11,"sort_order":1},{"id":34,"post_id":18,"tag_id":9,"sort_order":0},{"id":35,"post_id":19,"tag_id":14,"sort_order":0},{"id":36,"post_id":20,"tag_id":3,"sort_order":0},{"id":37,"post_id":20,"tag_id":4,"sort_order":1},{"id":38,"post_id":20,"tag_id":16,"sort_order":2},{"id":39,"post_id":20,"tag_id":9,"sort_order":3},{"id":40,"post_id":21,"tag_id":9,"sort_order":0}],"roles":[{"id":1,"uuid":"9d69a637-ac1f-4338-ba1d-1cf3c292681f","name":"Administrator","description":"管理员","created_at":"2016-01-11T13:11:46.000Z","created_by":1,"updated_at":"2016-01-11T13:11:46.000Z","updated_by":1},{"id":2,"uuid":"2986361a-6621-48cd-8fd6-c87472f144b7","name":"Editor","description":"编辑","created_at":"2016-01-11T13:11:46.000Z","created_by":1,"updated_at":"2016-01-11T13:11:46.000Z","updated_by":1},{"id":3,"uuid":"8cfc6b70-6ad5-4386-b036-ea0eb9dc2a35","name":"Author","description":"作者","created_at":"2016-01-11T13:11:46.000Z","created_by":1,"updated_at":"2016-01-11T13:11:46.000Z","updated_by":1},{"id":4,"uuid":"f9da9a04-55f0-48b8-94f2-69e677654ef8","name":"Owner","description":"博客所有者","created_at":"2016-01-11T13:11:46.000Z","created_by":1,"updated_at":"2016-01-11T13:11:46.000Z","updated_by":1}],"roles_users":[{"id":1,"role_id":4,"user_id":1}],"settings":[{"id":1,"uuid":"77a95eaa-c73f-4130-b778-0310bdaa3741","key":"databaseVersion","value":"004","type":"core","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T13:11:48.000Z","updated_by":1},{"id":2,"uuid":"8a239d97-b6cb-4d6b-8c65-8c5f7b0f7dda","key":"dbHash","value":"e6007452-5c61-4a78-b237-66dcc8f88a8d","type":"core","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T13:11:48.000Z","updated_by":1},{"id":3,"uuid":"14cbf063-0af8-42ca-b446-cee130053cd0","key":"nextUpdateCheck","value":"1456931945","type":"core","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-03-01T15:19:05.000Z","updated_by":1},{"id":4,"uuid":"a250de0f-aea1-4499-9add-90379ef96728","key":"displayUpdateNotification","value":"0.7.0","type":"core","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-03-01T15:19:05.000Z","updated_by":1},{"id":5,"uuid":"bf76d7cb-f128-4976-8926-709e18adc0ad","key":"title","value":"kt's Dev","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1},{"id":6,"uuid":"815cdb56-8d22-4f4f-b838-13fc9086670c","key":"description","value":"欢迎来到Kt的iOS开发小站，我是张星宇(@bestswifter)，目前在读大三，热爱iOS开发。","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1},{"id":7,"uuid":"c6502fb4-3871-4c31-a341-6dd09f77fe93","key":"logo","value":"/content/images/2016/01/avator.jpg","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1},{"id":8,"uuid":"2301d509-d56a-461f-b5ea-224935a47410","key":"cover","value":"/content/images/2016/01/background.jpg","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1},{"id":9,"uuid":"a6654a11-d191-462f-aabc-81c395033240","key":"defaultLang","value":"zh_CN","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1},{"id":10,"uuid":"5c161af8-f6f5-4fd7-9d32-231bef54773f","key":"postsPerPage","value":"6","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1},{"id":11,"uuid":"e3ce8226-ea96-4bf2-9496-a02dbb339ee1","key":"forceI18n","value":"true","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1},{"id":12,"uuid":"a47c3754-72bc-4d52-ab15-c056f0880667","key":"permalinks","value":"/:slug/","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1},{"id":13,"uuid":"b0e2509d-3b7f-48b5-84f2-3d490f3677d9","key":"ghost_head","value":"<script>\nvar _hmt = _hmt || [];\n(function() {\n  var hm = document.createElement(\"script\");\n  hm.src = \"//hm.baidu.com/hm.js?a5692a7e19c32836d83a21539b9eb759\";\n  var s = document.getElementsByTagName(\"script\")[0]; \n  s.parentNode.insertBefore(hm, s);\n})();\n</script>\n","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1},{"id":14,"uuid":"ca7889d3-5809-49cc-957d-2b6d57c5d790","key":"ghost_foot","value":"<script>\n(function(){\n    var bp = document.createElement('script');\n    bp.src = '//push.zhanzhang.baidu.com/push.js';\n    var s = document.getElementsByTagName(\"script\")[0];\n    s.parentNode.insertBefore(bp, s);\n})();\n</script>","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1},{"id":15,"uuid":"48835feb-a53f-4285-bbb4-902db49883ff","key":"labs","value":"{}","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1},{"id":16,"uuid":"ade3cf3c-fee3-453d-9ce3-d78c981bb18f","key":"navigation","value":"[{\"label\":\"首页\", \"url\":\"/\"}]","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1},{"id":17,"uuid":"3f812b37-8e8a-43f2-80e1-acbf8355e02f","key":"activeApps","value":"[]","type":"app","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T13:11:48.000Z","updated_by":1},{"id":18,"uuid":"97f9a055-2bbf-4c9e-aea5-39e3dac1631e","key":"installedApps","value":"[]","type":"app","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-12T02:16:53.000Z","updated_by":1},{"id":19,"uuid":"d6a30726-ecb7-41f7-8304-9cecc634cc2e","key":"isPrivate","value":"false","type":"private","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1},{"id":20,"uuid":"c873facc-cdda-4406-a54f-0d618baf1e82","key":"password","value":"null","type":"private","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1},{"id":21,"uuid":"bdd195a1-4a2e-44c9-aad2-a1a60bea1a17","key":"activeTheme","value":"vno","type":"theme","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-03T14:22:31.000Z","updated_by":1}],"tags":[{"id":5,"uuid":"0b25e63d-70c7-41ef-b0c5-1d48a2734dc0","name":"算法","slug":"suan-fa","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-11T15:09:47.000Z","created_by":1,"updated_at":"2016-01-11T15:09:47.000Z","updated_by":1},{"id":2,"uuid":"701c482c-15c7-4656-9c0f-ad0c55699b75","name":"基础知识","slug":"ji-chu-zhi-shi","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-11T13:39:34.000Z","created_by":1,"updated_at":"2016-01-11T13:39:34.000Z","updated_by":1},{"id":3,"uuid":"e3e59c47-2764-4832-ad85-aeec5af87808","name":"iOS","slug":"ios","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-11T13:48:17.000Z","created_by":1,"updated_at":"2016-01-11T13:48:17.000Z","updated_by":1},{"id":4,"uuid":"37a48c42-a716-4bcd-a157-f8fe9f85f518","name":"UI","slug":"ui","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-11T13:48:17.000Z","created_by":1,"updated_at":"2016-01-11T13:48:17.000Z","updated_by":1},{"id":6,"uuid":"ea71ba68-1217-43ef-99de-d4161fa87414","name":"GCD","slug":"gcd","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T07:58:20.000Z","created_by":1,"updated_at":"2016-01-14T07:58:20.000Z","updated_by":1},{"id":7,"uuid":"389aa2ce-9a97-4614-b4dc-72c77ed1def8","name":"NSOperation","slug":"nsoperation","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T07:58:20.000Z","created_by":1,"updated_at":"2016-01-14T07:58:20.000Z","updated_by":1},{"id":8,"uuid":"37e5d0d8-bc29-4514-9af3-304c69f58d41","name":"多线程","slug":"duo-xian-cheng","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T07:58:20.000Z","created_by":1,"updated_at":"2016-01-14T07:58:20.000Z","updated_by":1},{"id":9,"uuid":"fab2b53b-dc77-436b-bd45-784f96d073d7","name":"Swift","slug":"swift","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:05:35.000Z","created_by":1,"updated_at":"2016-01-14T08:05:35.000Z","updated_by":1},{"id":10,"uuid":"1bf98384-bd51-46b7-bc76-2eab1dfdced4","name":"Array","slug":"array","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:05:35.000Z","created_by":1,"updated_at":"2016-01-14T08:05:35.000Z","updated_by":1},{"id":11,"uuid":"f947f221-cfff-4e71-80c4-144dcd68ec58","name":"源码","slug":"yuan-ma","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:05:35.000Z","created_by":1,"updated_at":"2016-01-14T08:05:35.000Z","updated_by":1},{"id":12,"uuid":"1dae2c6f-9d56-4138-a8f0-ee689eafae3a","name":"Autolayout","slug":"autolayout","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:11:20.000Z","created_by":1,"updated_at":"2016-01-14T08:11:20.000Z","updated_by":1},{"id":13,"uuid":"ada537a4-3529-461f-becb-201a6ca20f40","name":"读书","slug":"du-shu","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:13:23.000Z","created_by":1,"updated_at":"2016-01-14T08:13:23.000Z","updated_by":1},{"id":14,"uuid":"67162769-aeb9-4661-90c1-4e6a5aaab759","name":"Objective-C","slug":"objective-c","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:17:19.000Z","created_by":1,"updated_at":"2016-01-14T08:17:19.000Z","updated_by":1},{"id":15,"uuid":"a7bfc143-972b-470c-b118-64baa4ab75e5","name":"Foundation","slug":"foundation","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:17:19.000Z","created_by":1,"updated_at":"2016-01-14T08:17:19.000Z","updated_by":1},{"id":16,"uuid":"142ea3f4-6d4a-4bba-82dd-166fce2f6525","name":"总结","slug":"zong-jie","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:20:16.000Z","created_by":1,"updated_at":"2016-01-14T08:20:16.000Z","updated_by":1}],"users":[{"id":1,"uuid":"dd6c4295-3190-434c-9c55-76b6388a923c","name":"张星宇","slug":"zhang","password":"$2a$10$L4nMNQU4yqljOtjhWYKK/e35x/8.SnzeTHFlP8FPB2Mmvw3QgKyh6","email":"649395594@qq.com","image":null,"cover":null,"bio":null,"website":null,"location":null,"accessibility":null,"status":"active","language":"zh_CN","meta_title":null,"meta_description":null,"tour":null,"last_login":"2016-02-28T09:45:20.000Z","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-02-28T09:45:20.000Z","updated_by":1}]}}]}