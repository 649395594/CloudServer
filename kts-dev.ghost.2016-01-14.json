{"db":[{"meta":{"exported_on":1452759643163,"version":"004"},"data":{"app_fields":[],"app_settings":[],"apps":[],"client_trusted_domains":[],"permissions":[{"id":1,"uuid":"5ca3fca8-8693-4008-a8f5-6e0d5faffec4","name":"Export database","object_type":"db","action_type":"exportContent","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":2,"uuid":"aea8da83-4bf2-4593-8494-32ec371a7bba","name":"Import database","object_type":"db","action_type":"importContent","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":3,"uuid":"28a8dde6-668f-4c86-b10f-a99997f47fd5","name":"Delete all content","object_type":"db","action_type":"deleteAllContent","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":4,"uuid":"18777053-82b6-4ec0-b446-1137e2ca47e2","name":"Send mail","object_type":"mail","action_type":"send","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":5,"uuid":"c986d00a-af82-4655-b571-d161dad81b62","name":"Browse notifications","object_type":"notification","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":6,"uuid":"c359d160-00cf-4428-a219-13201cf426b3","name":"Add notifications","object_type":"notification","action_type":"add","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":7,"uuid":"40da3006-dae9-4c5d-b9d9-de18fc3f2230","name":"Delete notifications","object_type":"notification","action_type":"destroy","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":8,"uuid":"e5786f6a-05ca-4cea-bfb0-ea0bb2075f9f","name":"Browse posts","object_type":"post","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":9,"uuid":"6e2b543f-75b4-4f59-b174-baef304aaeca","name":"Read posts","object_type":"post","action_type":"read","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":10,"uuid":"9d932cf0-730d-4ffa-9623-ac72dc25f356","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":11,"uuid":"45bfd5dd-a818-43a2-b364-21e953cb87a2","name":"Add posts","object_type":"post","action_type":"add","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":12,"uuid":"0d16b514-eda9-4f03-bf32-2c054cc465d1","name":"Delete posts","object_type":"post","action_type":"destroy","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":13,"uuid":"e7431cfb-2b8c-460a-a51c-9b9224061301","name":"Browse settings","object_type":"setting","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":14,"uuid":"f34068ca-3c3b-4c70-9994-d35a1f92de1b","name":"Read settings","object_type":"setting","action_type":"read","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":15,"uuid":"80d638e1-ed0c-4cde-b5d6-87d42297001d","name":"Edit settings","object_type":"setting","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":16,"uuid":"934d33cd-7272-4e69-aa58-0eea09e47b18","name":"Generate slugs","object_type":"slug","action_type":"generate","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":17,"uuid":"76a5f527-08be-488e-9e4e-4c7a00ca827c","name":"Browse tags","object_type":"tag","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":18,"uuid":"8e8e49b2-e2dd-495d-9cb2-ded271c22367","name":"Read tags","object_type":"tag","action_type":"read","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":19,"uuid":"ec1816dc-47de-44e1-880d-ea5ab667a65d","name":"Edit tags","object_type":"tag","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":20,"uuid":"729db729-7736-453e-bac3-eaca1eea994f","name":"Add tags","object_type":"tag","action_type":"add","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":21,"uuid":"6828f3ef-840e-4582-89ef-c2ef152b3de7","name":"Delete tags","object_type":"tag","action_type":"destroy","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":22,"uuid":"74c272ee-fcfd-4265-9851-61b1c3fc7cad","name":"Browse themes","object_type":"theme","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":23,"uuid":"5a529ed7-7fb5-4b66-8097-a7820800b480","name":"Edit themes","object_type":"theme","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":24,"uuid":"ae1030a2-6237-4220-8f28-9b8325cc17d5","name":"Browse users","object_type":"user","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":25,"uuid":"3262073c-7691-42c7-b0dc-f88d2332e53e","name":"Read users","object_type":"user","action_type":"read","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":26,"uuid":"d8bc98f0-1519-437f-af7b-d5387bbfb689","name":"Edit users","object_type":"user","action_type":"edit","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":27,"uuid":"91c7c0cc-484e-4541-9b4c-ca2f56b7c74b","name":"Add users","object_type":"user","action_type":"add","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":28,"uuid":"34fdfa25-bf81-4af8-92d2-c75a78ae75d7","name":"Delete users","object_type":"user","action_type":"destroy","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":29,"uuid":"b845a56f-c996-4e8f-858f-0f52c13836f3","name":"Assign a role","object_type":"role","action_type":"assign","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1},{"id":30,"uuid":"5d0c7f66-29c2-41cb-a49d-8ccd0a30ae58","name":"Browse roles","object_type":"role","action_type":"browse","object_id":null,"created_at":"2016-01-11T13:11:47.000Z","created_by":1,"updated_at":"2016-01-11T13:11:47.000Z","updated_by":1}],"permissions_apps":[],"permissions_roles":[{"id":1,"role_id":1,"permission_id":1},{"id":2,"role_id":1,"permission_id":2},{"id":3,"role_id":1,"permission_id":3},{"id":4,"role_id":1,"permission_id":4},{"id":5,"role_id":1,"permission_id":5},{"id":6,"role_id":1,"permission_id":6},{"id":7,"role_id":1,"permission_id":7},{"id":8,"role_id":1,"permission_id":8},{"id":9,"role_id":1,"permission_id":9},{"id":10,"role_id":1,"permission_id":10},{"id":11,"role_id":1,"permission_id":11},{"id":12,"role_id":1,"permission_id":12},{"id":13,"role_id":1,"permission_id":13},{"id":14,"role_id":1,"permission_id":14},{"id":15,"role_id":1,"permission_id":15},{"id":16,"role_id":1,"permission_id":16},{"id":17,"role_id":1,"permission_id":17},{"id":18,"role_id":1,"permission_id":18},{"id":19,"role_id":1,"permission_id":19},{"id":20,"role_id":1,"permission_id":20},{"id":21,"role_id":1,"permission_id":21},{"id":22,"role_id":1,"permission_id":22},{"id":23,"role_id":1,"permission_id":23},{"id":24,"role_id":1,"permission_id":24},{"id":25,"role_id":1,"permission_id":25},{"id":26,"role_id":1,"permission_id":26},{"id":27,"role_id":1,"permission_id":27},{"id":28,"role_id":1,"permission_id":28},{"id":29,"role_id":1,"permission_id":29},{"id":30,"role_id":1,"permission_id":30},{"id":31,"role_id":2,"permission_id":8},{"id":32,"role_id":2,"permission_id":9},{"id":33,"role_id":2,"permission_id":10},{"id":34,"role_id":2,"permission_id":11},{"id":35,"role_id":2,"permission_id":12},{"id":36,"role_id":2,"permission_id":13},{"id":37,"role_id":2,"permission_id":14},{"id":38,"role_id":2,"permission_id":16},{"id":39,"role_id":2,"permission_id":17},{"id":40,"role_id":2,"permission_id":18},{"id":41,"role_id":2,"permission_id":19},{"id":42,"role_id":2,"permission_id":20},{"id":43,"role_id":2,"permission_id":21},{"id":44,"role_id":2,"permission_id":24},{"id":45,"role_id":2,"permission_id":25},{"id":46,"role_id":2,"permission_id":26},{"id":47,"role_id":2,"permission_id":27},{"id":48,"role_id":2,"permission_id":28},{"id":49,"role_id":2,"permission_id":29},{"id":50,"role_id":2,"permission_id":30},{"id":51,"role_id":3,"permission_id":8},{"id":52,"role_id":3,"permission_id":9},{"id":53,"role_id":3,"permission_id":11},{"id":54,"role_id":3,"permission_id":13},{"id":55,"role_id":3,"permission_id":14},{"id":56,"role_id":3,"permission_id":16},{"id":57,"role_id":3,"permission_id":17},{"id":58,"role_id":3,"permission_id":18},{"id":59,"role_id":3,"permission_id":20},{"id":60,"role_id":3,"permission_id":24},{"id":61,"role_id":3,"permission_id":25},{"id":62,"role_id":3,"permission_id":30}],"permissions_users":[],"posts":[{"id":3,"uuid":"27e88a8f-a60c-4161-8b53-2712da8e25d3","title":"UIView的生命周期总结","slug":"uiviewlifetime","markdown":"# 序言:\n\n1. `loadView`、`viewDidLoad`、`viewDidAppear`、<font color = \"rgb(226,238,250)\">`initWithNibName`</font>、<font color = \"rgb(226,238,250)\">`awakeFromNib`</font>等经常出现在UIViewController中的方法介绍。\n2. 这些方法分别用来作哪些工作，换言之，创建自定义的View时代码放到以上哪个方法中。\n3. 一个UIView的生命周期是怎样的。以上几个方法的调用顺序如何。\n4. 通过IB和代码加载视图，有什么区别\n\n**文章主要参考官方和文档和StackOVerFlow有关问题整理得出，由于水平有限，如有错误之处请及时与我联系。**\n\n# UIViewController\n#####视图层次和根视图\n\n每个视图控制器都维护一个<font color=red>**视图层次(view hierarchy)**</font>。\n\n因为每个视图都有自己的**子视图**，这个**视图层次**其实也可以理解为一棵树状的数据结构。而树的根节点，也就是根视图(root view)，在UIViewController中以<font color = \"rgb(226,238,250)\">`view`</font>属性。它可以被看做是其他所有子视图的容器。\n\n\n##### 视图的加载方式\n\nUIViewController采用懒加载的方式，也就是说第一次访问到<font color = \"rgb(226,238,250)\">`view`</font>属性时才会加载或创建它。由于视图由视图控制器管理，所以讨论视图的加载方式时，主要讨论视图控制器的加载方式。\n\n* 通过Storyboard加载：这是苹果推荐的方式，也是未来的趋势。\t\t\t\n\t\n\t 通过这种方式创建<font color = \"rgb(226,238,250)\">`UIViewController `</font>对象的话，首先生成<font color = \"rgb(226,238,250)\">`UIStoryboard`</font>类型的对象，然后调用这个对象的<font color = \"rgb(226,238,250)\">`instantiateViewControllerWithIdentifier: `</font>方法\n\n* 通过Nib文件加载：\n\n\tNib文件其实就是xib文件，Storyboard相当于是聚合了多个nib文件，并且添加了对不同的<font color = \"rgb(226,238,250)\">`UIViewController `</font>之间的segue和relationship的管理。但总的实现原理非常类似\n\t\n\t通过这种方式加载视图,需要调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>类的<font color = \"rgb(226,238,250)\">`initWithNibName:bundle:  `</font>方法\n* 通过loadview方法加载：\n\n\t这就是通过代码加载。这需要我们在<font color = \"rgb(226,238,250)\">`loadView`</font>\t方法中，通过编程创建自己的**视图层次**，并且把把根视图赋值给<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`view `</font>属性。\n\t\n因此，通过代码自定义View的时候，<font color = \"rgb(226,238,250)\">`loadView`</font>\t方法大概是这样的：\n\t\n```Objective-C\n- (void)loadView{\n\tself.view = [[XXXView alloc] init];\n}\n```\n\n\n###处理视图相关通知\n\n当视图的可见性发生变化时，视图控制器会自动调用一系列方法来响应变化。\n\n所有可能的状态、方法和状态之间的转换关系在下图中被明确标出。\n\n![](http://7xonij.com1.z0.glb.clouddn.com/UIViewLifeCircle/StateTransitionspng.png)\n\n可以看到每一个will方法都有自己对应的did方法。但是如果我们在will方法中开始一个任务，不仅要在对应的did方法中结束它，还要考虑到和这个will方法相反的那个will方法（注意到Appearing和Disappearing这两个状态是可以互相转化的）\n\n\n#在运行时展示View\n\nUIKit极大的简化了加载和展示View的过程，它大概会按照以下顺序执行一些任务：\n\n1. 通过storyboard文件中的信息实例化视图\n2. 连接outlet和action\n3. 把根视图赋值给<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`view `</font>属性（其实就是调用<font color = \"rgb(226,238,250)\">`loadView`</font>\t方法）\n4. 调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法。要注意，在调用方法前，</font>的<font color = \"rgb(226,238,250)\">`trait collecion`</font>为空且子视图的位置可能不正确\n5. 调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`viewDidLoad `</font>方法。\n\n此时已经完成了视图的加载工作，在展示到屏幕之前，还有以下几个步骤：\n\n6. 调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`viewWillAppear `</font>方法。\n7. 更新视图的布局\n8. 把视图展示到屏幕上\n9. 调用<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`viewDidAppear `</font>方法。\n\n##### awakeFromNib方法\n\n至此，第一个问题已经几乎解释完了，还剩一个<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法。\n\n我们已经知道，<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法被调用时，所有视图的outlet和action已经连接，但还没有被确定。这个方法可以算作是和视图控制器的实例化配合在一起使用的，因为有些需要根据用户喜好来进行设置的内容，无法存在storyboard中，所以可以在<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法中被加载进来。\n\n<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法在视图控制器的生命周期内只会被调用一次。因为它和视图控制器从nib文件中的解档密切相关，和view的关系却不大。\n\n#具体方法的解释\n\n\n#####loadView方法\n\n当执行到<font color = \"rgb(226,238,250)\">`loadView `</font>方法时，视图控制器已经从nib文件中被解档并创建好了，接下来的任务主要是对view进行初始化。\n\n<font color = \"rgb(226,238,250)\">`loadView `</font>方法在<font color = \"rgb(226,238,250)\">`UIViewController `</font>对象的<font color = \"rgb(226,238,250)\">`view `</font>属性被访问到且为空的时候调用。\n这是它与<font color = \"rgb(226,238,250)\">`awakeFromNib `</font>方法的一个区别。假设我们在处理内存警告时释放<font color = \"rgb(226,238,250)\">`view `</font>属性（其实并不应该这么做，这里举个例子）：<font color = \"rgb(226,238,250)\">`self.view = nil `</font>。因此<font color = \"rgb(226,238,250)\">`loadView `</font>方法在视图控制器的生命周期内可能会被多次调用。\n\n这个方法不应该被直接调用，而是由系统自动调用。它会加载或创建一个view并把它赋值给<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`view `</font>属性。\n\n在创建view的过程中，首先会根据<font color = \"rgb(226,238,250)\">`nibName `</font>去找对应的Nib文件然后加载。如果<font color = \"rgb(226,238,250)\">`nibName `</font>为空，或找不到对应的Nib文件，则会创建一个空视图(这种情况一般是纯代码，也就是为什么说代码构建View的时候，要重写<font color = \"rgb(226,238,250)\">`loadView`</font>\t方法)。\n\n注意在重写<font color = \"rgb(226,238,250)\">`loadView`</font>方法的时候，不要调用父类的方法。\n\n\n###viewDidLoad方法\n<font color = \"rgb(226,238,250)\">`loadView`</font>方法执行完之后，就会执行<font color = \"rgb(226,238,250)\">`viewDidLoad `</font>方法。此时整个**视图层次(view hierarchy)**已经被放到内存中。\n\n无论是从nib文件加载，还是通过纯代码编写界面，<font color = \"rgb(226,238,250)\">`viewDidLoad `</font>方法都会执行。我们可以重写这个方法，对通过nib文件加载的view做一些其他的初始化工作。比如可以移除一些视图，修改约束，加载数据等。\n\n\n##### viewWillAppear和viewDidAppear方法\n\n在视图加载完成，并即将显示在屏幕上时，会调用<font color = \"rgb(226,238,250)\">`viewWillAppear `</font>方法，在这个方法里，可以改变当前屏幕方向或状态栏的风格等。\n\n当<font color = \"rgb(226,238,250)\">`viewWillAppear `</font>方法执行完后，系统会执行<font color = \"rgb(226,238,250)\">`viewDidAppear `</font>方法。在这个方法中，还可以对视图做一些关于展示效果方面的修改。\n\n\n#视图的生命历程\n\n到目前为止，我们已经了解了每个方法的作用，接下来就把整个流程梳理一遍。\n\n1. <font color = \"rgb(226,238,250)\">`-[ViewController  initWithCoder:]`或`-[ViewController  initWithNibName:Bundle]`</font>:首先从归档文件中加载<font color = \"rgb(226,238,250)\">`UIViewController `</font>对象。即使是纯代码，也会把nil作为参数传给后者。\n2. <font color = \"rgb(226,238,250)\">`-[ViewController awakeFromNib]`</font>:作为第一个方法的助手，方便处理一些额外的设置。\n3. <font color = \"rgb(226,238,250)\">`-[ViewController loadView]`</font>:创建或加载一个view并把它赋值给<font color = \"rgb(226,238,250)\">`UIViewController `</font>的<font color = \"rgb(226,238,250)\">`view `</font>属性\n4. <font color = \"rgb(226,238,250)\">`-[ViewController viewDidLoad]`</font>:此时整个**视图层次(view hierarchy)**已经被放到内存中，可以移除一些视图，修改约束，加载数据等\n5. <font color = \"rgb(226,238,250)\">`-[ViewController viewWillAppear:] `</font>:视图加载完成，并即将显示在屏幕上,还没有设置动画，可以改变当前屏幕方向或状态栏的风格等。\n6. <font color = \"rgb(226,238,250)\">`-[ViewController viewWillLayoutSubviews]`</font>：即将开始子视图位置布局\n7. <font color = \"rgb(226,238,250)\">`-[ViewController viewDidLayoutSubviews] `</font>：用于通知视图的位置布局已经完成\n8. <font color = \"rgb(226,238,250)\">`-[ViewController viewDidAppear:] `</font>：视图已经展示在屏幕上，可以对视图做一些关于展示效果方面的修改。\n9. <font color = \"rgb(226,238,250)\">`-[ViewController viewWillDisappear:]`</font>：视图即将消失\n10. <font color = \"rgb(226,238,250)\">`-[ViewController viewDidDisappear:]`</font>：视图已经消失\n\n如果考虑<font color = \"rgb(226,238,250)\">`UIViewController`</font>可能在某个时刻释放整个<font color = \"rgb(226,238,250)\">`view`</font>。那么再次加载视图时显然会从步骤3开始。因为此时的<font color = \"rgb(226,238,250)\">`UIViewController`</font>对象依然存在。\n\n#总结\n\n1. 只有init系列的方法,如<font color = \"rgb(226,238,250)\">`initWithNibName`</font>需要自己调用，其他方法如<font color = \"rgb(226,238,250)\">`loadView`</font>和<font color = \"rgb(226,238,250)\">`awakeFromNib`</font>则是系统自动调用。而<font color = \"rgb(226,238,250)\">`viewWill/Did`</font>系列的方法则类似于回调和通知，也会被自动调用。\n2. 纯代码写视图布局时需要注意，要手动调用<font color = \"rgb(226,238,250)\">`loadView`</font>方法，而且不要调用父类的<font color = \"rgb(226,238,250)\">`loadView`</font>方法。纯代码和用IB的区别仅存在于<font color = \"rgb(226,238,250)\">`loadView`</font>方法及其之前，编程时需要注意的也就是<font color = \"rgb(226,238,250)\">`loadView`</font>方法。\n3. 除了<font color = \"rgb(226,238,250)\">`initWithNibName`</font>和<font color = \"rgb(226,238,250)\">`awakeFromNib`</font>方法是处理视图控制器外，其他方法都是处理视图。这两个方法在视图控制器的生命周期里只会调用一次。\n\n\n#参考资料\n\n 1. [UIViewController Class Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/)\n 2. [View Controller Programming Guide for iOS](https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/DefiningYourSubclass.html#//apple_ref/doc/uid/TP40007457-CH7-SW1)\n 3. [NSObject UIKit Additions Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/NSObject_UIKitAdditions/index.html#//apple_ref/occ/instm/NSObject/awakeFromNib)\n 4. [Process of a UIViewController birth](http://stackoverflow.com/questions/5107604/can-somebody-explain-the-process-of-a-uiviewcontroller-birth-which-method-follo)\n 5. [Which should I use, -awakeFromNib or -viewDidLoad?](http://stackoverflow.com/questions/377202/which-should-i-use-awakefromnib-or-viewdidload)\n","html":"<h1 id=\"\">序言:</h1>\n\n<ol>\n<li><code>loadView</code>、<code>viewDidLoad</code>、<code>viewDidAppear</code>、<font color = \"rgb(226,238,250)\"><code>initWithNibName</code></font>、<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>等经常出现在UIViewController中的方法介绍。  </li>\n<li>这些方法分别用来作哪些工作，换言之，创建自定义的View时代码放到以上哪个方法中。  </li>\n<li>一个UIView的生命周期是怎样的。以上几个方法的调用顺序如何。  </li>\n<li>通过IB和代码加载视图，有什么区别</li>\n</ol>\n\n<p><strong>文章主要参考官方和文档和StackOVerFlow有关问题整理得出，由于水平有限，如有错误之处请及时与我联系。</strong></p>\n\n<h1 id=\"uiviewcontroller\">UIViewController</h1>\n\n<h5 id=\"\">视图层次和根视图</h5>\n\n<p>每个视图控制器都维护一个<font color=red><strong>视图层次(view hierarchy)</strong></font>。</p>\n\n<p>因为每个视图都有自己的<strong>子视图</strong>，这个<strong>视图层次</strong>其实也可以理解为一棵树状的数据结构。而树的根节点，也就是根视图(root view)，在UIViewController中以<font color = \"rgb(226,238,250)\"><code>view</code></font>属性。它可以被看做是其他所有子视图的容器。</p>\n\n<h5 id=\"\">视图的加载方式</h5>\n\n<p>UIViewController采用懒加载的方式，也就是说第一次访问到<font color = \"rgb(226,238,250)\"><code>view</code></font>属性时才会加载或创建它。由于视图由视图控制器管理，所以讨论视图的加载方式时，主要讨论视图控制器的加载方式。</p>\n\n<ul>\n<li><p>通过Storyboard加载：这是苹果推荐的方式，也是未来的趋势。            </p>\n\n<p>通过这种方式创建<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>对象的话，首先生成<font color = \"rgb(226,238,250)\"><code>UIStoryboard</code></font>类型的对象，然后调用这个对象的<font color = \"rgb(226,238,250)\"><code>instantiateViewControllerWithIdentifier:</code></font>方法</p></li>\n<li><p>通过Nib文件加载：</p>\n\n<p>Nib文件其实就是xib文件，Storyboard相当于是聚合了多个nib文件，并且添加了对不同的<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>之间的segue和relationship的管理。但总的实现原理非常类似</p>\n\n<p>通过这种方式加载视图,需要调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>类的<font color = \"rgb(226,238,250)\"><code>initWithNibName:bundle:</code></font>方法</p></li>\n<li><p>通过loadview方法加载：</p>\n\n<p>这就是通过代码加载。这需要我们在<font color = \"rgb(226,238,250)\"><code>loadView</code></font>  方法中，通过编程创建自己的<strong>视图层次</strong>，并且把把根视图赋值给<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性。</p></li>\n</ul>\n\n<p>因此，通过代码自定义View的时候，<font color = \"rgb(226,238,250)\"><code>loadView</code></font>    方法大概是这样的：</p>\n\n<pre><code class=\"language-Objective-C\">- (void)loadView{\n    self.view = [[XXXView alloc] init];\n}\n</code></pre>\n\n<h3 id=\"\">处理视图相关通知</h3>\n\n<p>当视图的可见性发生变化时，视图控制器会自动调用一系列方法来响应变化。</p>\n\n<p>所有可能的状态、方法和状态之间的转换关系在下图中被明确标出。</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/UIViewLifeCircle/StateTransitionspng.png\" alt=\"\" /></p>\n\n<p>可以看到每一个will方法都有自己对应的did方法。但是如果我们在will方法中开始一个任务，不仅要在对应的did方法中结束它，还要考虑到和这个will方法相反的那个will方法（注意到Appearing和Disappearing这两个状态是可以互相转化的）</p>\n\n<h1 id=\"view\">在运行时展示View</h1>\n\n<p>UIKit极大的简化了加载和展示View的过程，它大概会按照以下顺序执行一些任务：</p>\n\n<ol>\n<li>通过storyboard文件中的信息实例化视图  </li>\n<li>连接outlet和action  </li>\n<li>把根视图赋值给<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性（其实就是调用<font color = \"rgb(226,238,250)\"><code>loadView</code></font>    方法）  </li>\n<li>调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法。要注意，在调用方法前，</font>的<font color = \"rgb(226,238,250)\"><code>trait collecion</code></font>为空且子视图的位置可能不正确  </li>\n<li>调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>viewDidLoad</code></font>方法。</li>\n</ol>\n\n<p>此时已经完成了视图的加载工作，在展示到屏幕之前，还有以下几个步骤：</p>\n\n<ol>\n<li>调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>viewWillAppear</code></font>方法。  </li>\n<li>更新视图的布局  </li>\n<li>把视图展示到屏幕上  </li>\n<li>调用<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>viewDidAppear</code></font>方法。</li>\n</ol>\n\n<h5 id=\"awakefromnib\">awakeFromNib方法</h5>\n\n<p>至此，第一个问题已经几乎解释完了，还剩一个<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法。</p>\n\n<p>我们已经知道，<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法被调用时，所有视图的outlet和action已经连接，但还没有被确定。这个方法可以算作是和视图控制器的实例化配合在一起使用的，因为有些需要根据用户喜好来进行设置的内容，无法存在storyboard中，所以可以在<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法中被加载进来。</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法在视图控制器的生命周期内只会被调用一次。因为它和视图控制器从nib文件中的解档密切相关，和view的关系却不大。</p>\n\n<h1 id=\"\">具体方法的解释</h1>\n\n<h5 id=\"loadview\">loadView方法</h5>\n\n<p>当执行到<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法时，视图控制器已经从nib文件中被解档并创建好了，接下来的任务主要是对view进行初始化。</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法在<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>对象的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性被访问到且为空的时候调用。 <br />\n这是它与<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法的一个区别。假设我们在处理内存警告时释放<font color = \"rgb(226,238,250)\"><code>view</code></font>属性（其实并不应该这么做，这里举个例子）：<font color = \"rgb(226,238,250)\"><code>self.view = nil</code></font>。因此<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法在视图控制器的生命周期内可能会被多次调用。</p>\n\n<p>这个方法不应该被直接调用，而是由系统自动调用。它会加载或创建一个view并把它赋值给<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性。</p>\n\n<p>在创建view的过程中，首先会根据<font color = \"rgb(226,238,250)\"><code>nibName</code></font>去找对应的Nib文件然后加载。如果<font color = \"rgb(226,238,250)\"><code>nibName</code></font>为空，或找不到对应的Nib文件，则会创建一个空视图(这种情况一般是纯代码，也就是为什么说代码构建View的时候，要重写<font color = \"rgb(226,238,250)\"><code>loadView</code></font>    方法)。</p>\n\n<p>注意在重写<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法的时候，不要调用父类的方法。</p>\n\n<h3 id=\"viewdidload\">viewDidLoad方法</h3>\n\n<p><font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法执行完之后，就会执行<font color = \"rgb(226,238,250)\"><code>viewDidLoad</code></font>方法。此时整个<strong>视图层次(view hierarchy)</strong>已经被放到内存中。</p>\n\n<p>无论是从nib文件加载，还是通过纯代码编写界面，<font color = \"rgb(226,238,250)\"><code>viewDidLoad</code></font>方法都会执行。我们可以重写这个方法，对通过nib文件加载的view做一些其他的初始化工作。比如可以移除一些视图，修改约束，加载数据等。</p>\n\n<h5 id=\"viewwillappearviewdidappear\">viewWillAppear和viewDidAppear方法</h5>\n\n<p>在视图加载完成，并即将显示在屏幕上时，会调用<font color = \"rgb(226,238,250)\"><code>viewWillAppear</code></font>方法，在这个方法里，可以改变当前屏幕方向或状态栏的风格等。</p>\n\n<p>当<font color = \"rgb(226,238,250)\"><code>viewWillAppear</code></font>方法执行完后，系统会执行<font color = \"rgb(226,238,250)\"><code>viewDidAppear</code></font>方法。在这个方法中，还可以对视图做一些关于展示效果方面的修改。</p>\n\n<h1 id=\"\">视图的生命历程</h1>\n\n<p>到目前为止，我们已经了解了每个方法的作用，接下来就把整个流程梳理一遍。</p>\n\n<ol>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController  initWithCoder:]</code>或<code>-[ViewController  initWithNibName:Bundle]</code></font>:首先从归档文件中加载<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>对象。即使是纯代码，也会把nil作为参数传给后者。  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController awakeFromNib]</code></font>:作为第一个方法的助手，方便处理一些额外的设置。  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController loadView]</code></font>:创建或加载一个view并把它赋值给<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>的<font color = \"rgb(226,238,250)\"><code>view</code></font>属性  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewDidLoad]</code></font>:此时整个<strong>视图层次(view hierarchy)</strong>已经被放到内存中，可以移除一些视图，修改约束，加载数据等  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewWillAppear:]</code></font>:视图加载完成，并即将显示在屏幕上,还没有设置动画，可以改变当前屏幕方向或状态栏的风格等。  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewWillLayoutSubviews]</code></font>：即将开始子视图位置布局  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewDidLayoutSubviews]</code></font>：用于通知视图的位置布局已经完成  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewDidAppear:]</code></font>：视图已经展示在屏幕上，可以对视图做一些关于展示效果方面的修改。  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewWillDisappear:]</code></font>：视图即将消失  </li>\n<li><font color = \"rgb(226,238,250)\"><code>-[ViewController viewDidDisappear:]</code></font>：视图已经消失</li>\n</ol>\n\n<p>如果考虑<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>可能在某个时刻释放整个<font color = \"rgb(226,238,250)\"><code>view</code></font>。那么再次加载视图时显然会从步骤3开始。因为此时的<font color = \"rgb(226,238,250)\"><code>UIViewController</code></font>对象依然存在。</p>\n\n<h1 id=\"\">总结</h1>\n\n<ol>\n<li>只有init系列的方法,如<font color = \"rgb(226,238,250)\"><code>initWithNibName</code></font>需要自己调用，其他方法如<font color = \"rgb(226,238,250)\"><code>loadView</code></font>和<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>则是系统自动调用。而<font color = \"rgb(226,238,250)\"><code>viewWill/Did</code></font>系列的方法则类似于回调和通知，也会被自动调用。  </li>\n<li>纯代码写视图布局时需要注意，要手动调用<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法，而且不要调用父类的<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法。纯代码和用IB的区别仅存在于<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法及其之前，编程时需要注意的也就是<font color = \"rgb(226,238,250)\"><code>loadView</code></font>方法。  </li>\n<li>除了<font color = \"rgb(226,238,250)\"><code>initWithNibName</code></font>和<font color = \"rgb(226,238,250)\"><code>awakeFromNib</code></font>方法是处理视图控制器外，其他方法都是处理视图。这两个方法在视图控制器的生命周期里只会调用一次。</li>\n</ol>\n\n<h1 id=\"\">参考资料</h1>\n\n<ol>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/\">UIViewController Class Reference</a></li>\n<li><a href=\"https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/DefiningYourSubclass.html#//apple_ref/doc/uid/TP40007457-CH7-SW1\">View Controller Programming Guide for iOS</a></li>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/NSObject_UIKitAdditions/index.html#//apple_ref/occ/instm/NSObject/awakeFromNib\">NSObject UIKit Additions Reference</a></li>\n<li><a href=\"http://stackoverflow.com/questions/5107604/can-somebody-explain-the-process-of-a-uiviewcontroller-birth-which-method-follo\">Process of a UIViewController birth</a></li>\n<li><a href=\"http://stackoverflow.com/questions/377202/which-should-i-use-awakefromnib-or-viewdidload\">Which should I use, -awakeFromNib or -viewDidLoad?</a></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":"UIView的生命周期总结","meta_description":"","author_id":1,"created_at":"2016-01-11T13:40:39.000Z","created_by":1,"updated_at":"2016-01-11T15:14:48.000Z","updated_by":1,"published_at":"2015-11-26T13:44:00.000Z","published_by":1},{"id":2,"uuid":"2fe16a2a-f153-4000-8658-ca86765487aa","title":"修改一个数字破解Mac上的应用","slug":"xiu-gai-yi-ge-shu-zi-po-jie-macshang-de-ying-yong","markdown":"在某位大神的博客里看到了Mac一款非常好用的App，叫<font color=red>Paw</font>。\n\nPaw可以在Mac上模拟各种HTTP请求，可视化的管理HTTP Header、Parameters、Cookies等，还有一点非常出乎意料的功能是通过下载插件可以自动生成Swfit、OC、JS等多种语言的代码。\n\n然而Paw巨贵（200软妹币），而且破解版不好搜。于是寻思着自己动手解决需求，于是可怜的Paw成了实验对象。[先从这里下载原版app](https://luckymarmot.com/paw),一会儿教程中会逐步分析如何破解这个软件。\n\n由于在此之前我毫无逆向工程方面的经验，在看别人的介绍时各种不懂，深受折磨，所以我尽量用简单、详细的语言描述本次从零开始破解app之旅。作为参考，我用了**大约七个小时**的时间完成了此次破解（大量的时间浪费在找工具以及学习使用工具上，后面可以看到破解这个事情本身并不难）。在文章的最后会给出最新版Paw（2.2.6）的原版和破解版下载。\n\n由于水平有限，只是介绍了基本的逆向工程知识，算是自己的学习笔记，也希望向更多的和我一样还只是菜鸟的程序员科普一些逆向工程的基本知识，同时督促自己平时在Coding过程中的注意代码规范和安全。\n\n#知识储备\n\n想要破解app，首先自己得开发过app，至少了解一些基本的命令行操作，源代码、汇编代码和二进制码的基本定义。如果这些基本要求有某一点不满足，那么整个过程会是非常痛苦的。\n\n#工具准备\n破解Paw用到的工具主要有以下几个。\n\n+ <font color=red>homebrew</font> —— 不知道这个的估计都不好意思说自己是用Mac的程序员。\n+ [<font color=red>Hopper Disassembler</font>](http://pan.baidu.com/s/1bn94SDx) —— 反编译工具，根据可执行文件反编译出汇编码。\n+ [<font color=red>Class-dump</font>](http://stevenygard.com/projects/class-dump/) —— 逆向工程的入门级工具，导出一个App的某些信息。\n+ <font color = red>otx</font> —— 国外某位大神的博客上用的一个工具，我也说不出明确的用处。通过`brew install --HEAD homebrew/head-only/otx`命令安装。\n+ [<font color=red>Hex friend</font>](http://ridiculousfish.com/hexfiend/) —— 二进制文件编辑器，要用这个修改原来的二进制文件。\n+ <font color=red>gdb</font> —— 著名的调试器，用lldb也行。通过`brew install gdb`命令安装。\n\n#Begin cracking\n\n###找到破解点\n要破解App当然要明白自己为什么要破解它，它哪一点限制了我们，首先运行原版的Paw。可以看到如下界面:\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/real-paw-welcome.png)\n\n这个Welcome界面非常讨厌，由于它的存在，我们不能点击程序主界面。而想要关掉这个Welcome界面，只有两个方法，选择**Try Paw**按钮获得30天试用期或点击**Register License**按钮输入自己的License。\n\n因此我们的目的以及非常明确了——**<font color = red>关闭这个Welcome页面</font>**\n\n###初探Paw\n\n既然要破解这个App，免不了要去了解这个App的结构。现在我们手上只有在Applications文件夹下的Paw.app这一个文件。突破口在于**Paw.app/Contents/MacOs/Paw**这个可执行的二进制文件。我们以后的操作，绝大多数时候是与它打交道。在“**应用程序**”文件夹下，右键Paw，选择“**显示包内容**”就可以看到这个二进制文件了\n\n这时候，第一个工具——<font color = \"rgb(226,238,250)\">`class-dump`</font>出场了。由于篇幅所限，我就不介绍这个工具的具体配置方法了。可以参考这篇文章\n\n>\t[<font color = red>使用class-dump导出其他应用头文件</font>](http://www.jianshu.com/p/6a6ce18f998e)\n\n我们先用<font color = \"rgb(226,238,250)\">`class-dump`</font>导出Paw的头文件看看，在终端中执行命令：\n\n<font color = \"rgb(226,238,250)\">`class-dump -H /Applications/PawReal.app/Contents/MacOS/Paw -o /Users/你的用户名/Desktop/classdump`</font>,\n\n换上你的用户名，等运行结束之后，在桌面上可以看到一个叫<font color = \"rgb(226,238,250)\">`classdump`</font>的文件夹。不要被里面密密麻麻的文件吓到，这就是这个app所有的头文件了。\n\n###换位思考，变通思路\n\n接下来怎么找我们需要的信息呢，要想一个一个看过去，即使头文件里面只有方法和变量的定义，也是不现实的。好在<font color = \"rgb(226,238,250)\">`class-dump`</font>还有别的功能。执行命令：\n\n<font color = \"rgb(226,238,250)\">`class-dump -f license /Applications/PawReal.app/Contents/MacOS/Paw`</font>\n\n可以找到头文件中所有和license有关的部分。\n\n会什么要找license呢，这个就需要猜了。既然这个软件需要注册码，并且Welcome界面有一个**Register License**按钮，一定会有一部分代码是用来管理证书（License）相关的。让我们站在开发者的角度上想，如果要遵守命名规范，那么头文件中也许会有**License**关键字的身影。\n\n当然，这只是猜想，如果针对**License**关键字的查找结果不理想的话，我们还可以换一些关键字，比如**Register**、**Validate**等。\n\n不过好在我们通过<font color = \"rgb(226,238,250)\">`class-dump`</font>发现了一些线索，如图所示：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/class-dump-license.png)\n\n在图中，我们发现了一个比较有价值的类:<font color = \"rgb(226,238,250)\">`LMWelcomeViewController`</font>\n\n###合理猜想，趁胜追击\n\n发现<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>这个用来管理Welcome页面的类之后，我们打开头文件看看里面的函数。很“巧”地，里面有一组函数，都是以<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>开头。直觉告诉我们，这个用来显示Welcome页面的方法，很有可能就是解决问题的关键。\n\n故技重施，再看一看<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>这个函数的信息。运行：\n\n<font color = \"rgb(226,238,250)\">`class-dump -f showWelcome /Applications/PawCrack.app/Contents/MacOS/Paw`</font>\n\n可以看到这样的结果：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/class-dump-showWelcome.png)\n\n这就基本上印证了之前的猜想:<font color = \"rgb(226,238,250)\">`LMApplicationDelegate.m`</font>中的代码在程序启动时执行，通过某种方式判断用户是否已注册，**如果没有的话**，就调用<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>这个函数，同时把<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>类的实例对象作为参数，这个对象再执行自己的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法，**展示Welcome页面**\n\n当然，这样的分析很可能是错的。因为判断是否注册这个逻辑并不一定在<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>中进行，也可以放在<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>里。但无论如何，注意到黑体字部分连起来也是一段话，整个过程其实是一个**“如果……，就……”**的逻辑。\n\n记住这个逻辑，一会儿我们会根据这个逻辑做一些修改！\n\n###细看函数实现\n\n我们已经知道<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法可能是解决问题的关键，接下来我们就来看看这个方法到底是怎么实现的。\n\n打开Hopper Disassembler，把**MacOS**文件夹下的**Paw**二进制文件拖入其中，开始分析。Hopper Disassembler可以根据二进制文件反汇编成汇编代码。刚打开的时候，这个软件是这个样子：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/Hopper-Disassembler-introduction.png)\n\n在这个软件中看到的东西往往非常奇葩，和任何一种高级编程语言都不同。这种汇编语言给新手的阅读造成了极大的障碍，好在有一些注释，也可以生成伪代码，辅助我们阅读。我几乎不太能看懂汇编语言，所以尽量避免过多的研究他们。\n\n在左边的Labels标签下搜索我们感兴趣的内容，比如刚刚说的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法。\n\n可以分别看到在<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>和<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>中<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法的实现：\n\n![<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>](https://raw.githubusercontent.com/649395594/AppCrack/master/search-1.png)\n\n![<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>](https://raw.githubusercontent.com/649395594/AppCrack/master/search-2.png)\n\n<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>中的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法非常简单，根据绿色部分的注释可以猜到调用了参数的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法。或者我们可以选中这段汇编代码，点右上角的![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo-icon.png)图标生成伪代码。\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo1.png)\n\n<font color = \"rgb(226,238,250)\">`LMWelcomeViewController `</font>中的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法比较复杂。\n\n之前的图片上可以看到两个汇编指令分别是：<font color = \"rgb(226,238,250)\">`je `</font>和<font color = \"rgb(226,238,250)\">`ret `</font>\n\n<font color = \"rgb(226,238,250)\">`je`</font>是**\"jump euqal\"**的缩写，表示如果相等，则跳转到某个地址。所以我们可以在<font color = \"rgb(226,238,250)\">`je `</font>的上面一行看到<font color = \"rgb(226,238,250)\">`cmp `</font>指令。与<font color = \"rgb(226,238,250)\">`je `</font>相对应的就是<font color = \"rgb(226,238,250)\">`jne `</font>，表示**\"jump not euqal\"**\n\n<font color = \"rgb(226,238,250)\">`ret`</font>顾名思义就是**return的缩写了**，表示函数在这里返回。\n\n其实在这里我们已经可以大概了解这个</font>中的<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法的实现了。进行了一个判断，如果城里就返回，否则就进行下面一段操作，而根据右侧绿色提示，我们看到了**“可怕”**的<font color =\"rgb(226,238,250)\">`showWindow`</font>方法，这个方法没有在头文件里面看到，估计就是一个 私有方法了。\n\n如果不放心的话还可以生成伪代码看看：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo2.png)\n\n###巧变逻辑\n\n之前分析了整个Welcome页面出现的逻辑其实是一个**“如果……，就……”**的判断，那么要想破解，也很容易。方法有两个，要么判断条件不成立，要么改变执行语句。显然，对于不熟悉汇编和逆向工程的新手而言，让判断条件不容易更加简单一些。注意到<font color = \"rgb(226,238,250)\">`je`</font>指令之前有一个数字：**00000001000cdfaf**，它表示的是这条指令在虚拟内存空间中的地址。那么这个地址有什么用呢？\n\n###梳理思路\n\n确实乍一看，获取指令的地址并没有用处。而且从开始到现在，一直在接触完全没接触过的东西，已经有点晕乎了。\n\n梳理一下到目前为止的思路，我们从**license**关键字树藤摸瓜，找到了<font color =\"rgb(226,238,250)\">`showWelcomeWindow`</font>方法。分析出其中的关键一步是<font color = \"rgb(226,238,250)\">`je`</font>指令，最后还知道了这条指令在虚拟内存中的地址。\n\n其实我们的目的非常简单，就是把<font color = \"rgb(226,238,250)\">`je`</font>指令换成<font color = \"rgb(226,238,250)\">`jne`</font>指令。到目前为止，只剩三步。\n\n1. 算出<font color = \"rgb(226,238,250)\">`je`</font>指令的二进制码。\n2. 算出<font color = \"rgb(226,238,250)\">`jne`</font>指令的二进制码。\n3. 在二进制文件中，把算出<font color = \"rgb(226,238,250)\">`je`</font>指令的二进制码换成算出<font color = \"rgb(226,238,250)\">`jne`</font>指令的二进制码。\n\n幸好，gdb调试器能够为我们做前两步。免去了我们完全不熟悉的从汇编到二进制码转换的过程。gdb调试器有一个<font color = \"rgb(226,238,250)\">`x/x`</font>命令，可以读取给定内存地址中的数据。\n\n我们知道，程序运行的过程，简单来说其实就是二进制码从硬盘加载进内存，然后从程序入口开始运行的过程。我们不是汇编器，不善于做静态的、从汇编码到二进制码的转换工作。但是gdb调试器允许我们动态地、逆向的从内存中找到二进制码。\n\n所以，距离成功还差最后一步！\n\n###二进制文件\n\n所以，执行：\n\n<font color = \"rgb(226,238,250)\">`x/x 0x00000001000cdfaf`</font>\n\n可以得到如下的结果：\n\n<font color = \"rgb(226,238,250)\">`0x1000cdfaf <_mh_execute_header+843695>:\t0x83480774`</font>\n\n这里的**0x83480774**就是16进制格式的程序二进制码。接下来就可以打开**Hex friend**软件对二进制码进行修改了。**Hex friend**把应用程序以16进制的形式展现出了，支持查找、替换功能。\n\n按下<font color = \"rgb(226,238,250)\">`Command + F`</font>进行查找。\n\n特别需要注意点是**字节序问题（Byte Order）**，Intel处理器一般是以**小端（Little endian）**进行存储，而在硬盘上的二进制码，则是以**大端（Big endian）**存储。所谓的**大端**，就是把数字的最高位放在最前面，**小端**则是把最高位放在最后面。\n\n也就是说**0x83480774**作为一个**小端**数，它的**大端**形式应该是**74074883**,点击**Replace & Find**按钮之后，很不幸的事情出现了：这个数字不止出现了一次。\n\n解决方案很简单，用同样的方法，看看下一条指令的的二进制码就可以了。执行：\n\n<font color = \"rgb(226,238,250)\">`0x1000cdfb1 <_mh_execute_header+843695>:\t0x83480774`</font>\n\n得到：\n\n<font color = \"rgb(226,238,250)\">`0x1000cdfaf <_mh_execute_header+843695>:\t0x08c48348`</font>\n\n用大端表示就是**4883c408**，这个数字的前四位和之前的数字的后四位刚好是相同的。这个不是巧合，因为不同的指令，二进制码长度不同。而gdb的<font color = \"rgb(226,238,250)\">`x/x`</font>指令总是读取相同长度的内存中的数据。\n\n这一点并不影响破解Paw，但是如果想了解的非常透彻的话，可以用<font color = \"rgb(226,238,250)\">`otx`</font>命令查看：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/otx.png)\n\n可以看到其实<font color = \"rgb(226,238,250)\">`eq`</font>指令的实际二进制码是**7407**。\n\n现在终于确定了要被替换的数字式**74074883c408**，这里面包含了<font color = \"rgb(226,238,250)\">`eq`</font>指令的二进制码和接下来一些指令的二进制码。这些多余信息是为了唯一确定这组数的位置的。\n\n**“7407”**由**“74”**和**“07”**两部分组成，查阅相关资料或者多找几个其他的<font color = \"rgb(226,238,250)\">`eq`</font>指令和<font color = \"rgb(226,238,250)\">`enq`</font>指令可以知道，<font color = \"rgb(226,238,250)\">`eq`</font>指令的二进制码是**“74”**而<font color = \"rgb(226,238,250)\">`eq`</font>指令的二进制码是**“75”**。\n\n所以用来替换的数应该就是**“75074883c408”**。在**Hex friend**中填写好相关数据后选择**Replace**并保存。如图所示：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/AppCrack/replace.png)\n\n\n至此，整个破解的过程就完成了。其实细想一下，我们只是**把一个4换成了5**而已！\n\n###文件签名\n\n用修改过后的二进制文件替换原来文件后，打开程序总是会立刻报错。如果在命令行中运行，还可以看到**killed 9**的提示。\n\n这是因为苹果为了保证软件的安全加入了**<font color=red>代码签名（CodeSignature）</font>**机制。在**Contents**文件夹下可以找到**_CodeSignature**文件夹和其中的**CodeResources**文件。任何对二进制文件的修改，都无法通过代码签名的检查。\n\n关于代码签名的具体解释，和操作过程，可以看这篇文章：\n> [《How to re-sign Apple's applications once they've been modified》](http://forums.macnn.com/79/developer-center/355720/how-re-sign-apples-applications-once/)\n\n文章把每一步都描述得非常透彻，我就不重述了。按照文章所描述的，建立好自己的签名证书后，只要执行这条命令：\n\n\n<font color = \"rgb(226,238,250)\">`codesign -f -s 证书名 /Applications/PawCrack.app/Contents/MacOS/Paw`</font>\n\n其中证书名写自己创建的证书的名字，一切顺利的话，会得到这样的提示：\n<font color = \"rgb(226,238,250)\">`/Applications/PawCrack.app/Contents/MacOS/Paw: replacing existing signature`</font>\n\n代码重签名完成之后，就可以成功打开破解之后的App了。\n\n###尾巴\n\n打开App之后我们可以发现，**烦人**的Welcome页不见了。因为反转了判断逻辑，所以不执行<font color = \"rgb(226,238,250)\">`showWelcomeWindow`</font>方法了。\n\n不过可惜的是，发送HTTP请求的按钮依然点击无效。应该是还有判断机制。只要按照之前的步骤再来一次就可以了。\n\n#总结\n\n首先回顾一下整个破解过程。准备好工具之后，我们先从头文件里面搜索可以的方法名，再用反编译工具查看具体方法的汇编代码实现。结合基本的汇编语法和伪代码，了解整个方法的工作原理。最后修改if语句的逻辑从而完成破解。\n\n其实由于大部分针对功能的限制，都是基于<font color = \"rgb(226,238,250)\">`if else`</font>语句进行判断的，也就是说对于相当多的软件，只要我们分析出它的逻辑，只需要把一个4改成5即可破解。\n\n整个破解过程，除了巩固了操作系统的基础知识之外，我觉得对于iOS engineer来说还有一些其他的收获：\n\n1. 严格遵守**“迪米特法则”**，把不必要对外提供的在.m文件里定义、实现。这样不仅防止被class-dump扫描到，也能减轻与你合作的同事开发时的负担。\n2. 发布版本gcc编译时去掉<font color = \"rgb(226,238,250)\">`-g`</font>参数。我猜测，正是由于Paw这么做了，导致我无法用gdb调试器加断点。因为找不到函数的符号名。\n3. 对于极为核心的部分，可以做适当的代码混淆。\n\n做到以上几点非常轻松，但是足以防止数量广大，但又技术一般的tinkerer(比如作者本人)的捣鼓了。\n\n##参考资料\n1.\t[《Giving gdb permission to control other processes》](http://www.cnblogs.com/yishuiliunian/archive/2013/01/13/2858836.html)\n2.\t[《I Can Crack Your App With Just A Shell》](http://kswizz.com/2011-01-16/hacking-mac-apps/)\n3.\t[《How to re-sign Apple's applications once they've been modified》](http://forums.macnn.com/79/developer-center/355720/how-re-sign-apples-applications-once/)\n4.\t[Beginning Mac Hacking](http://www.mrspeaker.net/2011/01/06/mac-hacking/)","html":"<p>在某位大神的博客里看到了Mac一款非常好用的App，叫<font color=red>Paw</font>。</p>\n\n<p>Paw可以在Mac上模拟各种HTTP请求，可视化的管理HTTP Header、Parameters、Cookies等，还有一点非常出乎意料的功能是通过下载插件可以自动生成Swfit、OC、JS等多种语言的代码。</p>\n\n<p>然而Paw巨贵（200软妹币），而且破解版不好搜。于是寻思着自己动手解决需求，于是可怜的Paw成了实验对象。<a href=\"https://luckymarmot.com/paw\">先从这里下载原版app</a>,一会儿教程中会逐步分析如何破解这个软件。</p>\n\n<p>由于在此之前我毫无逆向工程方面的经验，在看别人的介绍时各种不懂，深受折磨，所以我尽量用简单、详细的语言描述本次从零开始破解app之旅。作为参考，我用了<strong>大约七个小时</strong>的时间完成了此次破解（大量的时间浪费在找工具以及学习使用工具上，后面可以看到破解这个事情本身并不难）。在文章的最后会给出最新版Paw（2.2.6）的原版和破解版下载。</p>\n\n<p>由于水平有限，只是介绍了基本的逆向工程知识，算是自己的学习笔记，也希望向更多的和我一样还只是菜鸟的程序员科普一些逆向工程的基本知识，同时督促自己平时在Coding过程中的注意代码规范和安全。</p>\n\n<h1 id=\"\">知识储备</h1>\n\n<p>想要破解app，首先自己得开发过app，至少了解一些基本的命令行操作，源代码、汇编代码和二进制码的基本定义。如果这些基本要求有某一点不满足，那么整个过程会是非常痛苦的。</p>\n\n<h1 id=\"\">工具准备</h1>\n\n<p>破解Paw用到的工具主要有以下几个。</p>\n\n<ul>\n<li><font color=red>homebrew</font> —— 不知道这个的估计都不好意思说自己是用Mac的程序员。</li>\n<li><a href=\"http://pan.baidu.com/s/1bn94SDx\"><font color=red>Hopper Disassembler</font></a> —— 反编译工具，根据可执行文件反编译出汇编码。</li>\n<li><a href=\"http://stevenygard.com/projects/class-dump/\"><font color=red>Class-dump</font></a> —— 逆向工程的入门级工具，导出一个App的某些信息。</li>\n<li><font color = red>otx</font> —— 国外某位大神的博客上用的一个工具，我也说不出明确的用处。通过<code>brew install --HEAD homebrew/head-only/otx</code>命令安装。</li>\n<li><a href=\"http://ridiculousfish.com/hexfiend/\"><font color=red>Hex friend</font></a> —— 二进制文件编辑器，要用这个修改原来的二进制文件。</li>\n<li><font color=red>gdb</font> —— 著名的调试器，用lldb也行。通过<code>brew install gdb</code>命令安装。</li>\n</ul>\n\n<h1 id=\"begincracking\">Begin cracking</h1>\n\n<h3 id=\"\">找到破解点</h3>\n\n<p>要破解App当然要明白自己为什么要破解它，它哪一点限制了我们，首先运行原版的Paw。可以看到如下界面:</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/real-paw-welcome.png\" alt=\"\" /></p>\n\n<p>这个Welcome界面非常讨厌，由于它的存在，我们不能点击程序主界面。而想要关掉这个Welcome界面，只有两个方法，选择<strong>Try Paw</strong>按钮获得30天试用期或点击<strong>Register License</strong>按钮输入自己的License。</p>\n\n<p>因此我们的目的以及非常明确了——<strong><font color = red>关闭这个Welcome页面</font></strong></p>\n\n<h3 id=\"paw\">初探Paw</h3>\n\n<p>既然要破解这个App，免不了要去了解这个App的结构。现在我们手上只有在Applications文件夹下的Paw.app这一个文件。突破口在于<strong>Paw.app/Contents/MacOs/Paw</strong>这个可执行的二进制文件。我们以后的操作，绝大多数时候是与它打交道。在“<strong>应用程序</strong>”文件夹下，右键Paw，选择“<strong>显示包内容</strong>”就可以看到这个二进制文件了</p>\n\n<p>这时候，第一个工具——<font color = \"rgb(226,238,250)\"><code>class-dump</code></font>出场了。由于篇幅所限，我就不介绍这个工具的具体配置方法了。可以参考这篇文章</p>\n\n<blockquote>\n  <p><a href=\"http://www.jianshu.com/p/6a6ce18f998e\"><font color = red>使用class-dump导出其他应用头文件</font></a></p>\n</blockquote>\n\n<p>我们先用<font color = \"rgb(226,238,250)\"><code>class-dump</code></font>导出Paw的头文件看看，在终端中执行命令：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>class-dump -H /Applications/PawReal.app/Contents/MacOS/Paw -o /Users/你的用户名/Desktop/classdump</code></font>,</p>\n\n<p>换上你的用户名，等运行结束之后，在桌面上可以看到一个叫<font color = \"rgb(226,238,250)\"><code>classdump</code></font>的文件夹。不要被里面密密麻麻的文件吓到，这就是这个app所有的头文件了。</p>\n\n<h3 id=\"\">换位思考，变通思路</h3>\n\n<p>接下来怎么找我们需要的信息呢，要想一个一个看过去，即使头文件里面只有方法和变量的定义，也是不现实的。好在<font color = \"rgb(226,238,250)\"><code>class-dump</code></font>还有别的功能。执行命令：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>class-dump -f license /Applications/PawReal.app/Contents/MacOS/Paw</code></font></p>\n\n<p>可以找到头文件中所有和license有关的部分。</p>\n\n<p>会什么要找license呢，这个就需要猜了。既然这个软件需要注册码，并且Welcome界面有一个<strong>Register License</strong>按钮，一定会有一部分代码是用来管理证书（License）相关的。让我们站在开发者的角度上想，如果要遵守命名规范，那么头文件中也许会有<strong>License</strong>关键字的身影。</p>\n\n<p>当然，这只是猜想，如果针对<strong>License</strong>关键字的查找结果不理想的话，我们还可以换一些关键字，比如<strong>Register</strong>、<strong>Validate</strong>等。</p>\n\n<p>不过好在我们通过<font color = \"rgb(226,238,250)\"><code>class-dump</code></font>发现了一些线索，如图所示：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/class-dump-license.png\" alt=\"\" /></p>\n\n<p>在图中，我们发现了一个比较有价值的类:<font color = \"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font></p>\n\n<h3 id=\"\">合理猜想，趁胜追击</h3>\n\n<p>发现<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>这个用来管理Welcome页面的类之后，我们打开头文件看看里面的函数。很“巧”地，里面有一组函数，都是以<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>开头。直觉告诉我们，这个用来显示Welcome页面的方法，很有可能就是解决问题的关键。</p>\n\n<p>故技重施，再看一看<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>这个函数的信息。运行：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>class-dump -f showWelcome /Applications/PawCrack.app/Contents/MacOS/Paw</code></font></p>\n\n<p>可以看到这样的结果：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/class-dump-showWelcome.png\" alt=\"\" /></p>\n\n<p>这就基本上印证了之前的猜想:<font color = \"rgb(226,238,250)\"><code>LMApplicationDelegate.m</code></font>中的代码在程序启动时执行，通过某种方式判断用户是否已注册，<strong>如果没有的话</strong>，就调用<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>这个函数，同时把<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>类的实例对象作为参数，这个对象再执行自己的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法，<strong>展示Welcome页面</strong></p>\n\n<p>当然，这样的分析很可能是错的。因为判断是否注册这个逻辑并不一定在<font color = \"rgb(226,238,250)\"><code>LMApplicationDelegate</code></font>中进行，也可以放在<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>里。但无论如何，注意到黑体字部分连起来也是一段话，整个过程其实是一个<strong>“如果……，就……”</strong>的逻辑。</p>\n\n<p>记住这个逻辑，一会儿我们会根据这个逻辑做一些修改！</p>\n\n<h3 id=\"\">细看函数实现</h3>\n\n<p>我们已经知道<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法可能是解决问题的关键，接下来我们就来看看这个方法到底是怎么实现的。</p>\n\n<p>打开Hopper Disassembler，把<strong>MacOS</strong>文件夹下的<strong>Paw</strong>二进制文件拖入其中，开始分析。Hopper Disassembler可以根据二进制文件反汇编成汇编代码。刚打开的时候，这个软件是这个样子：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/Hopper-Disassembler-introduction.png\" alt=\"\" /></p>\n\n<p>在这个软件中看到的东西往往非常奇葩，和任何一种高级编程语言都不同。这种汇编语言给新手的阅读造成了极大的障碍，好在有一些注释，也可以生成伪代码，辅助我们阅读。我几乎不太能看懂汇编语言，所以尽量避免过多的研究他们。</p>\n\n<p>在左边的Labels标签下搜索我们感兴趣的内容，比如刚刚说的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法。</p>\n\n<p>可以分别看到在<font color =\"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>和<font color = \"rgb(226,238,250)\"><code>LMApplicationDelegate</code></font>中<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法的实现：</p>\n\n<p><img src=\"https://raw.githubusercontent.com/649395594/AppCrack/master/search-1.png\" alt=\"<font color = \"rgb(226,238,250)\">`LMApplicationDelegate`</font>\" /></p>\n\n<p><img src=\"https://raw.githubusercontent.com/649395594/AppCrack/master/search-2.png\" alt=\"<font color =\"rgb(226,238,250)\">`LMWelcomeViewController`</font>\" /></p>\n\n<p><font color = \"rgb(226,238,250)\"><code>LMApplicationDelegate</code></font>中的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法非常简单，根据绿色部分的注释可以猜到调用了参数的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法。或者我们可以选中这段汇编代码，点右上角的<img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo-icon.png\" alt=\"\" title=\"\" />图标生成伪代码。</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo1.png\" alt=\"\" /></p>\n\n<p><font color = \"rgb(226,238,250)\"><code>LMWelcomeViewController</code></font>中的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法比较复杂。</p>\n\n<p>之前的图片上可以看到两个汇编指令分别是：<font color = \"rgb(226,238,250)\"><code>je</code></font>和<font color = \"rgb(226,238,250)\"><code>ret</code></font></p>\n\n<p><font color = \"rgb(226,238,250)\"><code>je</code></font>是<strong>\"jump euqal\"</strong>的缩写，表示如果相等，则跳转到某个地址。所以我们可以在<font color = \"rgb(226,238,250)\"><code>je</code></font>的上面一行看到<font color = \"rgb(226,238,250)\"><code>cmp</code></font>指令。与<font color = \"rgb(226,238,250)\"><code>je</code></font>相对应的就是<font color = \"rgb(226,238,250)\"><code>jne</code></font>，表示<strong>\"jump not euqal\"</strong></p>\n\n<p><font color = \"rgb(226,238,250)\"><code>ret</code></font>顾名思义就是<strong>return的缩写了</strong>，表示函数在这里返回。</p>\n\n<p>其实在这里我们已经可以大概了解这个</font>中的<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法的实现了。进行了一个判断，如果城里就返回，否则就进行下面一段操作，而根据右侧绿色提示，我们看到了<strong>“可怕”</strong>的<font color =\"rgb(226,238,250)\"><code>showWindow</code></font>方法，这个方法没有在头文件里面看到，估计就是一个 私有方法了。</p>\n\n<p>如果不放心的话还可以生成伪代码看看：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/pseudo2.png\" alt=\"\" /></p>\n\n<h3 id=\"\">巧变逻辑</h3>\n\n<p>之前分析了整个Welcome页面出现的逻辑其实是一个<strong>“如果……，就……”</strong>的判断，那么要想破解，也很容易。方法有两个，要么判断条件不成立，要么改变执行语句。显然，对于不熟悉汇编和逆向工程的新手而言，让判断条件不容易更加简单一些。注意到<font color = \"rgb(226,238,250)\"><code>je</code></font>指令之前有一个数字：<strong>00000001000cdfaf</strong>，它表示的是这条指令在虚拟内存空间中的地址。那么这个地址有什么用呢？</p>\n\n<h3 id=\"\">梳理思路</h3>\n\n<p>确实乍一看，获取指令的地址并没有用处。而且从开始到现在，一直在接触完全没接触过的东西，已经有点晕乎了。</p>\n\n<p>梳理一下到目前为止的思路，我们从<strong>license</strong>关键字树藤摸瓜，找到了<font color =\"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法。分析出其中的关键一步是<font color = \"rgb(226,238,250)\"><code>je</code></font>指令，最后还知道了这条指令在虚拟内存中的地址。</p>\n\n<p>其实我们的目的非常简单，就是把<font color = \"rgb(226,238,250)\"><code>je</code></font>指令换成<font color = \"rgb(226,238,250)\"><code>jne</code></font>指令。到目前为止，只剩三步。</p>\n\n<ol>\n<li>算出<font color = \"rgb(226,238,250)\"><code>je</code></font>指令的二进制码。  </li>\n<li>算出<font color = \"rgb(226,238,250)\"><code>jne</code></font>指令的二进制码。  </li>\n<li>在二进制文件中，把算出<font color = \"rgb(226,238,250)\"><code>je</code></font>指令的二进制码换成算出<font color = \"rgb(226,238,250)\"><code>jne</code></font>指令的二进制码。</li>\n</ol>\n\n<p>幸好，gdb调试器能够为我们做前两步。免去了我们完全不熟悉的从汇编到二进制码转换的过程。gdb调试器有一个<font color = \"rgb(226,238,250)\"><code>x/x</code></font>命令，可以读取给定内存地址中的数据。</p>\n\n<p>我们知道，程序运行的过程，简单来说其实就是二进制码从硬盘加载进内存，然后从程序入口开始运行的过程。我们不是汇编器，不善于做静态的、从汇编码到二进制码的转换工作。但是gdb调试器允许我们动态地、逆向的从内存中找到二进制码。</p>\n\n<p>所以，距离成功还差最后一步！</p>\n\n<h3 id=\"\">二进制文件</h3>\n\n<p>所以，执行：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>x/x 0x00000001000cdfaf</code></font></p>\n\n<p>可以得到如下的结果：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>0x1000cdfaf &lt;_mh_execute_header+843695&gt;:    0x83480774</code></font></p>\n\n<p>这里的<strong>0x83480774</strong>就是16进制格式的程序二进制码。接下来就可以打开<strong>Hex friend</strong>软件对二进制码进行修改了。<strong>Hex friend</strong>把应用程序以16进制的形式展现出了，支持查找、替换功能。</p>\n\n<p>按下<font color = \"rgb(226,238,250)\"><code>Command + F</code></font>进行查找。</p>\n\n<p>特别需要注意点是<strong>字节序问题（Byte Order）</strong>，Intel处理器一般是以<strong>小端（Little endian）</strong>进行存储，而在硬盘上的二进制码，则是以<strong>大端（Big endian）</strong>存储。所谓的<strong>大端</strong>，就是把数字的最高位放在最前面，<strong>小端</strong>则是把最高位放在最后面。</p>\n\n<p>也就是说<strong>0x83480774</strong>作为一个<strong>小端</strong>数，它的<strong>大端</strong>形式应该是<strong>74074883</strong>,点击<strong>Replace &amp; Find</strong>按钮之后，很不幸的事情出现了：这个数字不止出现了一次。</p>\n\n<p>解决方案很简单，用同样的方法，看看下一条指令的的二进制码就可以了。执行：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>0x1000cdfb1 &lt;_mh_execute_header+843695&gt;:    0x83480774</code></font></p>\n\n<p>得到：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>0x1000cdfaf &lt;_mh_execute_header+843695&gt;:    0x08c48348</code></font></p>\n\n<p>用大端表示就是<strong>4883c408</strong>，这个数字的前四位和之前的数字的后四位刚好是相同的。这个不是巧合，因为不同的指令，二进制码长度不同。而gdb的<font color = \"rgb(226,238,250)\"><code>x/x</code></font>指令总是读取相同长度的内存中的数据。</p>\n\n<p>这一点并不影响破解Paw，但是如果想了解的非常透彻的话，可以用<font color = \"rgb(226,238,250)\"><code>otx</code></font>命令查看：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/otx.png\" alt=\"\" /></p>\n\n<p>可以看到其实<font color = \"rgb(226,238,250)\"><code>eq</code></font>指令的实际二进制码是<strong>7407</strong>。</p>\n\n<p>现在终于确定了要被替换的数字式<strong>74074883c408</strong>，这里面包含了<font color = \"rgb(226,238,250)\"><code>eq</code></font>指令的二进制码和接下来一些指令的二进制码。这些多余信息是为了唯一确定这组数的位置的。</p>\n\n<p><strong>“7407”</strong>由<strong>“74”</strong>和<strong>“07”</strong>两部分组成，查阅相关资料或者多找几个其他的<font color = \"rgb(226,238,250)\"><code>eq</code></font>指令和<font color = \"rgb(226,238,250)\"><code>enq</code></font>指令可以知道，<font color = \"rgb(226,238,250)\"><code>eq</code></font>指令的二进制码是<strong>“74”</strong>而<font color = \"rgb(226,238,250)\"><code>eq</code></font>指令的二进制码是<strong>“75”</strong>。</p>\n\n<p>所以用来替换的数应该就是<strong>“75074883c408”</strong>。在<strong>Hex friend</strong>中填写好相关数据后选择<strong>Replace</strong>并保存。如图所示：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/AppCrack/replace.png\" alt=\"\" /></p>\n\n<p>至此，整个破解的过程就完成了。其实细想一下，我们只是<strong>把一个4换成了5</strong>而已！</p>\n\n<h3 id=\"\">文件签名</h3>\n\n<p>用修改过后的二进制文件替换原来文件后，打开程序总是会立刻报错。如果在命令行中运行，还可以看到<strong>killed 9</strong>的提示。</p>\n\n<p>这是因为苹果为了保证软件的安全加入了<strong><font color=red>代码签名（CodeSignature）</font></strong>机制。在<strong>Contents</strong>文件夹下可以找到<strong>_CodeSignature</strong>文件夹和其中的<strong>CodeResources</strong>文件。任何对二进制文件的修改，都无法通过代码签名的检查。</p>\n\n<p>关于代码签名的具体解释，和操作过程，可以看这篇文章：</p>\n\n<blockquote>\n  <p><a href=\"http://forums.macnn.com/79/developer-center/355720/how-re-sign-apples-applications-once/\">《How to re-sign Apple's applications once they've been modified》</a></p>\n</blockquote>\n\n<p>文章把每一步都描述得非常透彻，我就不重述了。按照文章所描述的，建立好自己的签名证书后，只要执行这条命令：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>codesign -f -s 证书名 /Applications/PawCrack.app/Contents/MacOS/Paw</code></font></p>\n\n<p>其中证书名写自己创建的证书的名字，一切顺利的话，会得到这样的提示：\n<font color = \"rgb(226,238,250)\"><code>/Applications/PawCrack.app/Contents/MacOS/Paw: replacing existing signature</code></font></p>\n\n<p>代码重签名完成之后，就可以成功打开破解之后的App了。</p>\n\n<h3 id=\"\">尾巴</h3>\n\n<p>打开App之后我们可以发现，<strong>烦人</strong>的Welcome页不见了。因为反转了判断逻辑，所以不执行<font color = \"rgb(226,238,250)\"><code>showWelcomeWindow</code></font>方法了。</p>\n\n<p>不过可惜的是，发送HTTP请求的按钮依然点击无效。应该是还有判断机制。只要按照之前的步骤再来一次就可以了。</p>\n\n<h1 id=\"\">总结</h1>\n\n<p>首先回顾一下整个破解过程。准备好工具之后，我们先从头文件里面搜索可以的方法名，再用反编译工具查看具体方法的汇编代码实现。结合基本的汇编语法和伪代码，了解整个方法的工作原理。最后修改if语句的逻辑从而完成破解。</p>\n\n<p>其实由于大部分针对功能的限制，都是基于<font color = \"rgb(226,238,250)\"><code>if else</code></font>语句进行判断的，也就是说对于相当多的软件，只要我们分析出它的逻辑，只需要把一个4改成5即可破解。</p>\n\n<p>整个破解过程，除了巩固了操作系统的基础知识之外，我觉得对于iOS engineer来说还有一些其他的收获：</p>\n\n<ol>\n<li>严格遵守<strong>“迪米特法则”</strong>，把不必要对外提供的在.m文件里定义、实现。这样不仅防止被class-dump扫描到，也能减轻与你合作的同事开发时的负担。  </li>\n<li>发布版本gcc编译时去掉<font color = \"rgb(226,238,250)\"><code>-g</code></font>参数。我猜测，正是由于Paw这么做了，导致我无法用gdb调试器加断点。因为找不到函数的符号名。  </li>\n<li>对于极为核心的部分，可以做适当的代码混淆。</li>\n</ol>\n\n<p>做到以上几点非常轻松，但是足以防止数量广大，但又技术一般的tinkerer(比如作者本人)的捣鼓了。</p>\n\n<h2 id=\"\">参考资料</h2>\n\n<ol>\n<li><a href=\"http://www.cnblogs.com/yishuiliunian/archive/2013/01/13/2858836.html\">《Giving gdb permission to control other processes》</a>  </li>\n<li><a href=\"http://kswizz.com/2011-01-16/hacking-mac-apps/\">《I Can Crack Your App With Just A Shell》</a>  </li>\n<li><a href=\"http://forums.macnn.com/79/developer-center/355720/how-re-sign-apples-applications-once/\">《How to re-sign Apple's applications once they've been modified》</a>  </li>\n<li><a href=\"http://www.mrspeaker.net/2011/01/06/mac-hacking/\">Beginning Mac Hacking</a></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-11T13:23:58.000Z","created_by":1,"updated_at":"2016-01-11T15:19:19.000Z","updated_by":1,"published_at":"2015-11-24T07:13:00.000Z","published_by":1},{"id":5,"uuid":"99a782b0-98ac-44a9-a328-17b2430e4a67","title":"iOS多线程编程——GCD与NSOperation总结","slug":"multithreadconclusion","markdown":"很长时间以来，我个人（可能还有很多同学），对多线程编程都存在一些误解。一个很明显的表现是，很多人有这样的看法：\n> 新开一个线程，能提高速度，避免阻塞主线程\n\n毕竟多线程嘛，几个线程一起跑任务，速度快，还不阻塞主线程，简直完美。\n\n在某些场合，我们还见过另一个“高深”的名词——“异步”。这东西好像和多线程挺类似，经过一番百度（阅读了很多质量层次不齐的文章）之后，很多人也没能真正搞懂何为“异步”。\n\n于是，带着对“多线程”和“异步”的懵懂，很多人又开开心心踏上了多线程编程之旅，比如文章待会儿会提到的GCD。\n\n## 何为多线程\n\n其实，如果**不考虑其他任何因素和技术**，多线程有百害而无一利，只能浪费时间，降低程序效率。\n\n是的，我很清醒的写下这句话。\n\n试想一下，一个任务由十个子任务组成。现在有两种方式完成这个任务：\n1. 建十个线程，把每个子任务放在对应的线程中执行。执行完一个线程中的任务就切换到另一个线程。\n2. 把十个任务放在一个线程里，按顺序执行。\n\n操作系统的基础知识告诉我们，线程，是执行程序最基本的单元，它有自己栈和寄存器。说得再具体一些，线程就是**“一个CPU执行的一条无分叉的命令列”**。\n\n对于第一种方法，在十个线程之间来回切换，就意味着有十组栈和寄存器中的值需要不断地被备份、替换。\n而对于对于第二种方法，只有一组寄存器和栈存在，显然效率完胜前者。\n\n### 并发与并行\n\n通过刚刚的分析我们看到，多线程本身会带来效率上的损失。准确来说，在处理并发任务时，多线程不仅不能提高效率，反而还会降低程序效率。\n\n所谓的“**并发**”，英文翻译是concurrent。要注意和**“并行（parallelism）”**的区别。\n\n> **并发**指的是一种现象，一种经常出现，无可避免的现象。它描述的是“多个任务同时发生，需要被处理”这一现象。它的侧重点在于“发生”。\n\n比如有很多人排队等待检票，这一现象就可以理解为并发。\n\n> **并行**指的是一种技术，一个同时处理多个任务的技术。它描述了一种能够同时处理多个任务的能力，侧重点在于“运行”。\n\n比如景点开放了多个检票窗口，同一时间内能服务多个游客。这种情况可以理解为并行。\n\n并行的反义词就是串行，表示任务必须按顺序来，一个一个执行，前一个执行完了才能执行后一个。\n\n我们经常挂在嘴边的“多线程”，正是采用了并行技术，从而提高了执行效率。因为有多个线程，所以计算机的多个CPU可以同时工作，同时处理不同线程内的指令。\n\n并发是一种现象，面对这一现象，我们首先创建多个线程，真正加快程序运行速度的，是并行技术。也就是让多个CPU同时工作。而多线程，是为了让多个CPU同时工作成为可能。\n\n### 同步与异步\n同步方法就是我们平时调用的哪些方法。因为任何有编程经验的人都知道，比如在第一行调用<font color = \"rgb(226,238,250)\">`foo()`</font>方法，那么程序运行到第二行的时候，foo方法肯定是执行完了。\n\n所谓的异步，就是允许在执行某一个任务时，函数立刻返回，但是真正要执行的任务稍后完成。\n\n比如我们在点击保存按钮之后，要先把数据写到磁盘，然后更新UI。同步方法就是等到数据保存完再更新UI，而异步则是立刻从保存数据的方法返回并向后执行代码，同时真正用来保存数据的指令将在稍后执行。\n\n### 区别和联系\n\n假设现在有三个任务需要处理。假设单个CPU处理它们分别需要3、1、1秒。\n\n并行与串行，其实讨论的是处理这三个任务的速度问题。如果三个CPU并行处理，那么一共只需要3秒。相比于串行处理，节约了两秒。\n\n而同步/异步，其实描述的是任务之间先后顺序问题。假设需要三秒的那个是保存数据的任务，而另外两个是UI相关的任务。那么通过异步执行第一个任务，我们省去了三秒钟的卡顿时间。\n\n对于同步执行的三个任务来说，系统**倾向于**在同一个线程里执行它们。因为即使开了三个线程，也得等他们分别在各自的线程中完成。并不能减少总的处理时间，反而徒增了线程切换（这就是文章开头举的例子）\n\n对于异步执行的三个任务来说，系统**倾向于**在三个新的线程里执行他们。因为这样可以最大程度的利用CPU性能，提升程序运行效率。\n\n### 总结\n\n于是我们可以得出结论，在需要同时处理IO和UI的情况下，真正起作用的是异步，而不是多线程。可以不用多线程（因为处理UI非常快），但不能不用异步（否则的话至少要等IO结束）。\n\n注意到我把“倾向于”这三个加粗了，也就是说异步方法并不一定永远在新线程里面执行，反之亦然。在接下来关于GCD的部分会对此做出解释。\n\n## GCD简介\n\nGCD以block为基本单位，一个block中的代码可以为一个任务。下文中提到任务，可以理解为执行某个block\n\n同时，GCD中有两大最重要的概念，分别是“队列”和“执行方式”。\n\n使用block的过程，概括来说就是把block放进合适的队列，并选择合适的执行方式去执行block的过程。\n\n#### 三种队列：\n\n2. 串行队列（队列中的任务并行处理）\n3. 并行队列（队列中的任务并行处理）\n4. 主队列（这是一个特殊的串行队列，而且队列中的任务一定会在主线程中执行）\n\n#### 两种执行方式：\n\n1. 同步执行\n2. 异步执行\n\n关于同步异步、串行并行和线程的关系，下面通过一个表格来总结\n\n![](http://7xonij.com1.z0.glb.clouddn.com/Tables/ralationship.jpg)\n\n可以看到，同步方法不一定在本线程，异步方法方法也不一定新开线程（考虑主队列）。\n\n然而事实上，在本文一开始就揭开了“多线程”的神秘面纱，所以我们在编程时，更应该考虑的是：\n\n> 同步 Or 异步\n\n以及\n\n> 串行 Or 并行\n\n而非仅仅考虑是否新开线程。\n\n当然，了解任务运行在那个线程中也是为了更加深入的理解整个程序的运行情况，尤其是接下来要讨论的死锁问题。\n\n### GCD的死锁问题\n\n在使用GCD的过程中，如果**同步地添加一个将要在当前线程执行的任务**，就会导致死锁。\n\n这句话有点绕，我们首先举个例子看看：\n\n```swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    let mainQueue = dispatch_get_main_queue()\n    let block = { ()  in\n    \tprint(NSThread.currentThread())\n\t}    \n\tdispatch_sync(mainQueue, block)\n}\n\n```\n\n这段代码就会导致死锁，因为我们将要同步地添加一个<font color = \"rgb(226,238,250)\">`block `</font>，<font color = \"rgb(226,238,250)\">`block `</font>被添加到主队列中。\n\n根据之前的表格，同步的往主队列中添加任务，任务会在主线程执行。而当前这段代码也在主线程中执行，所以导致死锁。\n\n### 理论分析\n\n我们知道<font color = \"rgb(226,238,250)\">`dispatch_sync `</font>表示同步的执行任务，也就是说执行<font color = \"rgb(226,238,250)\">`dispatch_sync `</font>后，当前线程会阻塞。而<font color = \"rgb(226,238,250)\">`dispatch_sync `</font>中的block如果要在当前线程中执行，就得等待当前线程执行完成（也就是不再阻塞）。\n\n很不幸的是，当前线程在<font color = \"rgb(226,238,250)\">`dispatch_sync `</font>的block执行完之前都是阻塞的，于是导致了死锁。\n\n### 解决方案\n\n其实在通常情况下我们不必要用<font color = \"rgb(226,238,250)\">`dispatch_sync `</font>，因为<font color = \"rgb(226,238,250)\">`dispatch_async `</font>能够更好的利用CPU，提升程序运行速度。\n\n只有当我们需要保证队列中的任务必须顺序执行时，才考虑使用<font color = \"rgb(226,238,250)\">`dispatch_sync `</font>。对于每一个串行队列，它有与之唯一对应的线程。所以在使用<font color = \"rgb(226,238,250)\">`dispatch_sync `</font>的时候应该分析当前属于哪个线程，以及队列中的任务会在哪个线程执行。\n\n### GCD任务组\n\n了解完队列之后，很自然的会有一个想法：我们怎么知道所有任务都已经执行完了呢？\n\n在单个串行队列中，这个不是问题，因为只要把回调block添加到队列末尾即可。\n\n但是对于并行队列，以及多个串行、并行队列混合的情况，就需要使用<font color = \"rgb(226,238,250)\">`dispatch_group `</font>了。\n\n``` swift\nlet group = dispatch_group_create()\n\ndispatch_group_async(group, serialQueue, { () -> Void in\n\tfor _ in 0..<2 {\n\t\tprint(\"group-serial \\(NSThread.currentThread())\")\n\t}\n})\n        \ndispatch_group_async(group, serialQueue, { () -> Void in\n\tfor _ in 0..<3 {\n\t\tNSLog(\"group-02 - %@\", NSThread.currentThread())\n\t}\n})\n        \ndispatch_group_notify(group, serialQueue, { () -> Void in\n\tprint(\"完成 - \\(NSThread.currentThread())\")\n})\n```\n\n首先我们要通过<font color = \"rgb(226,238,250)\">`dispatch_group_create() `</font>方法生成一个组。\n\n接下来，我们把<font color = \"rgb(226,238,250)\">`dispatch_async `</font>方法换成<font color = \"rgb(226,238,250)\">`dispatch_group_async `</font>。这个方法多了一个参数，第一个参数填刚刚创建的分组。\n\n想问<font color = \"rgb(226,238,250)\">`dispatch_sync `</font>对应的分组方法是什么的童鞋面壁思过三秒钟，思考一下group出现的目的和<font color = \"rgb(226,238,250)\">`dispatch_sync `</font>的特点。\n\n最后调用<font color = \"rgb(226,238,250)\">`dispatch_group_create `</font>方法。这个方法表示把第三个参数block传入第二个参数队列中去。而且可以保证第三个参数block执行时，group中的所有任务已经全部完成。\n\n### dispatch\\_group\n\n<font color = \"rgb(226,238,250)\">`dispatch_group_wait `</font>方法是一个很有用的方法，它的完整定义如下：\n\n<font color = \"rgb(226,238,250)\">`dispatch_group_wait(group: dispatch_group_t, _ timeout: dispatch_time_t) -> Int `</font>\n\n第一个参数表示要等待的group，第二个则表示等待时间。返回值表示经过指定的等待时间，属于这个group的任务是否已经全部执行完，如果是则返回0，否则返回非0。\n\n第二个<font color = \"rgb(226,238,250)\">`dispatch_time_t `</font>类型的参数还有两个特殊值：<font color = \"rgb(226,238,250)\">`DISPATCH_TIME_NOW `</font>和<font color = \"rgb(226,238,250)\">`DISPATCH_TIME_FOREVER `</font>。\n\n前者表示立刻检查属于这个group的任务是否已经完成，后者则表示一直等到属于这个group的任务全部完成。\n\n### dispatch\\_after方法\n\n通过GCD还可以进行简单的定时操作，比如在1秒后执行某个block。代码如下：\n\n``` swift\nlet mainQueue = dispatch_get_main_queue()\nlet time = dispatch_time(DISPATCH_TIME_NOW, Int64(3) * Int64(NSEC_PER_SEC))\nNSLog(\"%@\",NSThread.currentThread())\ndispatch_after(time, mainQueue, {() in NSLog(\"%@\",NSThread.currentThread())})\n```\n\n</font>和<font color = \"rgb(226,238,250)\">`dispatch_after `</font>方法有三个参数。第一个表示时间，也就是从现在起往后三秒钟。第二三个参数分别表示要提交的任务和提交到哪个队列。\n\n需要注意的是</font>和<font color = \"rgb(226,238,250)\">`dispatch_after `</font>仅表示在指定时间后提交任务，而非执行任务。如果任务提交到主队列，它将在main runloop中执行，对于每隔1/60秒执行一次的RunLoop，任务最多有可能在3+1/60秒后执行。\n\n## NSOperation\n\n<font color = \"rgb(226,238,250)\">`NSOperation`</font>和<font color = \"rgb(226,238,250)\">`NSOperationQueue`</font>主要涉及这几个方面：\n\n1. <font color = \"rgb(226,238,250)\">`NSOperation`</font>和</font>和<font color = \"rgb(226,238,250)\">`NSOperationQueue`</font>用法介绍\n2. <font color = \"rgb(226,238,250)\">`NSOperation`</font>的暂停、恢复和取消\n3. 通过KVO对<font color = \"rgb(226,238,250)\">`NSOperation`</font>的状态进行检测\n3. 多个<font color = \"rgb(226,238,250)\">`NSOperation`</font>的之间的依赖关系\n\n从简单意义上来说，<font color = \"rgb(226,238,250)\">`NSOperation`</font>是对GCD中的block进行的封装，它也表示一个要被执行的任务。\n\n与GCD中的block类似，<font color = \"rgb(226,238,250)\">`NSOperation`</font>对象有一个<font color = \"rgb(226,238,250)\">`start()`</font>方法表示开始执行这个任务。\n\n不仅如此，<font color = \"rgb(226,238,250)\">`NSOperation`</font>表示的任务还可以被取消。它还有三种状态<font color = \"rgb(226,238,250)\">`isExecuted`</font>、<font color = \"rgb(226,238,250)\">`isFinished`</font>和<font color = \"rgb(226,238,250)\">`isCancelled`</font>以方便我们通过KVC对它的状态进行监听。\n\n想要开始执行一个任务可以这么写：\n\n```swift\nlet operation = NSBlockOperation { () -> Void in\n\tprint(NSThread.currentThread())\n}\noperation.addExecutionBlock { () -> Void in\n\tprint(\"execution block1 -- \\(NSThread.currentThread())\")\n}\noperation.start()\n```\n\n以上代码会得到这样的执行结果：\n\n```swift\n<NSThread: 0x7f89b1c070f0>{number = 1, name = main}\nexecution block1 -- <NSThread: 0x7f89b1e17030>{number = 2, name = (null)}\n```\n\n首先我们创建了一个<font color = \"rgb(226,238,250)\">`NSBlockOperation `</font>，并且设置好它的block，也就是将要执行的任务。这个任务会在主线程中执行。\n\n用<font color = \"rgb(226,238,250)\">`NSBlockOperation `</font>是因为<font color = \"rgb(226,238,250)\">`NSOperation `</font>是一个基类，不应该直接生成<font color = \"rgb(226,238,250)\">`NSOperation `</font>对象，而是应该用它的子类。<font color = \"rgb(226,238,250)\">`NSBlockOperation `</font>是苹果预定义的子类，它可以用来封装一个或多个block，后面会介绍如何自己创建<font color = \"rgb(226,238,250)\">`NSOperation `</font>的子类。\n\n同时，还可以调用<font color = \"rgb(226,238,250)\">`addExecutionBlock `</font>方法追加几个任务，这些任务会并行执行（也就是说很有可能运行在别的线程里）。\n\n最后，调用<font color = \"rgb(226,238,250)\">`start `</font>方法让<font color = \"rgb(226,238,250)\">`NSOperation `</font>方法运行起来。<font color = \"rgb(226,238,250)\">`start `</font>是一个**同步**方法。\n\n## NSOperationQueue\n\n刚刚我们知道，默认的<font color = \"rgb(226,238,250)\">`NSOperation `</font>是同步执行的。简单的看一下<font color = \"rgb(226,238,250)\">`NSOperation `</font>类的定义会发现它有一个只读属性<font color = \"rgb(226,238,250)\">`asynchronous `</font>\n\n这意味着如果想要异步执行，就需要自定义<font color = \"rgb(226,238,250)\">`NSOperation `</font>的子类。或者使用<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>\n\n<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>类似于GCD中的队列。我们知道GCD中的队列有三种：**主队列**、**串行队列**和**并行队列**。<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>更简单，只有两种：**主队列**和**非主队列**。\n\n我们自己生成的<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>对象都是非主队列，主队列可以用<font color = \"rgb(226,238,250)\">`NSOperationQueue.mainQueue `</font>取得。\n\n<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>的主队列是串行队列，而且其中所有<font color = \"rgb(226,238,250)\">`NSOperation `</font>都会在主线程中执行。\n\n对于非主队列来说，一旦一个<font color = \"rgb(226,238,250)\">`NSOperation `</font>被放入其中，那这个<font color = \"rgb(226,238,250)\">`NSOperation `</font>一定是并发执行的。因为<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>会为每一个<font color = \"rgb(226,238,250)\">`NSOperation `</font>创建线程并调用它的<font color = \"rgb(226,238,250)\">`start `</font>方法。\n\n<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>有一个属性叫<font color = \"rgb(226,238,250)\">`maxConcurrentOperationCount `</font>，它表示最多支持多少个<font color = \"rgb(226,238,250)\">`NSOperation `</font>并发执行。如果<font color = \"rgb(226,238,250)\">`maxConcurrentOperationCount `</font>被设为1，就以为这个队列是串行队列。\n\n因此，<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>和GCD中的队列有这样的对应关系：\n\n![](http://7xonij.com1.z0.glb.clouddn.com/Tables/relationship2.jpg)\n\n回到开头的问题，如何利用<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>实现异步操作呢，代码如下：\n\n```swift\nlet operationQueue = NSOperationQueue()\nlet operation = NSBlockOperation { () -> Void in\n\tprint(NSThread.currentThread())\n}\n\toperation.addExecutionBlock { () -> Void in\n\tprint(\"execution block1 -- \\(NSThread.currentThread())\")\n}\noperationQueue.addOperation(operation)\nprint(\"操作结束\")\n```\n\n得到运行结果如下：\n\n```swift\n操作结束\n<NSThread: 0x7fd51d2111b0>{number = 2, name = (null)}\nexecution block1 -- <NSThread: 0x7fd51d21bd50>{number = 3, name = (null)}\n\n```\n\n使用<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>来执行任务与之前的区别在于，首先创建一个非主队列。然后用<font color = \"rgb(226,238,250)\">`addOperation `</font>方法替换之前的<font color = \"rgb(226,238,250)\">`start `</font>方法。刚刚已经说过，<font color = \"rgb(226,238,250)\">`NSOperationQueue `</font>会为每一个<font color = \"rgb(226,238,250)\">`NSOperation `</font>建立线程并调用他们的<font color = \"rgb(226,238,250)\">`start `</font>方法。\n\n观察一下运行结果，所有的<font color = \"rgb(226,238,250)\">`NSOperation `</font>都没有在主线程执行，从而成功的实现了异步、并行处理。\n\n## NSOperation新特性\n\n在学习<font color = \"rgb(226,238,250)\">`NSOperation`</font>的时候，我们总是用GCD的概念去解释。但是<font color = \"rgb(226,238,250)\">`NSOperation`</font>作为对GCD更高层次的封装，它有着一些GCD无法实现（或者至少说很难实现）的特性。由于<font color = \"rgb(226,238,250)\">`NSOperation`</font>和<font color = \"rgb(226,238,250)\">`NSOperationQueue`</font>良好的封装，这些新特性的使用都非常简单。\n\n### 取消任务\n如果我们有两次网络请求，第二次请求会用到第一次的数据。如果此时网络情况不好，第一次请求超时了，那么第二次请求也没有必要发送了。当然，用户也有可能人为地取消某个<font color = \"rgb(226,238,250)\">`NSOperation`</font>。\n\n当某个<font color = \"rgb(226,238,250)\">`NSOperation`</font>被取消时，我们应该尽可能的清除<font color = \"rgb(226,238,250)\">`NSOperation`</font>内部的数据并且把<font color = \"rgb(226,238,250)\">`cancelled`</font>和<font color = \"rgb(226,238,250)\">`finished`</font>设为<font color = \"rgb(226,238,250)\">`true`</font>，把<font color = \"rgb(226,238,250)\">`executing`</font>设为<font color = \"rgb(226,238,250)\">`false`</font>。\n\n```swift\n//取消某个NSOperation\noperation1.cancel()\n\n//取消某个NSOperationQueue剩余的NSOperation\nqueue.cencelAllOperations()\n\n```\n\n### 设置依赖\n依然考虑刚刚所说的两次网络请求的例子。因为第二次请求会用到第一次的数据，所以我们要保证发出第二次请求的时候第一个请求已经执行完。但是我们同时还希望利用到<font color = \"rgb(226,238,250)\">`NSOperationQueue`</font>的并发特性（因为可能不止这两个任务）。\n\n这时候我们可以设置<font color = \"rgb(226,238,250)\">`NSOperation`</font>之间的依赖关系。语法非常简洁：\n\n```swift\noperation2.addDependency(operation1)\n```\n\n需要注意的是<font color = \"rgb(226,238,250)\">`NSOperation`</font>之间的相互依赖会导致死锁\n\n### NSOperationQueue暂停与恢复\n\n这个更加简单，只要修改<font color = \"rgb(226,238,250)\">`suspended`</font>属性即可\n\n```swift\nqueue.suspended = true //暂停queue中所有operation\nqueue.suspended = false //恢复queue中所有operation\n```\n\n### NSOperation优先级\n\nGCD中，任务（block）是没有优先级的，而队列具有优先级。和GCD相反，我们一般考虑<font color = \"rgb(226,238,250)\">`NSOperation`</font>的优先级\n\n\n<font color = \"rgb(226,238,250)\">`NSOperation`</font>有一个<font color = \"rgb(226,238,250)\">`NSOperationQueuePriority `</font>枚举类型的属性<font color = \"rgb(226,238,250)\">`queuePriority`</font>\n\n```swift\npublic enum NSOperationQueuePriority : Int {\n    case VeryLow\n    case Low\n    case Normal\n    case High\n    case VeryHigh\n}\n```\n\n需要注意的是，<font color = \"rgb(226,238,250)\">`NSOperationQueue`</font>也不能完全保证优先级高的任务一定先执行。\n\n## NSOperation和GCD如何选择\n\n其实经过这两篇文章的分析，我们大概对<font color = \"rgb(226,238,250)\">`NSOperation`</font>和<font color = \"rgb(226,238,250)\">`GCD`</font>都有了比较详细的了解，同时在亲自运用这两者的过程中有了自己的理解。\n\nGCD以block为单位，代码简洁。同时GCD中的队列、组、信号量、source、barriers都是组成并行编程的基本原语。对于一次性的计算，或是仅仅为了加快现有方法的运行速度，选择轻量化的GCD就更加方便。\n\n而<font color = \"rgb(226,238,250)\">`NSOperation`</font>可以用来规划一组任务之间的依赖关系，设置它们的优先级，任务能被取消。队列可以暂停、恢复。<font color = \"rgb(226,238,250)\">`NSOperation`</font>还可以被子类化。这些都是GCD所不具备的。\n\n所以我们要记住的是：\n> **<font color = \"rgb(226,238,250)\">`NSOperation`</font>和GCD并不是互斥的，有效地结合两者可以开发出更棒的应用**\n\n## GCD进阶\n\n`NSOperation`有自己独特的优势，`GCD`也有一些强大的特性。接下来我们由浅入深，讨论以下几个部分：\n\n* <font color =\"rgb(226,238,250)\">`dispatch_suspend`</font>和<font color =\"rgb(226,238,250)\">`dispatch_resume`</font>\n* <font color =\"rgb(226,238,250)\">`dispathc_once`</font>\n* <font color =\"rgb(226,238,250)\">`dispatch_barrier_async`</font>\n* <font color =\"rgb(226,238,250)\">`dispatch_semaphore`</font>\n\n### dispatch\\_suspend和dispatch\\_resume\n\n我们知道<font color =\"rgb(226,238,250)\">`NSOperationQueue `</font>有暂停(suspend)和恢复(resume)。其实GCD中的队列也有类似的功能。用法也非常简单：\n\n```swift\ndispatch_suspend(queue) //暂停某个队列\ndispatch_resume(queue)  //恢复某个队列\n```\n\n这些函数不会影响到队列中已经执行的任务，队列暂停后，已经添加到队列中但还没有执行的任务不会执行，直到队列被恢复。\n\n### dispathc_once\n\n首先我们来看一下最简单的`dispathc_once`函数，这在单例模式中被广泛使用。\n\n* <font color =\"rgb(226,238,250)\">`dispathc_once`</font>函数可以确保某个block在应用程序执行的过程中只被处理一次，而且它是线程安全的。所以单例模式可以很简单的实现，以OC中Manager类为例\n\n```objective-c\n+ (Manager *)sharedInstance {\n\tstatic Manager *sharedManagerInstance = nil;\n\tstatic dispatch_once_t once;\n\t\n\tdispatch_once($once, ^{\n\t\tsharedManagerInstance = [[Manager alloc] init];\n\t});\n\t\n\treturn sharedManagerInstance;\n}\n```\n\n这段代码中我们创建一个值为nil的<font color =\"rgb(226,238,250)\">`sharedManagerInstance `</font>静态对象，然后把它的初始化代码放到<font color =\"rgb(226,238,250)\">`dispatch_once`</font>中完成。\n\n这样，只有第一次调用<font color =\"rgb(226,238,250)\">`sharedInstance`</font>方法时才会进行对象的初始化，以后每次只是返回<font color =\"rgb(226,238,250)\">`sharedManagerInstance `</font>而已。\n\n### dispatch\\_barrier_async\n\n我们知道数据在写入时，不能在其他线程读取或写入。但是多个线程同时读取数据是没有问题的。所以我们可以把读取任务放入并行队列，把写入任务放入串行队列，并且保证写入任务执行过程中没有读取任务可以执行。\n\n这样的需求比较常见，GCD提供了一个非常简单的解决办法——<font color =\"rgb(226,238,250)\">`dispatch_barrier_async`</font>\n\n假设我们有四个读取任务，在第二三个任务之间有一个写入任务，代码大概是这样：\n\n```swift\nlet queue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_CONCURRENT)\n\ndispatch_async(queue, block1_for_reading)\ndispatch_async(queue, block2_for_reading)\n\n/*\n\t这里插入写入任务，比如：\n\tdispatch_async(queue, block_for_writing)\n*/\n\ndispatch_async(queue, block3_for_reading)\ndispatch_async(queue, block4_for_reading)\n\n```\n\n如果代码这样写，由于这几个block是并发执行，就有可能在前两个block中读取到已经修改了的数据。如果是有多写入任务，那问题更严重，可能会有数据竞争。\n\n如果使用<font color =\"rgb(226,238,250)\">`dispatch_barrier_async`</font>函数，代码就可以这么写：\n\n```swift\ndispatch_async(queue, block1_for_reading)\ndispatch_async(queue, block2_for_reading)\n\ndispatch_barrier_async(queue, block_for_writing)\n\ndispatch_async(queue, block3_for_reading)\ndispatch_async(queue, block4_for_reading)\n```\n\n<font color =\"rgb(226,238,250)\">`dispatch_barrier_async`</font>会把并行队列的运行周期分为这三个过程：\n\n1. 首先等目前追加到并行队列中所有任务都执行完成\n2. 开始执行<font color =\"rgb(226,238,250)\">`dispatch_barrier_async`</font>中的任务，这时候即使向并行队列提交任务，也不会执行\n3. <font color =\"rgb(226,238,250)\">`dispatch_barrier_async`</font>中的任务执行完成后，并行队列恢复正常。\n\n总的来说，<font color =\"rgb(226,238,250)\">`dispatch_barrier_async`</font>起到了“**承上启下**”的作用。它保证此前的任务都先于自己执行，此后的任务也迟于自己执行。正如barrier的含义一样，它起到了一个栅栏、或是分水岭的作用。\n\n这样一来，使用并行队列和<font color =\"rgb(226,238,250)\">`dispatc_barrier_async`</font>方法，就可以高效的进行数据和文件读写了。\n\n\n### dispatch_semaphore\n\n首先介绍一下信号量(semaphore)的概念。信号量是持有计数的信号，不过这么解释等于没解释。我们举个生活中的例子来看看。\n\n假设有一个房子，它对应进程的概念，房子里的人就对应着线程。一个进程可以包括多个线程。这个房子(进程)有很多资源，比如花园、客厅等，是所有人(线程)共享的。\n\n但是有些地方，比如卧室，最多只有两个人能进去睡觉。怎么办呢，在卧室门口挂上两把钥匙。进去的人(线程)拿着钥匙进去，没有钥匙就不能进去，出来的时候把钥匙放回门口。\n\n这时候，门口的钥匙数量就称为**信号量(Semaphore)**。很明显，信号量为0时需要等待，信号量不为零时，减去1而且不等待。\n\n在GCD中，创建信号量的语法如下：\n\n```swift\nvar semaphore = dispatch_semaphore_create(2)\n```\n\n这句代码通过<font color =\"rgb(226,238,250)\">`dispatch_semaphore_create `</font>方法创建一个信号量并设置初始值为2。然后就可以调用<font color =\"rgb(226,238,250)\">`dispatch_semaphore_wait`</font>方法了。\n\n```swift\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)\n```\n\n<font color =\"rgb(226,238,250)\">`dispatch_semaphore_wait`</font>方法表示一直等待直到信号量的值大于等于一，当这个方法执行后，会把第一个信号量参数的值减1。\n\n第二个参数是一个<font color =\"rgb(226,238,250)\">`dispatch_time_t`</font>类型的时间，它表示这个方法最大的等待时间。这在第一章中已经讲过，比如\n<font color =\"rgb(226,238,250)\">`DISPATCH_TIME_FOREVER `</font>表示永久等待。\n\n返回值也和<font color =\"rgb(226,238,250)\">`dispatch_group_wait`</font>方法一样，返回0表示在规定的等待时间内第一个参数信号量的值已经大于等于1，否则表示已超过规定等待时间，但信号量的值还是0。\n\n<font color =\"rgb(226,238,250)\">`dispatch_semaphore_wait`</font>方法返回0，因为此时的信号量的值大于等于一，任务获得了可以执行的权限。这时候我们就可以安全的执行需要进行排他控制的任务了。\n\n任务结束时还需要调用\n<font color =\"rgb(226,238,250)\">`dispatch_semaphore_signal()`</font>方法，将信号量的值加1。这类似于之前所说的，从卧室出来要把锁放回门上，否则后来的人就无法进入了。\n\n我们来看一个完整的例子：\n\n```swift\nvar semaphore = dispatch_semaphore_create(1)\nlet queue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_CONCURRENT)\nvar array: [Int] = []\n\nfor i in 1...100000 {\n\tdispatch_async(queue, { () -> Void in\n\t\t/*\n\t\t\t某个线程执行到这里，如果信号量值为1，那么wait方法返回1，开始执行接下来的操作。\n\t\t\t与此同时，因为信号量变为0，其它执行到这里的线程都必须等待\n\t\t*/\n\t\tdispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)\n                \n\t\t/*\n\t\t\t执行了wait方法后，信号量的值变成了0。可以进行接下来的操作。\n\t\t\t这时候其它线程都得等待wait方法返回。\n\t\t\t可以对array修改的线程在任意时刻都只有一个，可以安全的修改array\n\t\t*/\n\t\tarray.append(i)\n                \n\t\t/*\n\t\t\t排他操作执行结束，记得要调用signal方法，把信号量的值加1。\n\t\t\t这样，如果有别的线程在等待wait函数返回，就由最先等待的线程执行。\n\t\t*/\n\t\tdispatch_semaphore_signal(semaphore)\n\t})\n}\n```\n\n如果你想知道不用信号量会出什么问题，可以看我的另一篇文章[Swift数组append方法研究](http://115.159.123.174/swiftarrayappend/)","html":"<p>很长时间以来，我个人（可能还有很多同学），对多线程编程都存在一些误解。一个很明显的表现是，很多人有这样的看法：</p>\n\n<blockquote>\n  <p>新开一个线程，能提高速度，避免阻塞主线程</p>\n</blockquote>\n\n<p>毕竟多线程嘛，几个线程一起跑任务，速度快，还不阻塞主线程，简直完美。</p>\n\n<p>在某些场合，我们还见过另一个“高深”的名词——“异步”。这东西好像和多线程挺类似，经过一番百度（阅读了很多质量层次不齐的文章）之后，很多人也没能真正搞懂何为“异步”。</p>\n\n<p>于是，带着对“多线程”和“异步”的懵懂，很多人又开开心心踏上了多线程编程之旅，比如文章待会儿会提到的GCD。</p>\n\n<h2 id=\"\">何为多线程</h2>\n\n<p>其实，如果<strong>不考虑其他任何因素和技术</strong>，多线程有百害而无一利，只能浪费时间，降低程序效率。</p>\n\n<p>是的，我很清醒的写下这句话。</p>\n\n<p>试想一下，一个任务由十个子任务组成。现在有两种方式完成这个任务：\n1. 建十个线程，把每个子任务放在对应的线程中执行。执行完一个线程中的任务就切换到另一个线程。 <br />\n2. 把十个任务放在一个线程里，按顺序执行。</p>\n\n<p>操作系统的基础知识告诉我们，线程，是执行程序最基本的单元，它有自己栈和寄存器。说得再具体一些，线程就是<strong>“一个CPU执行的一条无分叉的命令列”</strong>。</p>\n\n<p>对于第一种方法，在十个线程之间来回切换，就意味着有十组栈和寄存器中的值需要不断地被备份、替换。\n而对于对于第二种方法，只有一组寄存器和栈存在，显然效率完胜前者。</p>\n\n<h3 id=\"\">并发与并行</h3>\n\n<p>通过刚刚的分析我们看到，多线程本身会带来效率上的损失。准确来说，在处理并发任务时，多线程不仅不能提高效率，反而还会降低程序效率。</p>\n\n<p>所谓的“<strong>并发</strong>”，英文翻译是concurrent。要注意和<strong>“并行（parallelism）”</strong>的区别。</p>\n\n<blockquote>\n  <p><strong>并发</strong>指的是一种现象，一种经常出现，无可避免的现象。它描述的是“多个任务同时发生，需要被处理”这一现象。它的侧重点在于“发生”。</p>\n</blockquote>\n\n<p>比如有很多人排队等待检票，这一现象就可以理解为并发。</p>\n\n<blockquote>\n  <p><strong>并行</strong>指的是一种技术，一个同时处理多个任务的技术。它描述了一种能够同时处理多个任务的能力，侧重点在于“运行”。</p>\n</blockquote>\n\n<p>比如景点开放了多个检票窗口，同一时间内能服务多个游客。这种情况可以理解为并行。</p>\n\n<p>并行的反义词就是串行，表示任务必须按顺序来，一个一个执行，前一个执行完了才能执行后一个。</p>\n\n<p>我们经常挂在嘴边的“多线程”，正是采用了并行技术，从而提高了执行效率。因为有多个线程，所以计算机的多个CPU可以同时工作，同时处理不同线程内的指令。</p>\n\n<p>并发是一种现象，面对这一现象，我们首先创建多个线程，真正加快程序运行速度的，是并行技术。也就是让多个CPU同时工作。而多线程，是为了让多个CPU同时工作成为可能。</p>\n\n<h3 id=\"\">同步与异步</h3>\n\n<p>同步方法就是我们平时调用的哪些方法。因为任何有编程经验的人都知道，比如在第一行调用<font color = \"rgb(226,238,250)\"><code>foo()</code></font>方法，那么程序运行到第二行的时候，foo方法肯定是执行完了。</p>\n\n<p>所谓的异步，就是允许在执行某一个任务时，函数立刻返回，但是真正要执行的任务稍后完成。</p>\n\n<p>比如我们在点击保存按钮之后，要先把数据写到磁盘，然后更新UI。同步方法就是等到数据保存完再更新UI，而异步则是立刻从保存数据的方法返回并向后执行代码，同时真正用来保存数据的指令将在稍后执行。</p>\n\n<h3 id=\"\">区别和联系</h3>\n\n<p>假设现在有三个任务需要处理。假设单个CPU处理它们分别需要3、1、1秒。</p>\n\n<p>并行与串行，其实讨论的是处理这三个任务的速度问题。如果三个CPU并行处理，那么一共只需要3秒。相比于串行处理，节约了两秒。</p>\n\n<p>而同步/异步，其实描述的是任务之间先后顺序问题。假设需要三秒的那个是保存数据的任务，而另外两个是UI相关的任务。那么通过异步执行第一个任务，我们省去了三秒钟的卡顿时间。</p>\n\n<p>对于同步执行的三个任务来说，系统<strong>倾向于</strong>在同一个线程里执行它们。因为即使开了三个线程，也得等他们分别在各自的线程中完成。并不能减少总的处理时间，反而徒增了线程切换（这就是文章开头举的例子）</p>\n\n<p>对于异步执行的三个任务来说，系统<strong>倾向于</strong>在三个新的线程里执行他们。因为这样可以最大程度的利用CPU性能，提升程序运行效率。</p>\n\n<h3 id=\"\">总结</h3>\n\n<p>于是我们可以得出结论，在需要同时处理IO和UI的情况下，真正起作用的是异步，而不是多线程。可以不用多线程（因为处理UI非常快），但不能不用异步（否则的话至少要等IO结束）。</p>\n\n<p>注意到我把“倾向于”这三个加粗了，也就是说异步方法并不一定永远在新线程里面执行，反之亦然。在接下来关于GCD的部分会对此做出解释。</p>\n\n<h2 id=\"gcd\">GCD简介</h2>\n\n<p>GCD以block为基本单位，一个block中的代码可以为一个任务。下文中提到任务，可以理解为执行某个block</p>\n\n<p>同时，GCD中有两大最重要的概念，分别是“队列”和“执行方式”。</p>\n\n<p>使用block的过程，概括来说就是把block放进合适的队列，并选择合适的执行方式去执行block的过程。</p>\n\n<h4 id=\"\">三种队列：</h4>\n\n<ol>\n<li>串行队列（队列中的任务并行处理）  </li>\n<li>并行队列（队列中的任务并行处理）  </li>\n<li>主队列（这是一个特殊的串行队列，而且队列中的任务一定会在主线程中执行）</li>\n</ol>\n\n<h4 id=\"\">两种执行方式：</h4>\n\n<ol>\n<li>同步执行  </li>\n<li>异步执行</li>\n</ol>\n\n<p>关于同步异步、串行并行和线程的关系，下面通过一个表格来总结</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Tables/ralationship.jpg\" alt=\"\" /></p>\n\n<p>可以看到，同步方法不一定在本线程，异步方法方法也不一定新开线程（考虑主队列）。</p>\n\n<p>然而事实上，在本文一开始就揭开了“多线程”的神秘面纱，所以我们在编程时，更应该考虑的是：</p>\n\n<blockquote>\n  <p>同步 Or 异步</p>\n</blockquote>\n\n<p>以及</p>\n\n<blockquote>\n  <p>串行 Or 并行</p>\n</blockquote>\n\n<p>而非仅仅考虑是否新开线程。</p>\n\n<p>当然，了解任务运行在那个线程中也是为了更加深入的理解整个程序的运行情况，尤其是接下来要讨论的死锁问题。</p>\n\n<h3 id=\"gcd\">GCD的死锁问题</h3>\n\n<p>在使用GCD的过程中，如果<strong>同步地添加一个将要在当前线程执行的任务</strong>，就会导致死锁。</p>\n\n<p>这句话有点绕，我们首先举个例子看看：</p>\n\n<pre><code class=\"language-swift\">override func viewDidLoad() {  \n    super.viewDidLoad()\n    let mainQueue = dispatch_get_main_queue()\n    let block = { ()  in\n        print(NSThread.currentThread())\n    }    \n    dispatch_sync(mainQueue, block)\n}\n</code></pre>\n\n<p>这段代码就会导致死锁，因为我们将要同步地添加一个<font color = \"rgb(226,238,250)\"><code>block</code></font>，<font color = \"rgb(226,238,250)\"><code>block</code></font>被添加到主队列中。</p>\n\n<p>根据之前的表格，同步的往主队列中添加任务，任务会在主线程执行。而当前这段代码也在主线程中执行，所以导致死锁。</p>\n\n<h3 id=\"\">理论分析</h3>\n\n<p>我们知道<font color = \"rgb(226,238,250)\"><code>dispatch_sync</code></font>表示同步的执行任务，也就是说执行<font color = \"rgb(226,238,250)\"><code>dispatch_sync</code></font>后，当前线程会阻塞。而<font color = \"rgb(226,238,250)\"><code>dispatch_sync</code></font>中的block如果要在当前线程中执行，就得等待当前线程执行完成（也就是不再阻塞）。</p>\n\n<p>很不幸的是，当前线程在<font color = \"rgb(226,238,250)\"><code>dispatch_sync</code></font>的block执行完之前都是阻塞的，于是导致了死锁。</p>\n\n<h3 id=\"\">解决方案</h3>\n\n<p>其实在通常情况下我们不必要用<font color = \"rgb(226,238,250)\"><code>dispatch_sync</code></font>，因为<font color = \"rgb(226,238,250)\"><code>dispatch_async</code></font>能够更好的利用CPU，提升程序运行速度。</p>\n\n<p>只有当我们需要保证队列中的任务必须顺序执行时，才考虑使用<font color = \"rgb(226,238,250)\"><code>dispatch_sync</code></font>。对于每一个串行队列，它有与之唯一对应的线程。所以在使用<font color = \"rgb(226,238,250)\"><code>dispatch_sync</code></font>的时候应该分析当前属于哪个线程，以及队列中的任务会在哪个线程执行。</p>\n\n<h3 id=\"gcd\">GCD任务组</h3>\n\n<p>了解完队列之后，很自然的会有一个想法：我们怎么知道所有任务都已经执行完了呢？</p>\n\n<p>在单个串行队列中，这个不是问题，因为只要把回调block添加到队列末尾即可。</p>\n\n<p>但是对于并行队列，以及多个串行、并行队列混合的情况，就需要使用<font color = \"rgb(226,238,250)\"><code>dispatch_group</code></font>了。</p>\n\n<pre><code class=\"language- swift\">let group = dispatch_group_create()\n\ndispatch_group_async(group, serialQueue, { () -&gt; Void in  \n    for _ in 0..&lt;2 {\n        print(\"group-serial \\(NSThread.currentThread())\")\n    }\n})\n\ndispatch_group_async(group, serialQueue, { () -&gt; Void in  \n    for _ in 0..&lt;3 {\n        NSLog(\"group-02 - %@\", NSThread.currentThread())\n    }\n})\n\ndispatch_group_notify(group, serialQueue, { () -&gt; Void in  \n    print(\"完成 - \\(NSThread.currentThread())\")\n})\n</code></pre>\n\n<p>首先我们要通过<font color = \"rgb(226,238,250)\"><code>dispatch_group_create()</code></font>方法生成一个组。</p>\n\n<p>接下来，我们把<font color = \"rgb(226,238,250)\"><code>dispatch_async</code></font>方法换成<font color = \"rgb(226,238,250)\"><code>dispatch_group_async</code></font>。这个方法多了一个参数，第一个参数填刚刚创建的分组。</p>\n\n<p>想问<font color = \"rgb(226,238,250)\"><code>dispatch_sync</code></font>对应的分组方法是什么的童鞋面壁思过三秒钟，思考一下group出现的目的和<font color = \"rgb(226,238,250)\"><code>dispatch_sync</code></font>的特点。</p>\n\n<p>最后调用<font color = \"rgb(226,238,250)\"><code>dispatch_group_create</code></font>方法。这个方法表示把第三个参数block传入第二个参数队列中去。而且可以保证第三个参数block执行时，group中的所有任务已经全部完成。</p>\n\n<h3 id=\"dispatch_group\">dispatch_group</h3>\n\n<p><font color = \"rgb(226,238,250)\"><code>dispatch_group_wait</code></font>方法是一个很有用的方法，它的完整定义如下：</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>dispatch_group_wait(group: dispatch_group_t, _ timeout: dispatch_time_t) -&gt; Int</code></font></p>\n\n<p>第一个参数表示要等待的group，第二个则表示等待时间。返回值表示经过指定的等待时间，属于这个group的任务是否已经全部执行完，如果是则返回0，否则返回非0。</p>\n\n<p>第二个<font color = \"rgb(226,238,250)\"><code>dispatch_time_t</code></font>类型的参数还有两个特殊值：<font color = \"rgb(226,238,250)\"><code>DISPATCH_TIME_NOW</code></font>和<font color = \"rgb(226,238,250)\"><code>DISPATCH_TIME_FOREVER</code></font>。</p>\n\n<p>前者表示立刻检查属于这个group的任务是否已经完成，后者则表示一直等到属于这个group的任务全部完成。</p>\n\n<h3 id=\"dispatch_after\">dispatch_after方法</h3>\n\n<p>通过GCD还可以进行简单的定时操作，比如在1秒后执行某个block。代码如下：</p>\n\n<pre><code class=\"language- swift\">let mainQueue = dispatch_get_main_queue()  \nlet time = dispatch_time(DISPATCH_TIME_NOW, Int64(3) * Int64(NSEC_PER_SEC))  \nNSLog(\"%@\",NSThread.currentThread())  \ndispatch_after(time, mainQueue, {() in NSLog(\"%@\",NSThread.currentThread())})  \n</code></pre>\n\n<p></font>和<font color = \"rgb(226,238,250)\"><code>dispatch_after</code></font>方法有三个参数。第一个表示时间，也就是从现在起往后三秒钟。第二三个参数分别表示要提交的任务和提交到哪个队列。</p>\n\n<p>需要注意的是</font>和<font color = \"rgb(226,238,250)\"><code>dispatch_after</code></font>仅表示在指定时间后提交任务，而非执行任务。如果任务提交到主队列，它将在main runloop中执行，对于每隔1/60秒执行一次的RunLoop，任务最多有可能在3+1/60秒后执行。</p>\n\n<h2 id=\"nsoperation\">NSOperation</h2>\n\n<p><font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>和<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>主要涉及这几个方面：</p>\n\n<ol>\n<li><font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>和</font>和<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>用法介绍  </li>\n<li><font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>的暂停、恢复和取消  </li>\n<li>通过KVO对<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>的状态进行检测  </li>\n<li>多个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>的之间的依赖关系</li>\n</ol>\n\n<p>从简单意义上来说，<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>是对GCD中的block进行的封装，它也表示一个要被执行的任务。</p>\n\n<p>与GCD中的block类似，<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>对象有一个<font color = \"rgb(226,238,250)\"><code>start()</code></font>方法表示开始执行这个任务。</p>\n\n<p>不仅如此，<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>表示的任务还可以被取消。它还有三种状态<font color = \"rgb(226,238,250)\"><code>isExecuted</code></font>、<font color = \"rgb(226,238,250)\"><code>isFinished</code></font>和<font color = \"rgb(226,238,250)\"><code>isCancelled</code></font>以方便我们通过KVC对它的状态进行监听。</p>\n\n<p>想要开始执行一个任务可以这么写：</p>\n\n<pre><code class=\"language-swift\">let operation = NSBlockOperation { () -&gt; Void in  \n    print(NSThread.currentThread())\n}\noperation.addExecutionBlock { () -&gt; Void in  \n    print(\"execution block1 -- \\(NSThread.currentThread())\")\n}\noperation.start()  \n</code></pre>\n\n<p>以上代码会得到这样的执行结果：</p>\n\n<pre><code class=\"language-swift\">&lt;NSThread: 0x7f89b1c070f0&gt;{number = 1, name = main}  \nexecution block1 -- &lt;NSThread: 0x7f89b1e17030&gt;{number = 2, name = (null)}  \n</code></pre>\n\n<p>首先我们创建了一个<font color = \"rgb(226,238,250)\"><code>NSBlockOperation</code></font>，并且设置好它的block，也就是将要执行的任务。这个任务会在主线程中执行。</p>\n\n<p>用<font color = \"rgb(226,238,250)\"><code>NSBlockOperation</code></font>是因为<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>是一个基类，不应该直接生成<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>对象，而是应该用它的子类。<font color = \"rgb(226,238,250)\"><code>NSBlockOperation</code></font>是苹果预定义的子类，它可以用来封装一个或多个block，后面会介绍如何自己创建<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>的子类。</p>\n\n<p>同时，还可以调用<font color = \"rgb(226,238,250)\"><code>addExecutionBlock</code></font>方法追加几个任务，这些任务会并行执行（也就是说很有可能运行在别的线程里）。</p>\n\n<p>最后，调用<font color = \"rgb(226,238,250)\"><code>start</code></font>方法让<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>方法运行起来。<font color = \"rgb(226,238,250)\"><code>start</code></font>是一个<strong>同步</strong>方法。</p>\n\n<h2 id=\"nsoperationqueue\">NSOperationQueue</h2>\n\n<p>刚刚我们知道，默认的<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>是同步执行的。简单的看一下<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>类的定义会发现它有一个只读属性<font color = \"rgb(226,238,250)\"><code>asynchronous</code></font></p>\n\n<p>这意味着如果想要异步执行，就需要自定义<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>的子类。或者使用<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font></p>\n\n<p><font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>类似于GCD中的队列。我们知道GCD中的队列有三种：<strong>主队列</strong>、<strong>串行队列</strong>和<strong>并行队列</strong>。<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>更简单，只有两种：<strong>主队列</strong>和<strong>非主队列</strong>。</p>\n\n<p>我们自己生成的<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>对象都是非主队列，主队列可以用<font color = \"rgb(226,238,250)\"><code>NSOperationQueue.mainQueue</code></font>取得。</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>的主队列是串行队列，而且其中所有<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>都会在主线程中执行。</p>\n\n<p>对于非主队列来说，一旦一个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>被放入其中，那这个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>一定是并发执行的。因为<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>会为每一个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>创建线程并调用它的<font color = \"rgb(226,238,250)\"><code>start</code></font>方法。</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>有一个属性叫<font color = \"rgb(226,238,250)\"><code>maxConcurrentOperationCount</code></font>，它表示最多支持多少个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>并发执行。如果<font color = \"rgb(226,238,250)\"><code>maxConcurrentOperationCount</code></font>被设为1，就以为这个队列是串行队列。</p>\n\n<p>因此，<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>和GCD中的队列有这样的对应关系：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Tables/relationship2.jpg\" alt=\"\" /></p>\n\n<p>回到开头的问题，如何利用<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>实现异步操作呢，代码如下：</p>\n\n<pre><code class=\"language-swift\">let operationQueue = NSOperationQueue()  \nlet operation = NSBlockOperation { () -&gt; Void in  \n    print(NSThread.currentThread())\n}\n    operation.addExecutionBlock { () -&gt; Void in\n    print(\"execution block1 -- \\(NSThread.currentThread())\")\n}\noperationQueue.addOperation(operation)  \nprint(\"操作结束\")  \n</code></pre>\n\n<p>得到运行结果如下：</p>\n\n<pre><code class=\"language-swift\">操作结束\n&lt;NSThread: 0x7fd51d2111b0&gt;{number = 2, name = (null)}  \nexecution block1 -- &lt;NSThread: 0x7fd51d21bd50&gt;{number = 3, name = (null)}\n</code></pre>\n\n<p>使用<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>来执行任务与之前的区别在于，首先创建一个非主队列。然后用<font color = \"rgb(226,238,250)\"><code>addOperation</code></font>方法替换之前的<font color = \"rgb(226,238,250)\"><code>start</code></font>方法。刚刚已经说过，<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>会为每一个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>建立线程并调用他们的<font color = \"rgb(226,238,250)\"><code>start</code></font>方法。</p>\n\n<p>观察一下运行结果，所有的<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>都没有在主线程执行，从而成功的实现了异步、并行处理。</p>\n\n<h2 id=\"nsoperation\">NSOperation新特性</h2>\n\n<p>在学习<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>的时候，我们总是用GCD的概念去解释。但是<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>作为对GCD更高层次的封装，它有着一些GCD无法实现（或者至少说很难实现）的特性。由于<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>和<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>良好的封装，这些新特性的使用都非常简单。</p>\n\n<h3 id=\"\">取消任务</h3>\n\n<p>如果我们有两次网络请求，第二次请求会用到第一次的数据。如果此时网络情况不好，第一次请求超时了，那么第二次请求也没有必要发送了。当然，用户也有可能人为地取消某个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>。</p>\n\n<p>当某个<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>被取消时，我们应该尽可能的清除<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>内部的数据并且把<font color = \"rgb(226,238,250)\"><code>cancelled</code></font>和<font color = \"rgb(226,238,250)\"><code>finished</code></font>设为<font color = \"rgb(226,238,250)\"><code>true</code></font>，把<font color = \"rgb(226,238,250)\"><code>executing</code></font>设为<font color = \"rgb(226,238,250)\"><code>false</code></font>。</p>\n\n<pre><code class=\"language-swift\">//取消某个NSOperation\noperation1.cancel()\n\n//取消某个NSOperationQueue剩余的NSOperation\nqueue.cencelAllOperations()\n</code></pre>\n\n<h3 id=\"\">设置依赖</h3>\n\n<p>依然考虑刚刚所说的两次网络请求的例子。因为第二次请求会用到第一次的数据，所以我们要保证发出第二次请求的时候第一个请求已经执行完。但是我们同时还希望利用到<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>的并发特性（因为可能不止这两个任务）。</p>\n\n<p>这时候我们可以设置<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>之间的依赖关系。语法非常简洁：</p>\n\n<pre><code class=\"language-swift\">operation2.addDependency(operation1)  \n</code></pre>\n\n<p>需要注意的是<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>之间的相互依赖会导致死锁</p>\n\n<h3 id=\"nsoperationqueue\">NSOperationQueue暂停与恢复</h3>\n\n<p>这个更加简单，只要修改<font color = \"rgb(226,238,250)\"><code>suspended</code></font>属性即可</p>\n\n<pre><code class=\"language-swift\">queue.suspended = true //暂停queue中所有operation  \nqueue.suspended = false //恢复queue中所有operation  \n</code></pre>\n\n<h3 id=\"nsoperation\">NSOperation优先级</h3>\n\n<p>GCD中，任务（block）是没有优先级的，而队列具有优先级。和GCD相反，我们一般考虑<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>的优先级</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>有一个<font color = \"rgb(226,238,250)\"><code>NSOperationQueuePriority</code></font>枚举类型的属性<font color = \"rgb(226,238,250)\"><code>queuePriority</code></font></p>\n\n<pre><code class=\"language-swift\">public enum NSOperationQueuePriority : Int {  \n    case VeryLow\n    case Low\n    case Normal\n    case High\n    case VeryHigh\n}\n</code></pre>\n\n<p>需要注意的是，<font color = \"rgb(226,238,250)\"><code>NSOperationQueue</code></font>也不能完全保证优先级高的任务一定先执行。</p>\n\n<h2 id=\"nsoperationgcd\">NSOperation和GCD如何选择</h2>\n\n<p>其实经过这两篇文章的分析，我们大概对<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>和<font color = \"rgb(226,238,250)\"><code>GCD</code></font>都有了比较详细的了解，同时在亲自运用这两者的过程中有了自己的理解。</p>\n\n<p>GCD以block为单位，代码简洁。同时GCD中的队列、组、信号量、source、barriers都是组成并行编程的基本原语。对于一次性的计算，或是仅仅为了加快现有方法的运行速度，选择轻量化的GCD就更加方便。</p>\n\n<p>而<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>可以用来规划一组任务之间的依赖关系，设置它们的优先级，任务能被取消。队列可以暂停、恢复。<font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>还可以被子类化。这些都是GCD所不具备的。</p>\n\n<p>所以我们要记住的是：</p>\n\n<blockquote>\n  <p><strong><font color = \"rgb(226,238,250)\"><code>NSOperation</code></font>和GCD并不是互斥的，有效地结合两者可以开发出更棒的应用</strong></p>\n</blockquote>\n\n<h2 id=\"gcd\">GCD进阶</h2>\n\n<p><code>NSOperation</code>有自己独特的优势，<code>GCD</code>也有一些强大的特性。接下来我们由浅入深，讨论以下几个部分：</p>\n\n<ul>\n<li><font color =\"rgb(226,238,250)\"><code>dispatch_suspend</code></font>和<font color =\"rgb(226,238,250)\"><code>dispatch_resume</code></font></li>\n<li><font color =\"rgb(226,238,250)\"><code>dispathc_once</code></font></li>\n<li><font color =\"rgb(226,238,250)\"><code>dispatch_barrier_async</code></font></li>\n<li><font color =\"rgb(226,238,250)\"><code>dispatch_semaphore</code></font></li>\n</ul>\n\n<h3 id=\"dispatch_suspenddispatch_resume\">dispatch_suspend和dispatch_resume</h3>\n\n<p>我们知道<font color =\"rgb(226,238,250)\"><code>NSOperationQueue</code></font>有暂停(suspend)和恢复(resume)。其实GCD中的队列也有类似的功能。用法也非常简单：</p>\n\n<pre><code class=\"language-swift\">dispatch_suspend(queue) //暂停某个队列  \ndispatch_resume(queue)  //恢复某个队列  \n</code></pre>\n\n<p>这些函数不会影响到队列中已经执行的任务，队列暂停后，已经添加到队列中但还没有执行的任务不会执行，直到队列被恢复。</p>\n\n<h3 id=\"dispathc_once\">dispathc_once</h3>\n\n<p>首先我们来看一下最简单的<code>dispathc_once</code>函数，这在单例模式中被广泛使用。</p>\n\n<ul>\n<li><font color =\"rgb(226,238,250)\"><code>dispathc_once</code></font>函数可以确保某个block在应用程序执行的过程中只被处理一次，而且它是线程安全的。所以单例模式可以很简单的实现，以OC中Manager类为例</li>\n</ul>\n\n<pre><code class=\"language-objective-c\">+ (Manager *)sharedInstance {\n    static Manager *sharedManagerInstance = nil;\n    static dispatch_once_t once;\n\n    dispatch_once($once, ^{\n        sharedManagerInstance = [[Manager alloc] init];\n    });\n\n    return sharedManagerInstance;\n}\n</code></pre>\n\n<p>这段代码中我们创建一个值为nil的<font color =\"rgb(226,238,250)\"><code>sharedManagerInstance</code></font>静态对象，然后把它的初始化代码放到<font color =\"rgb(226,238,250)\"><code>dispatch_once</code></font>中完成。</p>\n\n<p>这样，只有第一次调用<font color =\"rgb(226,238,250)\"><code>sharedInstance</code></font>方法时才会进行对象的初始化，以后每次只是返回<font color =\"rgb(226,238,250)\"><code>sharedManagerInstance</code></font>而已。</p>\n\n<h3 id=\"dispatch_barrier_async\">dispatch_barrier_async</h3>\n\n<p>我们知道数据在写入时，不能在其他线程读取或写入。但是多个线程同时读取数据是没有问题的。所以我们可以把读取任务放入并行队列，把写入任务放入串行队列，并且保证写入任务执行过程中没有读取任务可以执行。</p>\n\n<p>这样的需求比较常见，GCD提供了一个非常简单的解决办法——<font color =\"rgb(226,238,250)\"><code>dispatch_barrier_async</code></font></p>\n\n<p>假设我们有四个读取任务，在第二三个任务之间有一个写入任务，代码大概是这样：</p>\n\n<pre><code class=\"language-swift\">let queue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_CONCURRENT)\n\ndispatch_async(queue, block1_for_reading)  \ndispatch_async(queue, block2_for_reading)\n\n/*\n    这里插入写入任务，比如：\n    dispatch_async(queue, block_for_writing)\n*/\n\ndispatch_async(queue, block3_for_reading)  \ndispatch_async(queue, block4_for_reading)\n</code></pre>\n\n<p>如果代码这样写，由于这几个block是并发执行，就有可能在前两个block中读取到已经修改了的数据。如果是有多写入任务，那问题更严重，可能会有数据竞争。</p>\n\n<p>如果使用<font color =\"rgb(226,238,250)\"><code>dispatch_barrier_async</code></font>函数，代码就可以这么写：</p>\n\n<pre><code class=\"language-swift\">dispatch_async(queue, block1_for_reading)  \ndispatch_async(queue, block2_for_reading)\n\ndispatch_barrier_async(queue, block_for_writing)\n\ndispatch_async(queue, block3_for_reading)  \ndispatch_async(queue, block4_for_reading)  \n</code></pre>\n\n<p><font color =\"rgb(226,238,250)\"><code>dispatch_barrier_async</code></font>会把并行队列的运行周期分为这三个过程：</p>\n\n<ol>\n<li>首先等目前追加到并行队列中所有任务都执行完成  </li>\n<li>开始执行<font color =\"rgb(226,238,250)\"><code>dispatch_barrier_async</code></font>中的任务，这时候即使向并行队列提交任务，也不会执行  </li>\n<li><font color =\"rgb(226,238,250)\"><code>dispatch_barrier_async</code></font>中的任务执行完成后，并行队列恢复正常。</li>\n</ol>\n\n<p>总的来说，<font color =\"rgb(226,238,250)\"><code>dispatch_barrier_async</code></font>起到了“<strong>承上启下</strong>”的作用。它保证此前的任务都先于自己执行，此后的任务也迟于自己执行。正如barrier的含义一样，它起到了一个栅栏、或是分水岭的作用。</p>\n\n<p>这样一来，使用并行队列和<font color =\"rgb(226,238,250)\"><code>dispatc_barrier_async</code></font>方法，就可以高效的进行数据和文件读写了。</p>\n\n<h3 id=\"dispatch_semaphore\">dispatch_semaphore</h3>\n\n<p>首先介绍一下信号量(semaphore)的概念。信号量是持有计数的信号，不过这么解释等于没解释。我们举个生活中的例子来看看。</p>\n\n<p>假设有一个房子，它对应进程的概念，房子里的人就对应着线程。一个进程可以包括多个线程。这个房子(进程)有很多资源，比如花园、客厅等，是所有人(线程)共享的。</p>\n\n<p>但是有些地方，比如卧室，最多只有两个人能进去睡觉。怎么办呢，在卧室门口挂上两把钥匙。进去的人(线程)拿着钥匙进去，没有钥匙就不能进去，出来的时候把钥匙放回门口。</p>\n\n<p>这时候，门口的钥匙数量就称为<strong>信号量(Semaphore)</strong>。很明显，信号量为0时需要等待，信号量不为零时，减去1而且不等待。</p>\n\n<p>在GCD中，创建信号量的语法如下：</p>\n\n<pre><code class=\"language-swift\">var semaphore = dispatch_semaphore_create(2)  \n</code></pre>\n\n<p>这句代码通过<font color =\"rgb(226,238,250)\"><code>dispatch_semaphore_create</code></font>方法创建一个信号量并设置初始值为2。然后就可以调用<font color =\"rgb(226,238,250)\"><code>dispatch_semaphore_wait</code></font>方法了。</p>\n\n<pre><code class=\"language-swift\">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)  \n</code></pre>\n\n<p><font color =\"rgb(226,238,250)\"><code>dispatch_semaphore_wait</code></font>方法表示一直等待直到信号量的值大于等于一，当这个方法执行后，会把第一个信号量参数的值减1。</p>\n\n<p>第二个参数是一个<font color =\"rgb(226,238,250)\"><code>dispatch_time_t</code></font>类型的时间，它表示这个方法最大的等待时间。这在第一章中已经讲过，比如\n<font color =\"rgb(226,238,250)\"><code>DISPATCH_TIME_FOREVER</code></font>表示永久等待。</p>\n\n<p>返回值也和<font color =\"rgb(226,238,250)\"><code>dispatch_group_wait</code></font>方法一样，返回0表示在规定的等待时间内第一个参数信号量的值已经大于等于1，否则表示已超过规定等待时间，但信号量的值还是0。</p>\n\n<p><font color =\"rgb(226,238,250)\"><code>dispatch_semaphore_wait</code></font>方法返回0，因为此时的信号量的值大于等于一，任务获得了可以执行的权限。这时候我们就可以安全的执行需要进行排他控制的任务了。</p>\n\n<p>任务结束时还需要调用\n<font color =\"rgb(226,238,250)\"><code>dispatch_semaphore_signal()</code></font>方法，将信号量的值加1。这类似于之前所说的，从卧室出来要把锁放回门上，否则后来的人就无法进入了。</p>\n\n<p>我们来看一个完整的例子：</p>\n\n<pre><code class=\"language-swift\">var semaphore = dispatch_semaphore_create(1)  \nlet queue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_CONCURRENT)  \nvar array: [Int] = []\n\nfor i in 1...100000 {  \n    dispatch_async(queue, { () -&gt; Void in\n        /*\n            某个线程执行到这里，如果信号量值为1，那么wait方法返回1，开始执行接下来的操作。\n            与此同时，因为信号量变为0，其它执行到这里的线程都必须等待\n        */\n        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)\n\n        /*\n            执行了wait方法后，信号量的值变成了0。可以进行接下来的操作。\n            这时候其它线程都得等待wait方法返回。\n            可以对array修改的线程在任意时刻都只有一个，可以安全的修改array\n        */\n        array.append(i)\n\n        /*\n            排他操作执行结束，记得要调用signal方法，把信号量的值加1。\n            这样，如果有别的线程在等待wait函数返回，就由最先等待的线程执行。\n        */\n        dispatch_semaphore_signal(semaphore)\n    })\n}\n</code></pre>\n\n<p>如果你想知道不用信号量会出什么问题，可以看我的另一篇文章<a href=\"http://115.159.123.174/swiftarrayappend/\">Swift数组append方法研究</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T07:16:14.000Z","created_by":1,"updated_at":"2016-01-14T08:03:32.000Z","updated_by":1,"published_at":"2015-12-06T07:35:00.000Z","published_by":1},{"id":4,"uuid":"f33ab947-dc99-42d3-b104-f1427e37a08e","title":"找数组中出现次数超过一半的数字","slug":"arrayoccurmorethanhalf","markdown":"数组中有一个数字出现次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组`{1,2,3,2,2,2,5,4,2}`。\n\n由于数字2在数组中出现了5次，超过数组长度一半，因此输出2\n\n#问题分析\n\n首先想到的是，可以维护一个数据结构用来存储每个数字对应的出现次数。没遇到一个新的数字就去找这个数字是否出现过，如果出现过就加1.这种思路最简单，但是时间复杂度是O(n^2)。\n\n稍做优化，可以把数组排序，然后中位数一定是要找的数。这样的时间复杂度是O(nlogn)\n\n还可以再试着优化，第一种方法之所以需要O(n^2)的时间复杂度是因为找一个数是否已经出现过，需要O（n）的时间复杂度，拿能不能用Hash呢。很不幸的是也不行，因为不知道数字的取值范围，无法构造hash函数。否则的话，也不用hash，直接基数排序就解决问题了。\n\n似乎最快的算法就是排序的O（nlogn）了。如果还想优化，关键在于利用“**出现次数超过一半**”这个条件的数学性质。\n\n#理论基础\n\n为了后面的解释，我们首先定义：\n\n> 对于数组A，出现次数超过一半的数记为H(A)\n\n还是以之前的数组A`{1,2,3,2,2,2,5,4,2}`为例,首先有H(A) = 2，我们观察一下这个2的特点：\n\n如果把前两个数`1`和`2`去掉，剩下的数组A'是`{3,2,2,2,5,4,2}`，H(A')依然为2！\n\n更进一步，我们可以这么想，既然前两个数去掉之后不影响找出现次数超过数组长度的一半的数字，那么任意去掉相邻的两个数字也不影响呢。\n\n也就是说对于任意数组A和A去掉两个相邻数字的子数组A'是否都有:`H(A) = H(A')`\n\n很不幸，这个结论也不成立，因为如果在刚刚的数组A中去掉连续的两个2，就不对了。但是只要稍稍把结论修改一下就是成立的：\n\n> 对于任意数组A，去掉A中任意两个相邻但不相等的数，得到数组A',总有`H(A) = H(A')`\n\n结论很好证明：设H(A) = p,去掉的两个数中最多有一个p，由于p原来出现的次数大于n/2，现在p-1自然一定大于(n-2)/2。所以`H（A'）= p`。\n\n#编程实现\n\n有了刚刚的结论，再看这个数组就简单多了。只要把数组从头到尾遍历一遍，剔除相邻的不同的数就可以。比如数组中有一段是`{1，2，3，4}`，可以预见到，有可能是`{2，3}`先被比较，然后被剔除，接着是`{1，4}`变成相邻的，接着被剔除。\n\n为了避免反复循环，在一个循环里解决问题，自然而然的想到了一个数据结构——“栈”。\n\n只要对于数组中的每一个元素，如果栈为空或这个元素与栈顶元素相同，则这个元素入栈，否则栈顶元素出栈即可。这样一来，不相同的数即使不相邻，迟早也会一起出栈（可以把用来和栈顶做比较元素想象为先入栈再出栈）。\n\n所以这样一来，代码会非常简洁优雅：\n\n\n```C++\nint findNumber(std::vector<int> v){\n    std::stack<int> stack = std::stack<int>();\n    for (int i = 0; i < v.size(); ++i) {\n        if (stack.empty() || stack.top() == v[i]) {\n            stack.push(v[i]);\n        }\n        else{\n            stack.pop();\n        }\n    }\n    return stack.top();\n}\n```\n\n#正确性证明\n\n对于H(A)这个数来说，它想要出栈的唯一可能是遇到一个和它不同的数（之前说过，如果把H(A)和与它不同栈顶元素比较，可以理解为H(A)先进栈再出栈）。\n\n而在数组A中，剩下所有的数出现次数的和一定小于H(A)出现的次数。所以最终的栈里一定只剩下若干个H(A)。\n\n#拓展1——判断是否存在这样的数\n\n之前我们都是基于题干所说的，出现次数超过一半的数是存在的，这一前提进行分析。如果把题干改为：\n> 判断出现次数超过一半的数是否存在，如果存在则找出这个数\n\n这时候，我们依然用同样的方法先得到之前所说的栈。这个栈如果为空，则H(A)不存在（因为已经证明H(A)存在的话栈中的数都等于H(A)）。如果不为空，也只有可能有一种数字，不妨记为x。\n\nx不一定是要找的H(A)，因为H(A)不一定存在。我们只能说如果H(A)存在的话，`x = H(A)`。所以只要重新遍历数组，看看x的出现次数是否超过n/2即可。\n\n#拓展2——不少于一半\n\n看到一个非常有意思的问题，即把题干改为找到出现次数不少于一半的数。其实非常简单的方法是判断数组的第一个元素是否满足要求。如果不满足的话，剩下的n-1个数构成数组A'，则H(A')就是要找的数。相当于划归为了之前已经解决的问题。","html":"<p>数组中有一个数字出现次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组<code>{1,2,3,2,2,2,5,4,2}</code>。</p>\n\n<p>由于数字2在数组中出现了5次，超过数组长度一半，因此输出2</p>\n\n<h1 id=\"\">问题分析</h1>\n\n<p>首先想到的是，可以维护一个数据结构用来存储每个数字对应的出现次数。没遇到一个新的数字就去找这个数字是否出现过，如果出现过就加1.这种思路最简单，但是时间复杂度是O(n^2)。</p>\n\n<p>稍做优化，可以把数组排序，然后中位数一定是要找的数。这样的时间复杂度是O(nlogn)</p>\n\n<p>还可以再试着优化，第一种方法之所以需要O(n^2)的时间复杂度是因为找一个数是否已经出现过，需要O（n）的时间复杂度，拿能不能用Hash呢。很不幸的是也不行，因为不知道数字的取值范围，无法构造hash函数。否则的话，也不用hash，直接基数排序就解决问题了。</p>\n\n<p>似乎最快的算法就是排序的O（nlogn）了。如果还想优化，关键在于利用“<strong>出现次数超过一半</strong>”这个条件的数学性质。</p>\n\n<h1 id=\"\">理论基础</h1>\n\n<p>为了后面的解释，我们首先定义：</p>\n\n<blockquote>\n  <p>对于数组A，出现次数超过一半的数记为H(A)</p>\n</blockquote>\n\n<p>还是以之前的数组A<code>{1,2,3,2,2,2,5,4,2}</code>为例,首先有H(A) = 2，我们观察一下这个2的特点：</p>\n\n<p>如果把前两个数<code>1</code>和<code>2</code>去掉，剩下的数组A'是<code>{3,2,2,2,5,4,2}</code>，H(A')依然为2！</p>\n\n<p>更进一步，我们可以这么想，既然前两个数去掉之后不影响找出现次数超过数组长度的一半的数字，那么任意去掉相邻的两个数字也不影响呢。</p>\n\n<p>也就是说对于任意数组A和A去掉两个相邻数字的子数组A'是否都有:<code>H(A) = H(A')</code></p>\n\n<p>很不幸，这个结论也不成立，因为如果在刚刚的数组A中去掉连续的两个2，就不对了。但是只要稍稍把结论修改一下就是成立的：</p>\n\n<blockquote>\n  <p>对于任意数组A，去掉A中任意两个相邻但不相等的数，得到数组A',总有<code>H(A) = H(A')</code></p>\n</blockquote>\n\n<p>结论很好证明：设H(A) = p,去掉的两个数中最多有一个p，由于p原来出现的次数大于n/2，现在p-1自然一定大于(n-2)/2。所以<code>H（A'）= p</code>。</p>\n\n<h1 id=\"\">编程实现</h1>\n\n<p>有了刚刚的结论，再看这个数组就简单多了。只要把数组从头到尾遍历一遍，剔除相邻的不同的数就可以。比如数组中有一段是<code>{1，2，3，4}</code>，可以预见到，有可能是<code>{2，3}</code>先被比较，然后被剔除，接着是<code>{1，4}</code>变成相邻的，接着被剔除。</p>\n\n<p>为了避免反复循环，在一个循环里解决问题，自然而然的想到了一个数据结构——“栈”。</p>\n\n<p>只要对于数组中的每一个元素，如果栈为空或这个元素与栈顶元素相同，则这个元素入栈，否则栈顶元素出栈即可。这样一来，不相同的数即使不相邻，迟早也会一起出栈（可以把用来和栈顶做比较元素想象为先入栈再出栈）。</p>\n\n<p>所以这样一来，代码会非常简洁优雅：</p>\n\n<pre><code class=\"language-C++\">int findNumber(std::vector&lt;int&gt; v){  \n    std::stack&lt;int&gt; stack = std::stack&lt;int&gt;();\n    for (int i = 0; i &lt; v.size(); ++i) {\n        if (stack.empty() || stack.top() == v[i]) {\n            stack.push(v[i]);\n        }\n        else{\n            stack.pop();\n        }\n    }\n    return stack.top();\n}\n</code></pre>\n\n<h1 id=\"\">正确性证明</h1>\n\n<p>对于H(A)这个数来说，它想要出栈的唯一可能是遇到一个和它不同的数（之前说过，如果把H(A)和与它不同栈顶元素比较，可以理解为H(A)先进栈再出栈）。</p>\n\n<p>而在数组A中，剩下所有的数出现次数的和一定小于H(A)出现的次数。所以最终的栈里一定只剩下若干个H(A)。</p>\n\n<h1 id=\"1\">拓展1——判断是否存在这样的数</h1>\n\n<p>之前我们都是基于题干所说的，出现次数超过一半的数是存在的，这一前提进行分析。如果把题干改为：</p>\n\n<blockquote>\n  <p>判断出现次数超过一半的数是否存在，如果存在则找出这个数</p>\n</blockquote>\n\n<p>这时候，我们依然用同样的方法先得到之前所说的栈。这个栈如果为空，则H(A)不存在（因为已经证明H(A)存在的话栈中的数都等于H(A)）。如果不为空，也只有可能有一种数字，不妨记为x。</p>\n\n<p>x不一定是要找的H(A)，因为H(A)不一定存在。我们只能说如果H(A)存在的话，<code>x = H(A)</code>。所以只要重新遍历数组，看看x的出现次数是否超过n/2即可。</p>\n\n<h1 id=\"2\">拓展2——不少于一半</h1>\n\n<p>看到一个非常有意思的问题，即把题干改为找到出现次数不少于一半的数。其实非常简单的方法是判断数组的第一个元素是否满足要求。如果不满足的话，剩下的n-1个数构成数组A'，则H(A')就是要找的数。相当于划归为了之前已经解决的问题。</p>","image":"http://7xonij.com1.z0.glb.clouddn.com/ghost/1/e3/7161ecc907a4ee5f13214f2cac9d4.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-11T15:08:45.000Z","created_by":1,"updated_at":"2016-01-14T07:59:53.000Z","updated_by":1,"published_at":"2015-11-28T15:09:00.000Z","published_by":1},{"id":6,"uuid":"ecc94650-1518-4557-8462-23d908e21a1e","title":"Swift数组扩容原理","slug":"swiftarrayappend","markdown":"#结论\n\n首先把结论写在文章开头，因为接下来的分析会有些啰嗦、复杂，如果不愿意深究的话只要记住Swift中数组扩容的原理是：\n\n> Swift2中创建一个空数组，默认容量为2，当长度和容量相等，且还需要再添加元素时，创建一个两倍长度于旧数组的新数组，把旧数组的元素拷贝过来，再把元素插入到新数组中。\n\n\n#引子\n\n下面这段代码希望通过多线程技术，加速向数组中添加数字这个过程，我们来看看它有什么问题：\n\n```swift\nvar array: [Int] = []\nlet concurrentQueue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_CONCURRENT)\n\nfor i in 1...10000 {\n\tdispatch_async(concurrentQueue, { () -> Void in\n\t\tarray.append(i)\n\t})\n}\n```\n\n代码很简短，看上去问题不大。不过如果你运行完这段代码而且程序没有崩溃，我强烈建议买一份彩票，因为你的运气已经好到逆天了。\n\n<!--more-->\n\n通常情况下，你会遇到这样的报错\n> fatal error: UnsafeMutablePointer.destroy with negative count\n\n#Append方法实现\n\n程序会断在`array.append(i)`这一行。也就是<font color = \"rgb(226,238,250)\">`append `</font>方法出了问题。我们知道Swift里的数组不像C语言，不需要提前定义好长度，更像是C++的<font color = \"rgb(226,238,250)\">`vector`</font>和OC的<font color = \"rgb(226,238,250)\">`NSMutableArray`</font>。\n\n所以，会不会是数组的可变性，导致了<font color = \"rgb(226,238,250)\">`append`</font>方法是线程不安全的呢，带着这样的猜想，我们来研究一下Swift是如何实现Append方法的。\n\nSwift已经开源了，github上[相关源码](https://github.com/apple/apple)已经可以下载。\n\n虽然明知道有些文件夹不会包含append方法的实现源码，但真想找到也不容易。如果你试着搜索\"append\"的话，相关文件非常多，因为\"append\"本身就是一个非常常用的单词。我采取的办法是搜索完整的函数定义，而函数定义是我们很容易看到的。\n\n当我们搜索\"mutating func append(newElement: Element)\"后，就只有六个相关文件了。如图所示:\n\n![搜索结果](http://7xonij.com1.z0.glb.clouddn.com/Swift_append/search_result.png)\n\n前三个文件无法直接打开，暂时先不管。其实第三个一看也知道是单元测试文件。第六个是字符串，也不是我们感兴趣的。所以我们依次打开\"ArrayType.swift\"和\"RangeReplaceableCollectionType.swift\"这两个文件。\n\n> 提示：这两个文件的目录都是\"/swift/stdlib/public/core\"\n\n遗憾的是，ArrayType.swift文件中没有找到相关函数，RangeReplaceableCollectionType.swift文件倒是有一个<font color = \"rgb(226,238,250)\">`append`</font>方法，不过参数类型对不上。于是我想到第一个文件——\"Arrays.swift.gyb\"，去掉gyb后缀后果然可以打开了。并且成功的找到了我们感兴趣的<font color = \"rgb(226,238,250)\">`append`</font>方法：\n\n\n```swift\npublic mutating func append(newElement: Element) {\n\t_makeUniqueAndReserveCapacityIfNotUnique()\n\tlet oldCount = _getCount()\n\t_reserveCapacityAssumingUniqueBuffer(oldCount)\n\t_appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)\n}\n```\n\n#源码分析\n\n代码不长，我们逐行看一下\n\n* 第一行的函数，看名字表示，如果这个数组不是惟一的，就把它变成惟一的，而且保留数组容量。在Xcode里面搜索一下这个函数：\n\n```swift\ninternal mutating func _makeUniqueAndReserveCapacityIfNotUnique() {\n\tif _slowPath(!_buffer.isMutableAndUniquelyReferenced()) {\n\t\t_copyToNewBuffer(_buffer.count)\n\t}\n}\n```\n\n这个函数会进行一个判断判断——如果数组不是被唯一引用的，就会复制一份新的。这其实就是“**写时赋值(copy-on-write)**”技术。如果你想了解它的具体使用，可以参考我的这篇文章——[《\b第二章——集合（数组与可变性）》](http://www.jianshu.com/p/21d518da46ed)\n\n不过对于文章开头那个例子的数组来说，它肯定是唯一引用的。所以<font color = \"rgb(226,238,250)\">`_copyToNewBuffer `</font>函数不会调用，我们先记下这个方法。然后回到<font color = \"rgb(226,238,250)\">`append `</font>方法继续研究。\n\n* 第二行用一个变量<font color = \"rgb(226,238,250)\">`oldCount`</font>保存数组当前长度。\n\n* 第三行的函数表示，在假设当前数组是唯一引用的前提下，保留数组容量。之所以做出这样的假设，是因为此前已经调用过<font color = \"rgb(226,238,250)\">`_makeUniqueAndReserveCapacityIfNotUnique `</font>方法，即使这个数组不是唯一引用，也被复制了一份新的。我们来看看<font color = \"rgb(226,238,250)\">`_reserveCapacityAssumingUniqueBuffer `</font>方法的实现：\n\n```swift\ninternal mutating func _reserveCapacityAssumingUniqueBuffer(oldCount : Int) {\n\t_sanityCheck(_buffer.isMutableAndUniquelyReferenced())\n\n\tif _slowPath(oldCount + 1 > _buffer.capacity) {\n\t\t_copyToNewBuffer(oldCount)\n\t}\n}\n```\n\n\t\n第一行有一个<font color = \"rgb(226,238,250)\">`_sanityCheck `</font>来判断数组是否可变且唯一引用。\"sanity\"说明这个判断是符合常理的，虽然它很有可能并没有效果，但也是为了确保万无一失。\n\n下面还有一个判断，检查当前数组长度加一后是否大于数组容量。如果判断成立，说明`oldCount == _buffer.capacity`，在实际编程中，就意味着数组需要扩容了。可以看到又会执行刚刚提到过的<font color = \"rgb(226,238,250)\">`_copyToNewBuffer `</font>函数。我们还是先把这个函数放一放，接着往后看。\n\n\n* 最后一行的函数表示，假设数组是唯一引用的，且数组容量也设置正确，把新的元素添加到数组中。这其实是真正执行了“append”操作的地方。它的实现如下：\n\n```swift\ninternal mutating func _appendElementAssumeUniqueAndCapacity(\n    oldCount : Int,\n    newElement : Element) {\n    \n\t_sanityCheck(_buffer.isMutableAndUniquelyReferenced())\n\t_sanityCheck(_buffer.capacity >= _buffer.count + 1)\n\n\t_buffer.count = oldCount + 1\n\t(_buffer.firstElementAddress + oldCount).initialize(newElement)\n}\n```\n\n首先是两个基本判断，然后把<font color = \"rgb(226,238,250)\">`count `</font>属性加一，最后获取到将要添加的位置的地址，用一个新的值初始化它。\n\n\nOK，<font color = \"rgb(226,238,250)\">`append`</font>方法的结构基本上了解了，首先会保证数组是唯一引用的，然后处理数组的容量问题，最后把待插入的元素放到指定位置上。其中最关键，也是目前还没有彻底明白的一步，就是之前所说的<font color = \"rgb(226,238,250)\">`_copyToNewBuffer `</font>函数了\n\n#copyToNewBuffer\n\n先来看看<font color = \"rgb(226,238,250)\">`copyToNewBuffer`</font>函数的实现：\n\n```swift\ninternal mutating func _copyToNewBuffer(oldCount: Int) {\n\tlet newCount = oldCount + 1\n\tvar newBuffer = Optional(\n\t_forceCreateUniqueMutableBuffer(\n\t\t&_buffer, countForNewBuffer: oldCount, minNewCapacity: newCount))\n\t_arrayOutOfPlaceUpdate(\n\t\t&_buffer, &newBuffer, oldCount, 0, _IgnorePointer())\n\t}\n```\n\n这个方法又分为两步，<font color = \"rgb(226,238,250)\">`_forceCreateUniqueMutableBuffer `</font>和<font color = \"rgb(226,238,250)\">`_arrayOutOfPlaceUpdate `</font>。前者实现了新存储区域的创建，而后者完成了数据的复制工作。\n\n为了简单起见，我们先看看<font color = \"rgb(226,238,250)\">`_arrayOutOfPlaceUpdate `</font>函数,这个函数的实现太长了，不过好在有注释：\n\n```swift\n/// Initialize the elements of dest by copying the first headCount\n/// items from source, calling initializeNewElements on the next\n/// uninitialized element, and finally by copying the last N items\n/// from source into the N remaining uninitialized elements of dest.\n///\n/// As an optimization, may move elements out of source rather than\n/// copying when it isUniquelyReferenced.\n```\n\n大意是说，源数组中已存在的元素会被复制到目标数组中，如果新数组比较长，空缺部分会调用<font color = \"rgb(226,238,250)\">`initializeNewElements `</font>方法来初始化。为了优化性能，被唯一引用的元素可能会直接从源数组移到新数组而不是复制。其实就是换了一个指针指向那个元素，从而避免了复制。\n\n接下来我们再研究一下比较关键的<font color = \"rgb(226,238,250)\">`_forceCreateUniqueMutableBuffer `</font>部分，也就是数组是怎样扩容的：\n\n```swift\n@inline(never)\nfunc _forceCreateUniqueMutableBuffer<_Buffer : _ArrayBufferType>(\n\tinout source: _Buffer,  countForNewBuffer: Int,  minNewCapacity: Int\n\t) -> _ContiguousArrayBuffer<_Buffer.Element> {\n\t\n\t//其实什么也没干，多加了一个参数就转发给 _forceCreateUniqueMutableBufferImpl了\n  \treturn _forceCreateUniqueMutableBufferImpl(\n\t\t&source, countForBuffer: countForNewBuffer, minNewCapacity: minNewCapacity,\n\t\trequiredCapacity: minNewCapacity)\n}\n\ninternal func _forceCreateUniqueMutableBufferImpl<_Buffer : _ArrayBufferType>(\n  inout source: _Buffer,  countForBuffer: Int, minNewCapacity: Int,\n  requiredCapacity: Int\n) -> _ContiguousArrayBuffer<_Buffer.Element> {\n\t_sanityCheck(countForBuffer >= 0)\n  \t_sanityCheck(requiredCapacity >= countForBuffer)\n  \t_sanityCheck(minNewCapacity >= countForBuffer)\n\n  \tlet minimumCapacity = max(\n\trequiredCapacity, minNewCapacity > source.capacity\n\t\t? _growArrayCapacity(source.capacity) : source.capacity)\n\n\treturn _ContiguousArrayBuffer(\n\t\tcount: countForBuffer, minimumCapacity: minimumCapacity)\n}\n```\n\n<font color = \"rgb(226,238,250)\">`_forceCreateUniqueMutableBufferImpl `</font>函数刚开始的三个检查读者可以自行理解，关键部分在于<font color = \"rgb(226,238,250)\">`minimumCapacity `</font>的计算。因为它会作为容量参数被传到用于创建新的Buffer的函数中。\n\n这个函数有四个参数，第一个参数buffer可以理解为数组中真正用于数据存放的那个部分。对于最后两个参数，意思有点像，我们不妨考虑一个实际的、需要进行数组扩容的情况，向一个容量为3，长度为3的数组新增一个元素1，此时函数的调用顺序如下：\n\n\n1. <font color = \"rgb(226,238,250)\">`append(1)`</font>\n2. <font color = \"rgb(226,238,250)\">`_reserveCapacityAssumingUniqueBuffer(3)`</font>\n3. <font color = \"rgb(226,238,250)\">`_copyToNewBuffer(3)`</font>\n4. <font color = \"rgb(226,238,250)\">`_forceCreateUniqueMutableBuffer(&_buffer, countForNewBuffer: 3, minNewCapacity: 4)`</font>\n5. <font color = \"rgb(226,238,250)\">`_forceCreateUniqueMutableBufferImpl(&_buffer, countForBuffer: 3, minNewCapacity: 4, requiredCapacity: 4)`</font>\n        \n还记得<font color = \"rgb(226,238,250)\">`_copyToNewBuffer()`</font>方法里的`let newCount = oldCount + 1`么，所以<font color = \"rgb(226,238,250)\">`oldCount(=3)`</font>作为<font color = \"rgb(226,238,250)\">`minNewCapacity `</font>，而<font color = \"rgb(226,238,250)\">`newCount(=4)`</font>作为<font color = \"rgb(226,238,250)\">`requiredCapacity `</font>参数被传入<font color = \"rgb(226,238,250)\">`_forceCreateUniqueMutableBufferImpl `</font>方法。\n\n此时，<font color = \"rgb(226,238,250)\">`minimumCapacity`</font>的计算，其实就是以下表达式的值：\n\n```swift\nmax(4, 4 > 3 ? _growArrayCapacity(3) : 3)\n```\n\n我们知道，如果数组需要扩容，<font color = \"rgb(226,238,250)\">`source.capacity`</font>总是等于<font color = \"rgb(226,238,250)\">`minNewCapacity `</font>的。也就是说上式可以写为：\n\n```swift\nmax(length+1, length+1 > length ? _growArrayCapacity(length) : length)\n\n//等价于\nmax(length+1, _growArrayCapacity(length))\n```\n\n可以看到<font color = \"rgb(226,238,250)\">`_growArrayCapacity `</font>返回值是传入参数的两倍：\n\n```swift\n@warn_unused_result\ninternal func _growArrayCapacity(capacity: Int) -> Int {\n  return capacity * 2\n}\n```\n\n所以<font color = \"rgb(226,238,250)\">`minimumCapacity`</font> = <font color = \"rgb(226,238,250)\">`max(length+1, 2 * length)`</font> = <font color = \"rgb(226,238,250)\">`2 * length`</font>。也就是新扩容的数组长度其实翻倍了。\n\n#线程安全\n\n现在我们可以理解为什么<font color = \"rgb(226,238,250)\">`append`</font>方法不是线程安全的了。如果在某一个线程中插入新元素，导致了数组扩容，那么Swift会创建一个新的数组（意味着地址完全不同）。然后ARC会为我们自动释放旧的数组，但这时候可能另一个线程还在访问旧的数组对象。\n\n#验证\n\n说了这么多，我们来证明一下Swift数组扩容的工作原理：\n\n```swift\nlet semaphore = dispatch_semaphore_create(1)\nvar array: [Int] = []\nfor i in 1...100000 {\n\tarray.append(i)\n\tlet arrayPtr = UnsafeMutableBufferPointer<Int>(start: &array, count: array.count)\n\tprint(arrayPtr)\n}\n```\n\n运行结果如下，可以验证文章开头的结论：“初始容量为2，扩容时容量翻倍”\n\n![容量翻倍](http://7xonij.com1.z0.glb.clouddn.com/Swift_append/double.png)","html":"<h1 id=\"\">结论</h1>\n\n<p>首先把结论写在文章开头，因为接下来的分析会有些啰嗦、复杂，如果不愿意深究的话只要记住Swift中数组扩容的原理是：</p>\n\n<blockquote>\n  <p>Swift2中创建一个空数组，默认容量为2，当长度和容量相等，且还需要再添加元素时，创建一个两倍长度于旧数组的新数组，把旧数组的元素拷贝过来，再把元素插入到新数组中。</p>\n</blockquote>\n\n<h1 id=\"\">引子</h1>\n\n<p>下面这段代码希望通过多线程技术，加速向数组中添加数字这个过程，我们来看看它有什么问题：</p>\n\n<pre><code class=\"language-swift\">var array: [Int] = []  \nlet concurrentQueue = dispatch_queue_create(\"com.gcd.kt\", DISPATCH_QUEUE_CONCURRENT)\n\nfor i in 1...10000 {  \n    dispatch_async(concurrentQueue, { () -&gt; Void in\n        array.append(i)\n    })\n}\n</code></pre>\n\n<p>代码很简短，看上去问题不大。不过如果你运行完这段代码而且程序没有崩溃，我强烈建议买一份彩票，因为你的运气已经好到逆天了。</p>\n\n<!--more-->\n\n<p>通常情况下，你会遇到这样的报错</p>\n\n<blockquote>\n  <p>fatal error: UnsafeMutablePointer.destroy with negative count</p>\n</blockquote>\n\n<h1 id=\"append\">Append方法实现</h1>\n\n<p>程序会断在<code>array.append(i)</code>这一行。也就是<font color = \"rgb(226,238,250)\"><code>append</code></font>方法出了问题。我们知道Swift里的数组不像C语言，不需要提前定义好长度，更像是C++的<font color = \"rgb(226,238,250)\"><code>vector</code></font>和OC的<font color = \"rgb(226,238,250)\"><code>NSMutableArray</code></font>。</p>\n\n<p>所以，会不会是数组的可变性，导致了<font color = \"rgb(226,238,250)\"><code>append</code></font>方法是线程不安全的呢，带着这样的猜想，我们来研究一下Swift是如何实现Append方法的。</p>\n\n<p>Swift已经开源了，github上<a href=\"https://github.com/apple/apple\">相关源码</a>已经可以下载。</p>\n\n<p>虽然明知道有些文件夹不会包含append方法的实现源码，但真想找到也不容易。如果你试着搜索\"append\"的话，相关文件非常多，因为\"append\"本身就是一个非常常用的单词。我采取的办法是搜索完整的函数定义，而函数定义是我们很容易看到的。</p>\n\n<p>当我们搜索\"mutating func append(newElement: Element)\"后，就只有六个相关文件了。如图所示:</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Swift_append/search_result.png\" alt=\"搜索结果\" /></p>\n\n<p>前三个文件无法直接打开，暂时先不管。其实第三个一看也知道是单元测试文件。第六个是字符串，也不是我们感兴趣的。所以我们依次打开\"ArrayType.swift\"和\"RangeReplaceableCollectionType.swift\"这两个文件。</p>\n\n<blockquote>\n  <p>提示：这两个文件的目录都是\"/swift/stdlib/public/core\"</p>\n</blockquote>\n\n<p>遗憾的是，ArrayType.swift文件中没有找到相关函数，RangeReplaceableCollectionType.swift文件倒是有一个<font color = \"rgb(226,238,250)\"><code>append</code></font>方法，不过参数类型对不上。于是我想到第一个文件——\"Arrays.swift.gyb\"，去掉gyb后缀后果然可以打开了。并且成功的找到了我们感兴趣的<font color = \"rgb(226,238,250)\"><code>append</code></font>方法：</p>\n\n<pre><code class=\"language-swift\">public mutating func append(newElement: Element) {  \n    _makeUniqueAndReserveCapacityIfNotUnique()\n    let oldCount = _getCount()\n    _reserveCapacityAssumingUniqueBuffer(oldCount)\n    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)\n}\n</code></pre>\n\n<h1 id=\"\">源码分析</h1>\n\n<p>代码不长，我们逐行看一下</p>\n\n<ul>\n<li>第一行的函数，看名字表示，如果这个数组不是惟一的，就把它变成惟一的，而且保留数组容量。在Xcode里面搜索一下这个函数：</li>\n</ul>\n\n<pre><code class=\"language-swift\">internal mutating func _makeUniqueAndReserveCapacityIfNotUnique() {  \n    if _slowPath(!_buffer.isMutableAndUniquelyReferenced()) {\n        _copyToNewBuffer(_buffer.count)\n    }\n}\n</code></pre>\n\n<p>这个函数会进行一个判断判断——如果数组不是被唯一引用的，就会复制一份新的。这其实就是“<strong>写时赋值(copy-on-write)</strong>”技术。如果你想了解它的具体使用，可以参考我的这篇文章——<a href=\"http://www.jianshu.com/p/21d518da46ed\">《\b第二章——集合（数组与可变性）》</a></p>\n\n<p>不过对于文章开头那个例子的数组来说，它肯定是唯一引用的。所以<font color = \"rgb(226,238,250)\"><code>_copyToNewBuffer</code></font>函数不会调用，我们先记下这个方法。然后回到<font color = \"rgb(226,238,250)\"><code>append</code></font>方法继续研究。</p>\n\n<ul>\n<li><p>第二行用一个变量<font color = \"rgb(226,238,250)\"><code>oldCount</code></font>保存数组当前长度。</p></li>\n<li><p>第三行的函数表示，在假设当前数组是唯一引用的前提下，保留数组容量。之所以做出这样的假设，是因为此前已经调用过<font color = \"rgb(226,238,250)\"><code>_makeUniqueAndReserveCapacityIfNotUnique</code></font>方法，即使这个数组不是唯一引用，也被复制了一份新的。我们来看看<font color = \"rgb(226,238,250)\"><code>_reserveCapacityAssumingUniqueBuffer</code></font>方法的实现：</p></li>\n</ul>\n\n<pre><code class=\"language-swift\">internal mutating func _reserveCapacityAssumingUniqueBuffer(oldCount : Int) {  \n    _sanityCheck(_buffer.isMutableAndUniquelyReferenced())\n\n    if _slowPath(oldCount + 1 &gt; _buffer.capacity) {\n        _copyToNewBuffer(oldCount)\n    }\n}\n</code></pre>\n\n<p>第一行有一个<font color = \"rgb(226,238,250)\"><code>_sanityCheck</code></font>来判断数组是否可变且唯一引用。\"sanity\"说明这个判断是符合常理的，虽然它很有可能并没有效果，但也是为了确保万无一失。</p>\n\n<p>下面还有一个判断，检查当前数组长度加一后是否大于数组容量。如果判断成立，说明<code>oldCount == _buffer.capacity</code>，在实际编程中，就意味着数组需要扩容了。可以看到又会执行刚刚提到过的<font color = \"rgb(226,238,250)\"><code>_copyToNewBuffer</code></font>函数。我们还是先把这个函数放一放，接着往后看。</p>\n\n<ul>\n<li>最后一行的函数表示，假设数组是唯一引用的，且数组容量也设置正确，把新的元素添加到数组中。这其实是真正执行了“append”操作的地方。它的实现如下：</li>\n</ul>\n\n<pre><code class=\"language-swift\">internal mutating func _appendElementAssumeUniqueAndCapacity(  \n    oldCount : Int,\n    newElement : Element) {\n\n    _sanityCheck(_buffer.isMutableAndUniquelyReferenced())\n    _sanityCheck(_buffer.capacity &gt;= _buffer.count + 1)\n\n    _buffer.count = oldCount + 1\n    (_buffer.firstElementAddress + oldCount).initialize(newElement)\n}\n</code></pre>\n\n<p>首先是两个基本判断，然后把<font color = \"rgb(226,238,250)\"><code>count</code></font>属性加一，最后获取到将要添加的位置的地址，用一个新的值初始化它。</p>\n\n<p>OK，<font color = \"rgb(226,238,250)\"><code>append</code></font>方法的结构基本上了解了，首先会保证数组是唯一引用的，然后处理数组的容量问题，最后把待插入的元素放到指定位置上。其中最关键，也是目前还没有彻底明白的一步，就是之前所说的<font color = \"rgb(226,238,250)\"><code>_copyToNewBuffer</code></font>函数了</p>\n\n<h1 id=\"copytonewbuffer\">copyToNewBuffer</h1>\n\n<p>先来看看<font color = \"rgb(226,238,250)\"><code>copyToNewBuffer</code></font>函数的实现：</p>\n\n<pre><code class=\"language-swift\">internal mutating func _copyToNewBuffer(oldCount: Int) {  \n    let newCount = oldCount + 1\n    var newBuffer = Optional(\n    _forceCreateUniqueMutableBuffer(\n        &amp;_buffer, countForNewBuffer: oldCount, minNewCapacity: newCount))\n    _arrayOutOfPlaceUpdate(\n        &amp;_buffer, &amp;newBuffer, oldCount, 0, _IgnorePointer())\n    }\n</code></pre>\n\n<p>这个方法又分为两步，<font color = \"rgb(226,238,250)\"><code>_forceCreateUniqueMutableBuffer</code></font>和<font color = \"rgb(226,238,250)\"><code>_arrayOutOfPlaceUpdate</code></font>。前者实现了新存储区域的创建，而后者完成了数据的复制工作。</p>\n\n<p>为了简单起见，我们先看看<font color = \"rgb(226,238,250)\"><code>_arrayOutOfPlaceUpdate</code></font>函数,这个函数的实现太长了，不过好在有注释：</p>\n\n<pre><code class=\"language-swift\">/// Initialize the elements of dest by copying the first headCount\n/// items from source, calling initializeNewElements on the next\n/// uninitialized element, and finally by copying the last N items\n/// from source into the N remaining uninitialized elements of dest.\n///\n/// As an optimization, may move elements out of source rather than\n/// copying when it isUniquelyReferenced.\n</code></pre>\n\n<p>大意是说，源数组中已存在的元素会被复制到目标数组中，如果新数组比较长，空缺部分会调用<font color = \"rgb(226,238,250)\"><code>initializeNewElements</code></font>方法来初始化。为了优化性能，被唯一引用的元素可能会直接从源数组移到新数组而不是复制。其实就是换了一个指针指向那个元素，从而避免了复制。</p>\n\n<p>接下来我们再研究一下比较关键的<font color = \"rgb(226,238,250)\"><code>_forceCreateUniqueMutableBuffer</code></font>部分，也就是数组是怎样扩容的：</p>\n\n<pre><code class=\"language-swift\">@inline(never)\nfunc _forceCreateUniqueMutableBuffer&lt;_Buffer : _ArrayBufferType&gt;(  \n    inout source: _Buffer,  countForNewBuffer: Int,  minNewCapacity: Int\n    ) -&gt; _ContiguousArrayBuffer&lt;_Buffer.Element&gt; {\n\n    //其实什么也没干，多加了一个参数就转发给 _forceCreateUniqueMutableBufferImpl了\n      return _forceCreateUniqueMutableBufferImpl(\n        &amp;source, countForBuffer: countForNewBuffer, minNewCapacity: minNewCapacity,\n        requiredCapacity: minNewCapacity)\n}\n\ninternal func _forceCreateUniqueMutableBufferImpl&lt;_Buffer : _ArrayBufferType&gt;(  \n  inout source: _Buffer,  countForBuffer: Int, minNewCapacity: Int,\n  requiredCapacity: Int\n) -&gt; _ContiguousArrayBuffer&lt;_Buffer.Element&gt; {\n    _sanityCheck(countForBuffer &gt;= 0)\n      _sanityCheck(requiredCapacity &gt;= countForBuffer)\n      _sanityCheck(minNewCapacity &gt;= countForBuffer)\n\n      let minimumCapacity = max(\n    requiredCapacity, minNewCapacity &gt; source.capacity\n        ? _growArrayCapacity(source.capacity) : source.capacity)\n\n    return _ContiguousArrayBuffer(\n        count: countForBuffer, minimumCapacity: minimumCapacity)\n}\n</code></pre>\n\n<p><font color = \"rgb(226,238,250)\"><code>_forceCreateUniqueMutableBufferImpl</code></font>函数刚开始的三个检查读者可以自行理解，关键部分在于<font color = \"rgb(226,238,250)\"><code>minimumCapacity</code></font>的计算。因为它会作为容量参数被传到用于创建新的Buffer的函数中。</p>\n\n<p>这个函数有四个参数，第一个参数buffer可以理解为数组中真正用于数据存放的那个部分。对于最后两个参数，意思有点像，我们不妨考虑一个实际的、需要进行数组扩容的情况，向一个容量为3，长度为3的数组新增一个元素1，此时函数的调用顺序如下：</p>\n\n<ol>\n<li><font color = \"rgb(226,238,250)\"><code>append(1)</code></font>  </li>\n<li><font color = \"rgb(226,238,250)\"><code>_reserveCapacityAssumingUniqueBuffer(3)</code></font>  </li>\n<li><font color = \"rgb(226,238,250)\"><code>_copyToNewBuffer(3)</code></font>  </li>\n<li><font color = \"rgb(226,238,250)\"><code>_forceCreateUniqueMutableBuffer(&amp;_buffer, countForNewBuffer: 3, minNewCapacity: 4)</code></font>  </li>\n<li><font color = \"rgb(226,238,250)\"><code>_forceCreateUniqueMutableBufferImpl(&amp;_buffer, countForBuffer: 3, minNewCapacity: 4, requiredCapacity: 4)</code></font></li>\n</ol>\n\n<p>还记得<font color = \"rgb(226,238,250)\"><code>_copyToNewBuffer()</code></font>方法里的<code>let newCount = oldCount + 1</code>么，所以<font color = \"rgb(226,238,250)\"><code>oldCount(=3)</code></font>作为<font color = \"rgb(226,238,250)\"><code>minNewCapacity</code></font>，而<font color = \"rgb(226,238,250)\"><code>newCount(=4)</code></font>作为<font color = \"rgb(226,238,250)\"><code>requiredCapacity</code></font>参数被传入<font color = \"rgb(226,238,250)\"><code>_forceCreateUniqueMutableBufferImpl</code></font>方法。</p>\n\n<p>此时，<font color = \"rgb(226,238,250)\"><code>minimumCapacity</code></font>的计算，其实就是以下表达式的值：</p>\n\n<pre><code class=\"language-swift\">max(4, 4 &gt; 3 ? _growArrayCapacity(3) : 3)  \n</code></pre>\n\n<p>我们知道，如果数组需要扩容，<font color = \"rgb(226,238,250)\"><code>source.capacity</code></font>总是等于<font color = \"rgb(226,238,250)\"><code>minNewCapacity</code></font>的。也就是说上式可以写为：</p>\n\n<pre><code class=\"language-swift\">max(length+1, length+1 &gt; length ? _growArrayCapacity(length) : length)\n\n//等价于\nmax(length+1, _growArrayCapacity(length))  \n</code></pre>\n\n<p>可以看到<font color = \"rgb(226,238,250)\"><code>_growArrayCapacity</code></font>返回值是传入参数的两倍：</p>\n\n<pre><code class=\"language-swift\">@warn_unused_result\ninternal func _growArrayCapacity(capacity: Int) -&gt; Int {  \n  return capacity * 2\n}\n</code></pre>\n\n<p>所以<font color = \"rgb(226,238,250)\"><code>minimumCapacity</code></font> = <font color = \"rgb(226,238,250)\"><code>max(length+1, 2 * length)</code></font> = <font color = \"rgb(226,238,250)\"><code>2 * length</code></font>。也就是新扩容的数组长度其实翻倍了。</p>\n\n<h1 id=\"\">线程安全</h1>\n\n<p>现在我们可以理解为什么<font color = \"rgb(226,238,250)\"><code>append</code></font>方法不是线程安全的了。如果在某一个线程中插入新元素，导致了数组扩容，那么Swift会创建一个新的数组（意味着地址完全不同）。然后ARC会为我们自动释放旧的数组，但这时候可能另一个线程还在访问旧的数组对象。</p>\n\n<h1 id=\"\">验证</h1>\n\n<p>说了这么多，我们来证明一下Swift数组扩容的工作原理：</p>\n\n<pre><code class=\"language-swift\">let semaphore = dispatch_semaphore_create(1)  \nvar array: [Int] = []  \nfor i in 1...100000 {  \n    array.append(i)\n    let arrayPtr = UnsafeMutableBufferPointer&lt;Int&gt;(start: &amp;array, count: array.count)\n    print(arrayPtr)\n}\n</code></pre>\n\n<p>运行结果如下，可以验证文章开头的结论：“初始容量为2，扩容时容量翻倍”</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Swift_append/double.png\" alt=\"容量翻倍\" /></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:00:49.000Z","created_by":1,"updated_at":"2016-01-14T08:05:58.000Z","updated_by":1,"published_at":"2015-12-09T08:00:00.000Z","published_by":1},{"id":7,"uuid":"03c046b0-eb28-47e3-bfdc-8d7e2c377bc6","title":"深入探究Swift数组背后的协议、方法、拓展","slug":"swiftarrayimplemation","markdown":"最近翻译完了[《Advanced Swift》中文版](http://www.jianshu.com/p/18744b078508)的“集合”章节。书的质量非常高，讲解非常细致。但不可避免的导致篇幅有点长，有些前面的知识点看到后面无法串联起来。同时由于偏重于讲解，所以个人感觉总结还不够，比如我们可以考虑这几个问题：\n\n* 数组类型(_ArrayType)、集合(Collection)、序列(Sequence)、生成器(Generator)、元素(Element)、下标(Index)，这些类型(协议)各自的作用。\n* 数组是如何利用上面这些类实现各种方法的。\n* <font color = \"rgb(226,238,250)\">`map`</font>、<font color = \"rgb(226,238,250)\">`reduce`</font>、<font color = \"rgb(226,238,250)\">`filter`</font>等方法的作用是什么，他们是怎么实现的。\n* 只有数组有上面这些方法么，如果不是，什么样的类型才有这些方法。\n* 如果实现一个自定义的集合类型，应该怎么做。\n\n而这些问题恰恰是过去我们没有重视或根本无法找到答案的问题。因为在OC中，由于<font color = \"rgb(226,238,250)\">`NSArray`</font>封装的非常好，而且在单纯的iOS开发中对数组的理解不用非常深入，所以我们很少深究数组背后的实现原理。\n\n其实答案就遍布在[《Advanced Swift》中文版](http://www.jianshu.com/p/18744b078508)的“集合”章节的各篇文章中。本文会通过分析Swift中数组的实现，回答上述问题并尝试着建立完整的知识体系。由于篇幅所限，本文不会给出非常详细的源码，而是做总结性的提炼。\n\n# 参考文章\n\n* [Advanced Swift——数组可变性](http://www.jianshu.com/p/21d518da46ed)：主要介绍数组的值语义\n* [Advanced Swift——数组变换](http://www.jianshu.com/p/7b1bb303ec45)： 主要介绍<font color = \"rgb(226,238,250)\">`map`</font>、<font color = \"rgb(226,238,250)\">`reduce`</font>、<font color = \"rgb(226,238,250)\">`filter`</font>等方法的使用和原理\n* [Advanced Swift——字典与集合](http://www.jianshu.com/p/17731dd5db55)：主要介绍字典与集合类型的使用\n* [Advanced Swift——集合协议](http://www.jianshu.com/p/17731dd5db55)：主要介绍数组相关的三种协议\n* [Advanced Swift——集合](http://www.jianshu.com/p/847797ecb79b)：通过实现一个队列，介绍<font color = \"rgb(226,238,250)\">`CollectionType`</font>类型的使用\n* [Advanced Swift——下标](http://www.jianshu.com/p/a22e29b75e40)：实现自定义链表，介绍数组下标的相关知识\n\n#相关类型简介\n\n我们从零开始，根据集合最本质的特点开始思考，逐步抽象。\n\n###元素(Element)\n\n对于任何一种集合来说，它本质上是一种数据结构，也就是用来存放数据的。我们在各种代码中见到的<font color = \"rgb(226,238,250)\">`Element`</font>表示的就是最底层数据的类型别名。因为对于集合这种范型类型来说，它不关心具体存放的数据的类型，所以就用通用的<font color = \"rgb(226,238,250)\">`Element`</font>来代替，比如我们写这样的代码:\n\n```swift\nlet array: Array<Int> = [1,2,3]\n```\n\n这就相当于告诉数组，<font color = \"rgb(226,238,250)\">`Element`</font>现在具体变为<font color = \"rgb(226,238,250)\">`Int`</font>类型了。\n\n###生成器(Generator)\n\n对于集合来说，它往往还需要提供遍历的功能。那怎么把它设计为可遍历的呢？不要指望for循环，要知道目前我们什么都没有，没有数组的概念，更没有下标的概念。有一句名言说：“任何编程问题都可以通过增加一个中间层来解决”。于是，我们抽象出一个<font color = \"rgb(226,238,250)\">`Generator `</font>(生成器)的概念。我们把它声明成一个协议，任何实现这个协议的类都要提供一个<font color = \"rgb(226,238,250)\">`next`</font>方法，返回集合中的下一个元素：\n\n```swift\nprotocol GeneratorType {\n\ttypealias Element\n\tmutating func next() -> Element?\n}\n```\n\n可以想象的是这样一来，实现了<font color = \"rgb(226,238,250)\">`GeneratorType `</font>协议的类，就可以隐藏具体元素的信息，通过不断调用<font color = \"rgb(226,238,250)\">`next`</font>方法就可以获得所有元素了。比如你可以用一个生成器，不断生成斐波那契数列的下一个数字。\n\n总的来说，生成器(<font color = \"rgb(226,238,250)\">`Generator `</font>)允许我们遍历所有的元素。\n\n### 序列(Sequence)\n\n生成器不断生成下一个元素，但是已经生成过的元素就无法再获取到了。比如在斐波那契数列中通过3和5得到了8，那么这个生成器永远也不会再生成元素3了，下一个生成的元素是13。也就是说对于生成器来说，已经访问过的元素就无法再次获取到。\n\n然而对于集合来说，它所包含的元素总是客观存在的。为了能够多次遍历集合，我们抽象出了序列(<font color = \"rgb(226,238,250)\">`Sequence `</font>)的概念。<font color = \"rgb(226,238,250)\">`Sequence `</font>封装了<font color = \"rgb(226,238,250)\">`Generator `</font>对象的创建过程：\n\n```swift\nprotocol SequenceType {\n\ttypealias Generator: GeneratorType\n\tfunc generate() -> Generator\n}\n```\n\n序列(<font color = \"rgb(226,238,250)\">`Sequence `</font>)相比于单纯的<font color = \"rgb(226,238,250)\">`Generator `</font>，使**反复**遍历集合中的元素成为可能。这时候，我们已经可以通过<font color = \"rgb(226,238,250)\">`for`</font>循环而不是<font color = \"rgb(226,238,250)\">`Generator`</font>来遍历所有元素。\n\n### 集合(Collection)\n\n对比一下现有的<font color = \"rgb(226,238,250)\">`Sequence `</font>和数组，会发现它还欠缺一个特性——下标。\n\n回顾一下<font color = \"rgb(226,238,250)\">`Generator `</font>和<font color = \"rgb(226,238,250)\">`Sequence `</font>，它们只是实现了集合的遍历，但没有指定怎么遍历。也就是说，只要<font color = \"rgb(226,238,250)\">`Generator `</font>设计“得当”，即使是1和2这两个元素，我们也可以不断遍历：“1的next是2，2的next是1”。这种情况显然不符合我们对数组的认识。归根结底，还是<font color = \"rgb(226,238,250)\">`Sequence `</font>中无法确定元素的位置，也就无法确保不遍历到已经访问过的元素。\n\n基于这种考虑，我们抽象出集合(<font color = \"rgb(226,238,250)\">`Collection`</font>)的概念。在集合中，每个元素都有确切的位置，因此集合有明确的开始位置和结束位置。给定一个位置，就可以找到这个位置上的元素。<font color = \"rgb(226,238,250)\">`Collection`</font>在<font color = \"rgb(226,238,250)\">`Sequence`</font>的基础上实现了<font color = \"rgb(226,238,250)\">`Indexable`</font>协议\n\n```swift\n\npublic protocol CollectionType : Indexable, SequenceType {\n\tpublic var startIndex: Self.Index { get }\n\tpublic var endIndex: Self.Index { get }\n\tpublic subscript (position: Self.Index) -> Self._Element { get }\n}\n```\n\n当然，<font color = \"rgb(226,238,250)\">`CollectionType`</font>中的内容远远不止这些。这里列出的仅仅是为了表示<font color = \"rgb(226,238,250)\">`CollectionType`</font>的特性。\n\n### 下标(Index)\n\n虽然我们在使用数组的时候，元素下标总是从0开始，并且逐个递增。但下标不必是从0开始递增的整数。比如<font color = \"rgb(226,238,250)\">`a、b、c……`</font>也可以作为下标。下标类型的关键在于能根据某一个下标推断出下一个下标是什么，比如对于整数来说下一个下标就是当前下标值加1。下标类型的协议如下：\n\n```swift\npublic protocol ForwardIndexType : _Incrementable {\n\t///....\n}\n\npublic protocol _Incrementable : Equatable {\n    public func successor() -> Self\n}\n```\n\n对于下标类型来说，它们必须实现<font color = \"rgb(226,238,250)\">`successor()`</font>方法，同时也得是<font color = \"rgb(226,238,250)\">`Equatable`</font>的，否则怎么知道某个位置上的元素已经被访问过了呢。\n\n#数组简介\n\n有了以上基本知识做铺垫，接下来就可以研究一下Swift中数组是怎么实现的了。\n\n### 基本定义\n我们可能早已体会到Swift数组的强大，它的下标脚本不仅可以读取元素，还可以直接修改元素。它可以通过字面量初始化，还可以调用\n<font color = \"rgb(226,238,250)\">`appendContentsOf `</font>方法从别的数组中添加元素。甚至于我们可能都没有仔细考虑过为什么可以用<font color = \"rgb(226,238,250)\">`for number in array`</font>这样的语法。\n\n首先，我们需要明确一个概念：数组丰富强大的特性绝不是由<font color = \"rgb(226,238,250)\">`Array`</font>这一个类型可以提供的。实际上，这主要是协议的功劳。用OC写iOS时，协议几乎就是代理的代名词(可能是我对OC不甚精通，目光短浅)，但毋庸置疑的是在Swift中，协议的功能被空前的强化。数组通过实现协议、以及协议的嵌套、拓展功能，具有了很多特性。数组的背后交织着错综复杂的协议、方法和拓展。\n\n下面是数组的定义：\n\n```swift\npublic struct Array<Element> : CollectionType, MutableCollectionType, _DestructorSafeContainer {\n    public var startIndex: Int { get }\n    public var endIndex: Int { get }\n    public subscript (index: Int) -> Element\n    public subscript (subRange: Range<Int>) -> ArraySlice<Element>\n}\n```\n\n数组是一个结构体，它实现了三个协议，有两个变量和两个下标脚本。除此以外，数组还有大量的拓展。\n###数组拓展\n\n数组的大量功能在拓展中完成，由于拓展很多，我就不列出完整代码，只是做一个整理。数组一共拓展了四类协议：\n\n* <font color = \"rgb(226,238,250)\">`ArrayLiteralConvertible `</font>： 这个协议是为了支持这样的语法的：<font color = \"rgb(226,238,250)\">`let a: Array<Int> = [1,2,3]`</font>。实现协议很简单，只要提供一个自定义方法即可：\n\n```swift\npublic init(arrayLiteral elements: Element...)\n```\n* <font color = \"rgb(226,238,250)\">`_Reflectable `</font>：这个协议用于处理反射相关的内容，这里不做详解\n* <font color = \"rgb(226,238,250)\">`CustomStringConvertible `</font>和<font color = \"rgb(226,238,250)\">`CustomDebugStringConvertible `</font>：这两个是方便我们调试的协议，与数组自身的功能无关。\n* <font color = \"rgb(226,238,250)\">`_ArrayType `</font>：这是数组**最关键的**部分。在实现这个协议之前，数组还只是一个普通的集合类型，它仅仅是拥有下标，而且可以重复遍历所有元素而已。而通过实现<font color = \"rgb(226,238,250)\">`_ArrayType `</font>协议，它可以**在指定位置(下标)添加或移除一个或多个元素**，它还有了自己的<font color = \"rgb(226,238,250)\">`count`</font>属性。\n\n这一点也许有些颠覆我们此前的认识。一个集合类型，是不能添加或删除元素的。数组通过实现了<font color = \"rgb(226,238,250)\">`_ArrayType `</font>协议提供了这样的功能。但这也很容易理解，因为集合的本质还是在于元素的收集，而非考虑如何改变这些元素。\n\n<font color = \"rgb(226,238,250)\">`_ArrayType `</font>协议还给了我们一个非常重要的启示。比如说我想实现自己的数据结构——栈，那么就应该实现对应的<font color = \"rgb(226,238,250)\">`_StackType `</font>协议。这种协议要充分考虑数据结构自身的特点，从而提供对应的方法。比如我们不可能向栈的某个特定位置添加若干个元素(只能向栈顶添加一个)。所以<font color = \"rgb(226,238,250)\">`_StackType `</font>协议中不会定义<font color = \"rgb(226,238,250)\">`append `</font>、<font color = \"rgb(226,238,250)\">`appendContentsOf`</font>这样的方法，而是应该定义<font color = \"rgb(226,238,250)\">`pop`</font>和<font color = \"rgb(226,238,250)\">`push`</font>方法。\n\n#SequenceType\n\n接下来的任务是搞清楚<font color = \"rgb(226,238,250)\">`ColectionType`</font>的原理了。不过在此之前，我们先来看看<font color = \"rgb(226,238,250)\">`SequenceType`</font>的一些细节，毕竟<font color = \"rgb(226,238,250)\">`CollectionType`</font>协议是继承了<font color = \"rgb(226,238,250)\">`SequenceType`</font>协议的。\n\n在有了<font color = \"rgb(226,238,250)\">`Generator`</font>之后，我们已经可以在<font color = \"rgb(226,238,250)\">`while`</font>循环中用<font color = \"rgb(226,238,250)\">`Generator`</font>的<font color = \"rgb(226,238,250)\">`next`</font>方法遍历所有元素了。之前也说过，<font color = \"rgb(226,238,250)\">`SequenceType`</font>使对元素的多次遍历成为可能。\n\n注意，仅仅是成为可能而已。如果遍历的细节由<font color = \"rgb(226,238,250)\">`Generator`</font>控制，那么多次遍历是没有问题的。在极个别情况下，但如果遍历的细节依赖于<font color = \"rgb(226,238,250)\">`SequenceType`</font>自身的某个属性，而且这个属性会发生变化，那么就不能多次遍历所有元素了。\n\n<font color = \"rgb(226,238,250)\">`SequenceType`</font>协议的基本部分非常简单，只有一个<font color = \"rgb(226,238,250)\">`generator()`</font>方法，封装了<font color = \"rgb(226,238,250)\">`Generator`</font>的创建过程。\n\n一旦有了遍历元素的概念，<font color = \"rgb(226,238,250)\">`SequenceType`</font>立刻就有了非常多的拓展。这里简单列举几个比较关键的：\n\n* <font color = \"rgb(226,238,250)\">`forEach`</font>：这个拓展使得我们可以用for循环遍历集合了：<font color = \"rgb(226,238,250)\">`for item in sequence`</font>\n* <font color = \"rgb(226,238,250)\">`dropFirst(n: Int)`</font>和<font color = \"rgb(226,238,250)\">`dropLast(n: Int)`</font>：这两个方法返回的是除了前(后)n个元素之外的<font color = \"rgb(226,238,250)\">`Sequence`</font>。需要提一下的是，由于此时的<font color = \"rgb(226,238,250)\">`SequenceType`</font>还没有下标的概念，这两个方法的实现是**非常复杂**的。\n* <font color = \"rgb(226,238,250)\">`prefix(maxLength: Int)`</font>和<font color = \"rgb(226,238,250)\">`suffix(maxLength: Int)`</font>：和刚刚两个方法类似，这两个方法返回的是前(后)maxLength个元素，实现也不简单。\n* <font color = \"rgb(226,238,250)\">`elementsEqual`</font>、<font color = \"rgb(226,238,250)\">`contains`</font>、<font color = \"rgb(226,238,250)\">`minElement`</font>、<font color = \"rgb(226,238,250)\">`maxElement`</font>等，这些都是针对元素的判断和选择。\n* <font color = \"rgb(226,238,250)\">`map`</font>、<font color = \"rgb(226,238,250)\">`flatMap`</font>、<font color = \"rgb(226,238,250)\">`filter`</font>、<font color = \"rgb(226,238,250)\">`reduce`</font>这些方法是针对所有元素的变换。\n\n<font color = \"rgb(226,238,250)\">`SequenceType`</font>的拓展实在是太多了，但总结来看不外乎两点：\n\n1. 由于可以多次遍历元素了，我们可以对元素进行各种比较、处理、筛选等等操作。这些派生出来的方法和函数极大的强化了<font color = \"rgb(226,238,250)\">`SequenceType `</font>的功能。\n2. 由于<font color = \"rgb(226,238,250)\">`SequenceType `</font>自身的局限性，不能保证一定可以多次遍历所有元素，还没有下标和元素位置的概念，因此某些方法的实现还不够高效，\n\n带着这样的遗憾，我们来看看最关键的<font color = \"rgb(226,238,250)\">`CollectionType `</font>是如何实现的。\n\n#细谈CollectionType\n\n之前我们说过<font color = \"rgb(226,238,250)\">`CollectionType`</font>协议是在<font color = \"rgb(226,238,250)\">`SequenceType`</font>的基础上实现了<font color = \"rgb(226,238,250)\">`Indexable`</font>协议。由于协议的继承关系，任何实现了<font color = \"rgb(226,238,250)\">`CollectionType`</font>协议的类，必须实现<font color = \"rgb(226,238,250)\">`Indexable`</font>协议规定的两个参数：<font color = \"rgb(226,238,250)\">`startIndex`</font>和<font color = \"rgb(226,238,250)\">`endIndex`</font>，以及一个下标脚本：<font color = \"rgb(226,238,250)\">`subscript (position: Self.Index) -> Self._Element { get }`</font>。即使这三个要求在<font color = \"rgb(226,238,250)\">`CollectionType`</font>中没有直接标出来。\n\n回顾一下数组定义的前三行，正是满足了这三个要求。再看<font color = \"rgb(226,238,250)\">`CollectionType`</font>,它不仅重载了<font color = \"rgb(226,238,250)\">`Indexable`</font>的一个下标脚本，还额外提供了一个下标脚本用来访问某一段元素，这个下标脚本返回的类型是切片(<font color = \"rgb(226,238,250)\">`Slice`</font>)。这也正是数组定义的第四行，实现的内容。\n\n细心的读者可能已经注意到，<font color = \"rgb(226,238,250)\">`CollectionType`</font>还定义了很多属性和方法，比如：<font color = \"rgb(226,238,250)\">`prefixUpTo`</font>、<font color = \"rgb(226,238,250)\">`suffixFrom`</font>、<font color = \"rgb(226,238,250)\">`isEmpty`</font>、<font color = \"rgb(226,238,250)\">`first`</font>等等。但数组没有实现其中的任何一个。\n\n事实上，这不仅不是数组设计的失败之处，而正是Swift协议的强大之处。Swift可以通过协议拓展，为计算属性和方法提供默认实现。因此，数组可以不用写任何代码就具备这些方法。更赞的是，任何实现了<font color = \"rgb(226,238,250)\">`CollectionType`</font>协议的类型也因此具有了这些方法。\n\n观察一下<font color = \"rgb(226,238,250)\">`CollectionType `</font>的其它拓展，大部分都是重写了<font color = \"rgb(226,238,250)\">`SequenceType `</font>中的实现。之前已经提到过<font color = \"rgb(226,238,250)\">`SequenceType `</font>没有下标的概念，而类似于<font color = \"rgb(226,238,250)\">`dropFirst `</font>这样的方法，利用下标的概念是非常容易实现的。\n\n除了对一些已有方法的重写之外，<font color = \"rgb(226,238,250)\">`CollectionType `</font>还新增了一些基于下标的方法。比如<font color = \"rgb(226,238,250)\">`indexOf() `</font>等。\n\n套用官方文档中对<font color = \"rgb(226,238,250)\">`CollectionType `</font>的总结就是：\n\n>     A multi-pass sequence with addressable positions\n\n也就是说<font color = \"rgb(226,238,250)\">`CollectionType `</font>是可以多次遍历，元素可定位的<font color = \"rgb(226,238,250)\">`SequenceType `</font>\n\n#总结\n\n<font color = \"rgb(226,238,250)\">`Element`</font>、<font color = \"rgb(226,238,250)\">`Generator`</font>、<font color = \"rgb(226,238,250)\">`SequenceType`</font>、<font color = \"rgb(226,238,250)\">`CollectionType`</font>、<font color = \"rgb(226,238,250)\">`Array`</font>由下至上构造了数组背后的层次结构。他们的关系如下图所示：\n\n![Swift数组层次结构](http://7xonij.com1.z0.glb.clouddn.com/Advanced%20Swift/Collection/array-hierarchy.png)\n\n\n如果我们希望定义一个自己的数据结构，比如链表。首先可以明确它要实现<font color = \"rgb(226,238,250)\">`CollectionType`</font>协议。链表应该是和<font color = \"rgb(226,238,250)\">`Array`</font>同层次的类型。然后我们需要定义一个<font color = \"rgb(226,238,250)\">`_ListType`</font>的协议，这个协议对应数组的<font color = \"rgb(226,238,250)\">`_ArrayList`</font>协议，根据数据结构自身的特性定义一些方法。\n\n如果觉得<font color = \"rgb(226,238,250)\">`CollectionType`</font>甚至是<font color = \"rgb(226,238,250)\">`SequenceType`</font>不满足我们的需求，我们还可以自己实现对应的类型。难度不会很大，因为它们虽然负责，但大多数方法已有默认实现，我们只要重写一些关键的逻辑即可。\n\n最后需要说明的是，Swift中对集合的实现实在是太复杂了，如果每个都详细分析，怕是可以写一本书。希望读完这篇文章后，读者可以举一反三，自行阅读源码解决相关问题。","html":"<p>最近翻译完了<a href=\"http://www.jianshu.com/p/18744b078508\">《Advanced Swift》中文版</a>的“集合”章节。书的质量非常高，讲解非常细致。但不可避免的导致篇幅有点长，有些前面的知识点看到后面无法串联起来。同时由于偏重于讲解，所以个人感觉总结还不够，比如我们可以考虑这几个问题：</p>\n\n<ul>\n<li>数组类型(_ArrayType)、集合(Collection)、序列(Sequence)、生成器(Generator)、元素(Element)、下标(Index)，这些类型(协议)各自的作用。</li>\n<li>数组是如何利用上面这些类实现各种方法的。</li>\n<li><font color = \"rgb(226,238,250)\"><code>map</code></font>、<font color = \"rgb(226,238,250)\"><code>reduce</code></font>、<font color = \"rgb(226,238,250)\"><code>filter</code></font>等方法的作用是什么，他们是怎么实现的。</li>\n<li>只有数组有上面这些方法么，如果不是，什么样的类型才有这些方法。</li>\n<li>如果实现一个自定义的集合类型，应该怎么做。</li>\n</ul>\n\n<p>而这些问题恰恰是过去我们没有重视或根本无法找到答案的问题。因为在OC中，由于<font color = \"rgb(226,238,250)\"><code>NSArray</code></font>封装的非常好，而且在单纯的iOS开发中对数组的理解不用非常深入，所以我们很少深究数组背后的实现原理。</p>\n\n<p>其实答案就遍布在<a href=\"http://www.jianshu.com/p/18744b078508\">《Advanced Swift》中文版</a>的“集合”章节的各篇文章中。本文会通过分析Swift中数组的实现，回答上述问题并尝试着建立完整的知识体系。由于篇幅所限，本文不会给出非常详细的源码，而是做总结性的提炼。</p>\n\n<h1 id=\"\">参考文章</h1>\n\n<ul>\n<li><a href=\"http://www.jianshu.com/p/21d518da46ed\">Advanced Swift——数组可变性</a>：主要介绍数组的值语义</li>\n<li><a href=\"http://www.jianshu.com/p/7b1bb303ec45\">Advanced Swift——数组变换</a>： 主要介绍<font color = \"rgb(226,238,250)\"><code>map</code></font>、<font color = \"rgb(226,238,250)\"><code>reduce</code></font>、<font color = \"rgb(226,238,250)\"><code>filter</code></font>等方法的使用和原理</li>\n<li><a href=\"http://www.jianshu.com/p/17731dd5db55\">Advanced Swift——字典与集合</a>：主要介绍字典与集合类型的使用</li>\n<li><a href=\"http://www.jianshu.com/p/17731dd5db55\">Advanced Swift——集合协议</a>：主要介绍数组相关的三种协议</li>\n<li><a href=\"http://www.jianshu.com/p/847797ecb79b\">Advanced Swift——集合</a>：通过实现一个队列，介绍<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>类型的使用</li>\n<li><a href=\"http://www.jianshu.com/p/a22e29b75e40\">Advanced Swift——下标</a>：实现自定义链表，介绍数组下标的相关知识</li>\n</ul>\n\n<h1 id=\"\">相关类型简介</h1>\n\n<p>我们从零开始，根据集合最本质的特点开始思考，逐步抽象。</p>\n\n<h3 id=\"element\">元素(Element)</h3>\n\n<p>对于任何一种集合来说，它本质上是一种数据结构，也就是用来存放数据的。我们在各种代码中见到的<font color = \"rgb(226,238,250)\"><code>Element</code></font>表示的就是最底层数据的类型别名。因为对于集合这种范型类型来说，它不关心具体存放的数据的类型，所以就用通用的<font color = \"rgb(226,238,250)\"><code>Element</code></font>来代替，比如我们写这样的代码:</p>\n\n<pre><code class=\"language-swift\">let array: Array&lt;Int&gt; = [1,2,3]  \n</code></pre>\n\n<p>这就相当于告诉数组，<font color = \"rgb(226,238,250)\"><code>Element</code></font>现在具体变为<font color = \"rgb(226,238,250)\"><code>Int</code></font>类型了。</p>\n\n<h3 id=\"generator\">生成器(Generator)</h3>\n\n<p>对于集合来说，它往往还需要提供遍历的功能。那怎么把它设计为可遍历的呢？不要指望for循环，要知道目前我们什么都没有，没有数组的概念，更没有下标的概念。有一句名言说：“任何编程问题都可以通过增加一个中间层来解决”。于是，我们抽象出一个<font color = \"rgb(226,238,250)\"><code>Generator</code></font>(生成器)的概念。我们把它声明成一个协议，任何实现这个协议的类都要提供一个<font color = \"rgb(226,238,250)\"><code>next</code></font>方法，返回集合中的下一个元素：</p>\n\n<pre><code class=\"language-swift\">protocol GeneratorType {  \n    typealias Element\n    mutating func next() -&gt; Element?\n}\n</code></pre>\n\n<p>可以想象的是这样一来，实现了<font color = \"rgb(226,238,250)\"><code>GeneratorType</code></font>协议的类，就可以隐藏具体元素的信息，通过不断调用<font color = \"rgb(226,238,250)\"><code>next</code></font>方法就可以获得所有元素了。比如你可以用一个生成器，不断生成斐波那契数列的下一个数字。</p>\n\n<p>总的来说，生成器(<font color = \"rgb(226,238,250)\"><code>Generator</code></font>)允许我们遍历所有的元素。</p>\n\n<h3 id=\"sequence\">序列(Sequence)</h3>\n\n<p>生成器不断生成下一个元素，但是已经生成过的元素就无法再获取到了。比如在斐波那契数列中通过3和5得到了8，那么这个生成器永远也不会再生成元素3了，下一个生成的元素是13。也就是说对于生成器来说，已经访问过的元素就无法再次获取到。</p>\n\n<p>然而对于集合来说，它所包含的元素总是客观存在的。为了能够多次遍历集合，我们抽象出了序列(<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>)的概念。<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>封装了<font color = \"rgb(226,238,250)\"><code>Generator</code></font>对象的创建过程：</p>\n\n<pre><code class=\"language-swift\">protocol SequenceType {  \n    typealias Generator: GeneratorType\n    func generate() -&gt; Generator\n}\n</code></pre>\n\n<p>序列(<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>)相比于单纯的<font color = \"rgb(226,238,250)\"><code>Generator</code></font>，使<strong>反复</strong>遍历集合中的元素成为可能。这时候，我们已经可以通过<font color = \"rgb(226,238,250)\"><code>for</code></font>循环而不是<font color = \"rgb(226,238,250)\"><code>Generator</code></font>来遍历所有元素。</p>\n\n<h3 id=\"collection\">集合(Collection)</h3>\n\n<p>对比一下现有的<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>和数组，会发现它还欠缺一个特性——下标。</p>\n\n<p>回顾一下<font color = \"rgb(226,238,250)\"><code>Generator</code></font>和<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>，它们只是实现了集合的遍历，但没有指定怎么遍历。也就是说，只要<font color = \"rgb(226,238,250)\"><code>Generator</code></font>设计“得当”，即使是1和2这两个元素，我们也可以不断遍历：“1的next是2，2的next是1”。这种情况显然不符合我们对数组的认识。归根结底，还是<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>中无法确定元素的位置，也就无法确保不遍历到已经访问过的元素。</p>\n\n<p>基于这种考虑，我们抽象出集合(<font color = \"rgb(226,238,250)\"><code>Collection</code></font>)的概念。在集合中，每个元素都有确切的位置，因此集合有明确的开始位置和结束位置。给定一个位置，就可以找到这个位置上的元素。<font color = \"rgb(226,238,250)\"><code>Collection</code></font>在<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>的基础上实现了<font color = \"rgb(226,238,250)\"><code>Indexable</code></font>协议</p>\n\n<pre><code class=\"language-swift\">public protocol CollectionType : Indexable, SequenceType {  \n    public var startIndex: Self.Index { get }\n    public var endIndex: Self.Index { get }\n    public subscript (position: Self.Index) -&gt; Self._Element { get }\n}\n</code></pre>\n\n<p>当然，<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>中的内容远远不止这些。这里列出的仅仅是为了表示<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>的特性。</p>\n\n<h3 id=\"index\">下标(Index)</h3>\n\n<p>虽然我们在使用数组的时候，元素下标总是从0开始，并且逐个递增。但下标不必是从0开始递增的整数。比如<font color = \"rgb(226,238,250)\"><code>a、b、c……</code></font>也可以作为下标。下标类型的关键在于能根据某一个下标推断出下一个下标是什么，比如对于整数来说下一个下标就是当前下标值加1。下标类型的协议如下：</p>\n\n<pre><code class=\"language-swift\">public protocol ForwardIndexType : _Incrementable {  \n    ///....\n}\n\npublic protocol _Incrementable : Equatable {  \n    public func successor() -&gt; Self\n}\n</code></pre>\n\n<p>对于下标类型来说，它们必须实现<font color = \"rgb(226,238,250)\"><code>successor()</code></font>方法，同时也得是<font color = \"rgb(226,238,250)\"><code>Equatable</code></font>的，否则怎么知道某个位置上的元素已经被访问过了呢。</p>\n\n<h1 id=\"\">数组简介</h1>\n\n<p>有了以上基本知识做铺垫，接下来就可以研究一下Swift中数组是怎么实现的了。</p>\n\n<h3 id=\"\">基本定义</h3>\n\n<p>我们可能早已体会到Swift数组的强大，它的下标脚本不仅可以读取元素，还可以直接修改元素。它可以通过字面量初始化，还可以调用\n<font color = \"rgb(226,238,250)\"><code>appendContentsOf</code></font>方法从别的数组中添加元素。甚至于我们可能都没有仔细考虑过为什么可以用<font color = \"rgb(226,238,250)\"><code>for number in array</code></font>这样的语法。</p>\n\n<p>首先，我们需要明确一个概念：数组丰富强大的特性绝不是由<font color = \"rgb(226,238,250)\"><code>Array</code></font>这一个类型可以提供的。实际上，这主要是协议的功劳。用OC写iOS时，协议几乎就是代理的代名词(可能是我对OC不甚精通，目光短浅)，但毋庸置疑的是在Swift中，协议的功能被空前的强化。数组通过实现协议、以及协议的嵌套、拓展功能，具有了很多特性。数组的背后交织着错综复杂的协议、方法和拓展。</p>\n\n<p>下面是数组的定义：</p>\n\n<pre><code class=\"language-swift\">public struct Array&lt;Element&gt; : CollectionType, MutableCollectionType, _DestructorSafeContainer {  \n    public var startIndex: Int { get }\n    public var endIndex: Int { get }\n    public subscript (index: Int) -&gt; Element\n    public subscript (subRange: Range&lt;Int&gt;) -&gt; ArraySlice&lt;Element&gt;\n}\n</code></pre>\n\n<p>数组是一个结构体，它实现了三个协议，有两个变量和两个下标脚本。除此以外，数组还有大量的拓展。</p>\n\n<h3 id=\"\">数组拓展</h3>\n\n<p>数组的大量功能在拓展中完成，由于拓展很多，我就不列出完整代码，只是做一个整理。数组一共拓展了四类协议：</p>\n\n<ul>\n<li><font color = \"rgb(226,238,250)\"><code>ArrayLiteralConvertible</code></font>： 这个协议是为了支持这样的语法的：<font color = \"rgb(226,238,250)\"><code>let a: Array&lt;Int&gt; = [1,2,3]</code></font>。实现协议很简单，只要提供一个自定义方法即可：</li>\n</ul>\n\n<pre><code class=\"language-swift\">public init(arrayLiteral elements: Element...)  \n</code></pre>\n\n<ul>\n<li><font color = \"rgb(226,238,250)\"><code>_Reflectable</code></font>：这个协议用于处理反射相关的内容，这里不做详解</li>\n<li><font color = \"rgb(226,238,250)\"><code>CustomStringConvertible</code></font>和<font color = \"rgb(226,238,250)\"><code>CustomDebugStringConvertible</code></font>：这两个是方便我们调试的协议，与数组自身的功能无关。</li>\n<li><font color = \"rgb(226,238,250)\"><code>_ArrayType</code></font>：这是数组<strong>最关键的</strong>部分。在实现这个协议之前，数组还只是一个普通的集合类型，它仅仅是拥有下标，而且可以重复遍历所有元素而已。而通过实现<font color = \"rgb(226,238,250)\"><code>_ArrayType</code></font>协议，它可以<strong>在指定位置(下标)添加或移除一个或多个元素</strong>，它还有了自己的<font color = \"rgb(226,238,250)\"><code>count</code></font>属性。</li>\n</ul>\n\n<p>这一点也许有些颠覆我们此前的认识。一个集合类型，是不能添加或删除元素的。数组通过实现了<font color = \"rgb(226,238,250)\"><code>_ArrayType</code></font>协议提供了这样的功能。但这也很容易理解，因为集合的本质还是在于元素的收集，而非考虑如何改变这些元素。</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>_ArrayType</code></font>协议还给了我们一个非常重要的启示。比如说我想实现自己的数据结构——栈，那么就应该实现对应的<font color = \"rgb(226,238,250)\"><code>_StackType</code></font>协议。这种协议要充分考虑数据结构自身的特点，从而提供对应的方法。比如我们不可能向栈的某个特定位置添加若干个元素(只能向栈顶添加一个)。所以<font color = \"rgb(226,238,250)\"><code>_StackType</code></font>协议中不会定义<font color = \"rgb(226,238,250)\"><code>append</code></font>、<font color = \"rgb(226,238,250)\"><code>appendContentsOf</code></font>这样的方法，而是应该定义<font color = \"rgb(226,238,250)\"><code>pop</code></font>和<font color = \"rgb(226,238,250)\"><code>push</code></font>方法。</p>\n\n<h1 id=\"sequencetype\">SequenceType</h1>\n\n<p>接下来的任务是搞清楚<font color = \"rgb(226,238,250)\"><code>ColectionType</code></font>的原理了。不过在此之前，我们先来看看<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>的一些细节，毕竟<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>协议是继承了<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>协议的。</p>\n\n<p>在有了<font color = \"rgb(226,238,250)\"><code>Generator</code></font>之后，我们已经可以在<font color = \"rgb(226,238,250)\"><code>while</code></font>循环中用<font color = \"rgb(226,238,250)\"><code>Generator</code></font>的<font color = \"rgb(226,238,250)\"><code>next</code></font>方法遍历所有元素了。之前也说过，<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>使对元素的多次遍历成为可能。</p>\n\n<p>注意，仅仅是成为可能而已。如果遍历的细节由<font color = \"rgb(226,238,250)\"><code>Generator</code></font>控制，那么多次遍历是没有问题的。在极个别情况下，但如果遍历的细节依赖于<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>自身的某个属性，而且这个属性会发生变化，那么就不能多次遍历所有元素了。</p>\n\n<p><font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>协议的基本部分非常简单，只有一个<font color = \"rgb(226,238,250)\"><code>generator()</code></font>方法，封装了<font color = \"rgb(226,238,250)\"><code>Generator</code></font>的创建过程。</p>\n\n<p>一旦有了遍历元素的概念，<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>立刻就有了非常多的拓展。这里简单列举几个比较关键的：</p>\n\n<ul>\n<li><font color = \"rgb(226,238,250)\"><code>forEach</code></font>：这个拓展使得我们可以用for循环遍历集合了：<font color = \"rgb(226,238,250)\"><code>for item in sequence</code></font></li>\n<li><font color = \"rgb(226,238,250)\"><code>dropFirst(n: Int)</code></font>和<font color = \"rgb(226,238,250)\"><code>dropLast(n: Int)</code></font>：这两个方法返回的是除了前(后)n个元素之外的<font color = \"rgb(226,238,250)\"><code>Sequence</code></font>。需要提一下的是，由于此时的<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>还没有下标的概念，这两个方法的实现是<strong>非常复杂</strong>的。</li>\n<li><font color = \"rgb(226,238,250)\"><code>prefix(maxLength: Int)</code></font>和<font color = \"rgb(226,238,250)\"><code>suffix(maxLength: Int)</code></font>：和刚刚两个方法类似，这两个方法返回的是前(后)maxLength个元素，实现也不简单。</li>\n<li><font color = \"rgb(226,238,250)\"><code>elementsEqual</code></font>、<font color = \"rgb(226,238,250)\"><code>contains</code></font>、<font color = \"rgb(226,238,250)\"><code>minElement</code></font>、<font color = \"rgb(226,238,250)\"><code>maxElement</code></font>等，这些都是针对元素的判断和选择。</li>\n<li><font color = \"rgb(226,238,250)\"><code>map</code></font>、<font color = \"rgb(226,238,250)\"><code>flatMap</code></font>、<font color = \"rgb(226,238,250)\"><code>filter</code></font>、<font color = \"rgb(226,238,250)\"><code>reduce</code></font>这些方法是针对所有元素的变换。</li>\n</ul>\n\n<p><font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>的拓展实在是太多了，但总结来看不外乎两点：</p>\n\n<ol>\n<li>由于可以多次遍历元素了，我们可以对元素进行各种比较、处理、筛选等等操作。这些派生出来的方法和函数极大的强化了<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>的功能。  </li>\n<li>由于<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>自身的局限性，不能保证一定可以多次遍历所有元素，还没有下标和元素位置的概念，因此某些方法的实现还不够高效，</li>\n</ol>\n\n<p>带着这样的遗憾，我们来看看最关键的<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>是如何实现的。</p>\n\n<h1 id=\"collectiontype\">细谈CollectionType</h1>\n\n<p>之前我们说过<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>协议是在<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>的基础上实现了<font color = \"rgb(226,238,250)\"><code>Indexable</code></font>协议。由于协议的继承关系，任何实现了<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>协议的类，必须实现<font color = \"rgb(226,238,250)\"><code>Indexable</code></font>协议规定的两个参数：<font color = \"rgb(226,238,250)\"><code>startIndex</code></font>和<font color = \"rgb(226,238,250)\"><code>endIndex</code></font>，以及一个下标脚本：<font color = \"rgb(226,238,250)\"><code>subscript (position: Self.Index) -&gt; Self._Element { get }</code></font>。即使这三个要求在<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>中没有直接标出来。</p>\n\n<p>回顾一下数组定义的前三行，正是满足了这三个要求。再看<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>,它不仅重载了<font color = \"rgb(226,238,250)\"><code>Indexable</code></font>的一个下标脚本，还额外提供了一个下标脚本用来访问某一段元素，这个下标脚本返回的类型是切片(<font color = \"rgb(226,238,250)\"><code>Slice</code></font>)。这也正是数组定义的第四行，实现的内容。</p>\n\n<p>细心的读者可能已经注意到，<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>还定义了很多属性和方法，比如：<font color = \"rgb(226,238,250)\"><code>prefixUpTo</code></font>、<font color = \"rgb(226,238,250)\"><code>suffixFrom</code></font>、<font color = \"rgb(226,238,250)\"><code>isEmpty</code></font>、<font color = \"rgb(226,238,250)\"><code>first</code></font>等等。但数组没有实现其中的任何一个。</p>\n\n<p>事实上，这不仅不是数组设计的失败之处，而正是Swift协议的强大之处。Swift可以通过协议拓展，为计算属性和方法提供默认实现。因此，数组可以不用写任何代码就具备这些方法。更赞的是，任何实现了<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>协议的类型也因此具有了这些方法。</p>\n\n<p>观察一下<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>的其它拓展，大部分都是重写了<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>中的实现。之前已经提到过<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>没有下标的概念，而类似于<font color = \"rgb(226,238,250)\"><code>dropFirst</code></font>这样的方法，利用下标的概念是非常容易实现的。</p>\n\n<p>除了对一些已有方法的重写之外，<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>还新增了一些基于下标的方法。比如<font color = \"rgb(226,238,250)\"><code>indexOf()</code></font>等。</p>\n\n<p>套用官方文档中对<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>的总结就是：</p>\n\n<blockquote>\n<pre><code>A multi-pass sequence with addressable positions\n</code></pre>\n</blockquote>\n\n<p>也就是说<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>是可以多次遍历，元素可定位的<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font></p>\n\n<h1 id=\"\">总结</h1>\n\n<p><font color = \"rgb(226,238,250)\"><code>Element</code></font>、<font color = \"rgb(226,238,250)\"><code>Generator</code></font>、<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>、<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>、<font color = \"rgb(226,238,250)\"><code>Array</code></font>由下至上构造了数组背后的层次结构。他们的关系如下图所示：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Advanced%20Swift/Collection/array-hierarchy.png\" alt=\"Swift数组层次结构\" /></p>\n\n<p>如果我们希望定义一个自己的数据结构，比如链表。首先可以明确它要实现<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>协议。链表应该是和<font color = \"rgb(226,238,250)\"><code>Array</code></font>同层次的类型。然后我们需要定义一个<font color = \"rgb(226,238,250)\"><code>_ListType</code></font>的协议，这个协议对应数组的<font color = \"rgb(226,238,250)\"><code>_ArrayList</code></font>协议，根据数据结构自身的特性定义一些方法。</p>\n\n<p>如果觉得<font color = \"rgb(226,238,250)\"><code>CollectionType</code></font>甚至是<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>不满足我们的需求，我们还可以自己实现对应的类型。难度不会很大，因为它们虽然负责，但大多数方法已有默认实现，我们只要重写一些关键的逻辑即可。</p>\n\n<p>最后需要说明的是，Swift中对集合的实现实在是太复杂了，如果每个都详细分析，怕是可以写一本书。希望读完这篇文章后，读者可以举一反三，自行阅读源码解决相关问题。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:04:21.000Z","created_by":1,"updated_at":"2016-01-14T08:05:35.000Z","updated_by":1,"published_at":"2015-12-14T08:04:00.000Z","published_by":1},{"id":8,"uuid":"e2a40440-4d49-413e-b2e1-812e5bdbed2f","title":"从原理分析Swift中switch怎么比较对象","slug":"cong-yuan-li-fen-xi-swiftzhong-switchzen-yao-bi-jiao-dui-xiang","markdown":"今天突然想到一个问题，让我觉得有必要总结一下switch语句。我们知道swift中的switch，远比C语言只能比较整数强大得多，但问题来了，哪些类型可以放到switch中比较呢，对象可以比较么？\n\n<!--more-->\n\n[官方文档](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120)对switch的用法给出了这样的解释：\n\n> Cases can match many different patterns, including interval matches, tuples, and casts to a specific type.\n\n也就是说除了最常用的比较整数、字符串等等之外，switch还可以用来匹配范围、元组，转化成某个特定类型等等。但文档里这个**including**用的实在是无语，因为它没有指明所有可以放在switch中比较的类型，文章开头提出的问题依然没有答案。\n\n我们不妨动手试一下，用switch匹配对象：\n\n```swift\nclass A {\n    \n}\n\nvar o  = A()\nvar o1 = A()\nvar o2 = A()\n\nswitch o {\ncase o1:\n    print(\"it is o1\")\ncase o2:\n    print(\"it is o2\")\ndefault:\n    print(\"not o1 or o2\")\n}\n```\n\n果然，编译器报错了：“Expression pattern of type 'A' cannot match values of type 'A'”。至少我们目前还不明白“expression pattern”是什么，怎么类型A就不能匹配类型A了。\n\n我们做一下改动，在<font color = \"rgb(226,238,250)\">`case`</font>语句后面加上<font color = \"rgb(226,238,250)\">`let`</font>：\n\n```swift\nswitch o {\ncase let o1:\n    print(\"it is o1\")\ncase let o2:\n    print(\"it is o2\")\ndefault:\n    print(\"not o1 or o2\")\n}\n```\n\nOK，编译运行，结果是：<font color = \"rgb(226,238,250)\">`it is o1`</font>。这是因为<font color = \"rgb(226,238,250)\">`case let`</font>不是匹配值，而是值绑定，也就是把o的值赋给临时变量o1,这在o是可选类型时很有用，类似于<font color = \"rgb(226,238,250)\">`if let`</font>那样的隐式解析可选类型。没有打出<font color = \"rgb(226,238,250)\">`it is o2`</font>是因为swift中的switch，只匹配第一个相符的case，然后就结束了，即使不写<font color = \"rgb(226,238,250)\">`break`</font>也不会跳到后面的case。\n\n扯远了，回到话题上来，既然添加<font color = \"rgb(226,238,250)\">`let`</font>不行，我们得想别的办法。这时候不妨考虑一下<font color = \"rgb(226,238,250)\">`switch`</font>语句是怎么实现的。据我个人猜测，估计类似于用了好多个if判断有没有匹配的case，那既然如此，我们给类型A重载一下<font color = \"rgb(226,238,250)\">``==`</font>运算符试试：\n\n```swift\nclass A {}\n\nfunc == (lhs: A, rhs: A) -> Bool { return true }\n\nvar o = A(); var o1 = A() ;var o2 = A()\n\nswitch o {\ncase o1:\n    print(\"it is o1\")\ncase o2:\n    print(\"it is o2\")\ndefault:\n    print(\"not o1 or o2\")\n}\n```\n\n很显然，又失败了。如果这就能搞定问题，那这篇文章也太水了。报错信息和之前一样。可问题是我们已经重载了<font color = \"rgb(226,238,250)\">`==`</font>运算符，为什么A类型还是不能饿匹配A类型呢，难道switch不用判断两个变量是否相等么。\n\nswitch作为一个多条件匹配的语句，自然是要判断变量是否相等的，不过它不是通过<font color = \"rgb(226,238,250)\">`==`</font>运算符判断，而是通过<font color = \"rgb(226,238,250)\">`~=`</font>运算符。再来看一段[官方文档](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/doc/uid/TP40014097-CH36-ID419)的解释：\n\n> An expression pattern represents the value of an expression. Expression patterns appear only in switch statement case labels.\n\n以及这句话：\n\n> The expression represented by the expression pattern is compared with the value of an input expression using the Swift standard library ~= operator. \n\n第一句解释了之前的报错，所谓的“express pattern”是指表达式的值，这个概念只在switch的case标签中有。所以之前的报错信息是说：“o1这个表达式的值(还是o1)与传入的参数o都是类型A的，但它们无法匹配”。至于为什么不能匹配，答案在第二句话中，因为o1和o的匹配是通过调用标准库中的<font color = \"rgb(226,238,250)\">`~=`</font>运算符完成的。\n\n所以，只要把重载<font color = \"rgb(226,238,250)\">`==`</font>换成重载<font color = \"rgb(226,238,250)\">`~=`</font>就可以了。改动一个字符，别的都不用改，然后程序就可以运行了。Swift默认在<font color = \"rgb(226,238,250)\">`~=`</font>运算符中调用<font color = \"rgb(226,238,250)\">`==`</font>运算符，这也就是为什么我们感觉不到匹配整数类型需要什么额外处理。但对于自定义类型来说，不重载<font color = \"rgb(226,238,250)\">`~=`</font>运算符，就算你重载了<font color = \"rgb(226,238,250)\">`==`</font>也是没用的。\n\n除此以外，还有一种解决方法，那就是让A类型实现<font color = \"rgb(226,238,250)\">`Equatable`</font>协议。这样就不需要重载<font color = \"rgb(226,238,250)\">`~=`</font>运算符了。答案就在Swift的module的最后几行：\n\n```swift\n@warn_unused_result\npublic func ~=<T : Equatable>(a: T, b: T) -> Bool\n```\n\nSwift已经为所有实现了<font color = \"rgb(226,238,250)\">`Equatable `</font>协议的类重载了<font color = \"rgb(226,238,250)\">`~=`</font>运算符。虽然实现<font color = \"rgb(226,238,250)\">`Equatable `</font>协议只要求重载<font color = \"rgb(226,238,250)\">`==`</font>运算符，但如果你不显式的注明遵守了<font color = \"rgb(226,238,250)\">`Equatable `</font>协议，swift是无法知道的。因此，如果你重载了<font color = \"rgb(226,238,250)\">`==`</font>运算符，就顺手标注一下实现了<font color = \"rgb(226,238,250)\">`Equatable `</font>协议吧，这样还有很多好处，比如<font color = \"rgb(226,238,250)\">`SequenceType`</font>的<font color = \"rgb(226,238,250)\">`split`</font>方法等。\n\n最后总结一句：\n> 能放在switch语句中的类型必须重载<font color = \"rgb(226,238,250)\">`~=`</font>运算符，或者实现<font color = \"rgb(226,238,250)\">`Equatable`</font>协议。","html":"<p>今天突然想到一个问题，让我觉得有必要总结一下switch语句。我们知道swift中的switch，远比C语言只能比较整数强大得多，但问题来了，哪些类型可以放到switch中比较呢，对象可以比较么？</p>\n\n<!--more-->\n\n<p><a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120\">官方文档</a>对switch的用法给出了这样的解释：</p>\n\n<blockquote>\n  <p>Cases can match many different patterns, including interval matches, tuples, and casts to a specific type.</p>\n</blockquote>\n\n<p>也就是说除了最常用的比较整数、字符串等等之外，switch还可以用来匹配范围、元组，转化成某个特定类型等等。但文档里这个<strong>including</strong>用的实在是无语，因为它没有指明所有可以放在switch中比较的类型，文章开头提出的问题依然没有答案。</p>\n\n<p>我们不妨动手试一下，用switch匹配对象：</p>\n\n<pre><code class=\"language-swift\">class A {\n\n}\n\nvar o  = A()  \nvar o1 = A()  \nvar o2 = A()\n\nswitch o {  \ncase o1:  \n    print(\"it is o1\")\ncase o2:  \n    print(\"it is o2\")\ndefault:  \n    print(\"not o1 or o2\")\n}\n</code></pre>\n\n<p>果然，编译器报错了：“Expression pattern of type 'A' cannot match values of type 'A'”。至少我们目前还不明白“expression pattern”是什么，怎么类型A就不能匹配类型A了。</p>\n\n<p>我们做一下改动，在<font color = \"rgb(226,238,250)\"><code>case</code></font>语句后面加上<font color = \"rgb(226,238,250)\"><code>let</code></font>：</p>\n\n<pre><code class=\"language-swift\">switch o {  \ncase let o1:  \n    print(\"it is o1\")\ncase let o2:  \n    print(\"it is o2\")\ndefault:  \n    print(\"not o1 or o2\")\n}\n</code></pre>\n\n<p>OK，编译运行，结果是：<font color = \"rgb(226,238,250)\"><code>it is o1</code></font>。这是因为<font color = \"rgb(226,238,250)\"><code>case let</code></font>不是匹配值，而是值绑定，也就是把o的值赋给临时变量o1,这在o是可选类型时很有用，类似于<font color = \"rgb(226,238,250)\"><code>if let</code></font>那样的隐式解析可选类型。没有打出<font color = \"rgb(226,238,250)\"><code>it is o2</code></font>是因为swift中的switch，只匹配第一个相符的case，然后就结束了，即使不写<font color = \"rgb(226,238,250)\"><code>break</code></font>也不会跳到后面的case。</p>\n\n<p>扯远了，回到话题上来，既然添加<font color = \"rgb(226,238,250)\"><code>let</code></font>不行，我们得想别的办法。这时候不妨考虑一下<font color = \"rgb(226,238,250)\"><code>switch</code></font>语句是怎么实现的。据我个人猜测，估计类似于用了好多个if判断有没有匹配的case，那既然如此，我们给类型A重载一下<font color = \"rgb(226,238,250)\"><code>`==</code></font>运算符试试：</p>\n\n<p><pre><code class=\"language-swift\">switch o {  \ncase let o1:  \n    print(\"it is o1\")\ncase let o2:  \n    print(\"it is o2\")\ndefault:  \n    print(\"not o1 or o2\")\n}\n</code></pre></p>\n\n<p>很显然，又失败了。如果这就能搞定问题，那这篇文章也太水了。报错信息和之前一样。可问题是我们已经重载了<font color = \"rgb(226,238,250)\"><code>==</code></font>运算符，为什么A类型还是不能饿匹配A类型呢，难道switch不用判断两个变量是否相等么。</p>\n\n<p>switch作为一个多条件匹配的语句，自然是要判断变量是否相等的，不过它不是通过<font color = \"rgb(226,238,250)\"><code>==</code></font>运算符判断，而是通过<font color = \"rgb(226,238,250)\"><code>~=</code></font>运算符。再来看一段<a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/doc/uid/TP40014097-CH36-ID419\">官方文档</a>的解释：</p>\n\n<blockquote>\n  <p>An expression pattern represents the value of an expression. Expression patterns appear only in switch statement case labels.</p>\n</blockquote>\n\n<p>以及这句话：</p>\n\n<blockquote>\n  <p>The expression represented by the expression pattern is compared with the value of an input expression using the Swift standard library ~= operator. </p>\n</blockquote>\n\n<p>第一句解释了之前的报错，所谓的“express pattern”是指表达式的值，这个概念只在switch的case标签中有。所以之前的报错信息是说：“o1这个表达式的值(还是o1)与传入的参数o都是类型A的，但它们无法匹配”。至于为什么不能匹配，答案在第二句话中，因为o1和o的匹配是通过调用标准库中的<font color = \"rgb(226,238,250)\"><code>~=</code></font>运算符完成的。</p>\n\n<p>所以，只要把重载<font color = \"rgb(226,238,250)\"><code>==</code></font>换成重载<font color = \"rgb(226,238,250)\"><code>~=</code></font>就可以了。改动一个字符，别的都不用改，然后程序就可以运行了。Swift默认在<font color = \"rgb(226,238,250)\"><code>~=</code></font>运算符中调用<font color = \"rgb(226,238,250)\"><code>==</code></font>运算符，这也就是为什么我们感觉不到匹配整数类型需要什么额外处理。但对于自定义类型来说，不重载<font color = \"rgb(226,238,250)\"><code>~=</code></font>运算符，就算你重载了<font color = \"rgb(226,238,250)\"><code>==</code></font>也是没用的。</p>\n\n<p>除此以外，还有一种解决方法，那就是让A类型实现<font color = \"rgb(226,238,250)\"><code>Equatable</code></font>协议。这样就不需要重载<font color = \"rgb(226,238,250)\"><code>~=</code></font>运算符了。答案就在Swift的module的最后几行：</p>\n\n<p><code>it is o1</code></p>\n\n<p>Swift已经为所有实现了<font color = \"rgb(226,238,250)\"><code>Equatable</code></font>协议的类重载了<font color = \"rgb(226,238,250)\"><code>~=</code></font>运算符。虽然实现<font color = \"rgb(226,238,250)\"><code>Equatable</code></font>协议只要求重载<font color = \"rgb(226,238,250)\"><code>==</code></font>运算符，但如果你不显式的注明遵守了<font color = \"rgb(226,238,250)\"><code>Equatable</code></font>协议，swift是无法知道的。因此，如果你重载了<font color = \"rgb(226,238,250)\"><code>==</code></font>运算符，就顺手标注一下实现了<font color = \"rgb(226,238,250)\"><code>Equatable</code></font>协议吧，这样还有很多好处，比如<font color = \"rgb(226,238,250)\"><code>SequenceType</code></font>的<font color = \"rgb(226,238,250)\"><code>split</code></font>方法等。</p>\n\n<p>最后总结一句：</p>\n\n<blockquote>\n  <p>能放在switch语句中的类型必须重载<font color = \"rgb(226,238,250)\"><code>~=</code></font>运算符，或者实现<font color = \"rgb(226,238,250)\"><code>Equatable</code></font>协议。</p>\n</blockquote>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:07:37.000Z","created_by":1,"updated_at":"2016-01-14T08:11:52.000Z","updated_by":1,"published_at":"2015-12-17T08:07:00.000Z","published_by":1},{"id":9,"uuid":"3bec92a5-3cc5-47ae-8f3e-b61ccf633156","title":"史上最简单的UIScrollView+Autolayout出坑指南","slug":"uiscrollviewwithautolayout","markdown":"网上有很多使用Storyboard完成<font color = \"rgb(226,238,250)\">`UIScrollview`</font>的例子，但是纯代码的例子却不多。有限的一些例子大多也是外国开发者用VFL写的。而这篇文章基于swift语言和SnapKit分析了如何用纯代码加Autolayout写<font color = \"rgb(226,238,250)\">`UIScrollview`</font>，完整代码已经上传到我的[github](https://github.com/649395594/MySampleCode/tree/master/AutolayoutScrollViewInCode)。\n\n在正文中，我会分析其中的关键代码。对于Autolayout，**绝对不可取**的态度是不停的试几个约束，一旦发现好用，也不管其原理，就放手不管了。事实上，我们写的每一个约束，都要明白它存在的价值是什么，要做到不写一个无用的约束，不漏一个必要的约束，明白为什么某种写法有效，而另一种写法就无效。\n\n废话不多说，估计大家用<font color = \"rgb(226,238,250)\">`UIScrollview`</font>时，都有过被Autolayout坑的经历，要么是布局不对，要么不能滑动，以及其他匪夷所思的bug。这与Autolayout和<font color = \"rgb(226,238,250)\">`UIScrollview`</font>各自的特性有关。\n\n# 理论分析\n\n首先，我们知道Autolayout改变了传统的以frame为主的布局思想。它其实是一种相对布局，核心思想是视图与视图之间的位置关系。比如，我们可以根据矩形的起始横坐标、纵坐标、长和宽这四个变量确定它的位置。或者，如果已经确定矩形A的位置，只要知道矩形B每条边的和A对应边之间的距离，也能确定B的位置。前者就是frame的思想，它基于绝对数值，而后者是Autolayout的思想，它基于偏移量的概念。\n\n其次，<font color = \"rgb(226,238,250)\">`UIScrollview`</font>有自己的frame也就是我们在屏幕上能看到的区域。它还有一个<font color = \"rgb(226,238,250)\">`contentSize `</font>的概念。在使用frame布局的时候，我们一般先设置好子视图的位置，最后再设置<font color = \"rgb(226,238,250)\">`contentSize `</font>,它会将所有的子视图包含在内。于是通过滑动，我们就可以在有限的布局中，看到所有的内容了。\n\n但是在Autolayout时代，为了简化布局，我们希望<font color = \"rgb(226,238,250)\">`contentSize `</font>能够自动设置。比如有一个scrollView，它有两个子视图。frame分别为(x: 0, y: 0, width: 10, height: 10)和(x: 10, y: 0, width: 10, height: 10)，那么我们自然会认为这两个视图左右并排排列，<font color = \"rgb(226,238,250)\">`contentSize `</font>为(x: 0, y: 0, width: 20, height: 10)：\n\n![自动计算contentSize](http://7xonij.com1.z0.glb.clouddn.com/Autolayout+Scrollview/sample1.png)\n\n这种把若干个子视图合并，得出<font color = \"rgb(226,238,250)\">`contentSize `</font>的能力，人类是天生具备的，但是计算机却不是这样。仅凭以上信息，程序无法推断出真正的<font color = \"rgb(226,238,250)\">`contentSize `</font>。原因在于，我们没有明确的告诉系统，在这两个子视图拼接而成的区域以外，还有没有区域应该被<font color = \"rgb(226,238,250)\">`contentSize `</font>包含。\n\n也就是说，<font color = \"rgb(226,238,250)\">`contentSize `</font>也有可能是下图中的阴影部分：\n\n![更大的contentSize](http://7xonij.com1.z0.glb.clouddn.com/Autolayout+Scrollview/sample2.png)\n\n如果需要指定<font color = \"rgb(226,238,250)\">`contentSize `</font>就是两个正方形拼接而成的区域，我们还需要提供四个信息：\n\n1. 左边的正方形的左侧的边，距离contentSize左边的距离为0\n2. 右边的正方形的右侧的边，距离contentSize右边的距离为0\n\n……\n\n通过以上的分析，我们可以看到，其实<font color = \"rgb(226,238,250)\">`contentSize `</font>是依赖于子视图自身的大小，和上下左右四个方向的留白大小计算出的。而<font color = \"rgb(226,238,250)\">`UIScrollview`</font>的leading/trailing/top/bottom是相对于它的<font color = \"rgb(226,238,250)\">`contentSize `</font>而不是`bounds`来确定的。所以如果你写这样的代码，布局是肯定不会生效的：\n\n```swift\nsubview.snp_makeConstraints { (make) -> Void in\n    make.edges.equalTo(scrollView).offset(5)\n}\n```\n\n因为我们其实是在根据<font color = \"rgb(226,238,250)\">`UIScrollview`</font>的leading/trailing/top/bottom来确定子视图的位置，而我们已经分析过，<font color = \"rgb(226,238,250)\">`UIScrollview`</font>的leading/trailing/top/bottom是相对于自己的<font color = \"rgb(226,238,250)\">`contentSize `</font>而言的。而<font color = \"rgb(226,238,250)\">`contentSize `</font>又是根据子视图位置决定的。这就变成了一种你依赖我，我又依赖你的情况。\n\n为了打破这种循环依赖，为子视图添加约束的**两个要求**是：\n\n1. 它不依赖于任何与<font color = \"rgb(226,238,250)\">scrollview</font>有关布局，也就是不能参考<font color = \"rgb(226,238,250)\">scrollview</font>的位置和大小。\n2. 它不仅要确定过自己的大小，还要确定自己与<font color = \"rgb(226,238,250)\">`contentSize `</font>四周的距离。\n\n\n第二个要求意思是说，正常使用autolayout时，我们确定一个矩形在水平方向上的范围，只要知道它的左边距离它左边的矩形有多远，以及它有多宽即可。但是在<font color = \"rgb(226,238,250)\">`UIScrollView `中布局时，还需要告诉`UIScrollView `</font>，它的右边距离右边的视图有多远。这样<font color = \"rgb(226,238,250)\">`contentSize `</font>才能确定。否则<font color = \"rgb(226,238,250)\">`UIScrollView `</font>就不知道<font color = \"rgb(226,238,250)\">`contentSize `</font>向右可以延伸多少。在竖直方向上也是同理。\n\n**这两大要求一定要牢记！**接下来我们的代码都将围绕如何满足这两大要求展开。\n\n# 动手实践\n\n明白了问题的理论背景后，我们通过一个具体的需求，来看看正确的代码怎么写，以下面这个效果为例：\n\n![任务目标](http://7xonij.com1.z0.glb.clouddn.com/Autolayout+Scrollview/1.pic.png)\n\n如图所示，中间是一个<font color = \"rgb(226,238,250)\">`UIScrollview`</font>,它的背景颜色是黄色。红色部分我们称之为`box`，它是一个普通的，红色背景的`UIView`。也就是说我们向<font color = \"rgb(226,238,250)\">`UIScrollview`</font>中添加了多个`box`，每个子`box`之间间隔一定距离。我们分步实现这个功能\n\n## 使用container\n\n首先我们介绍一种使用Container的方法。\n\n###第一步：为scrollView添加约束\n\n\n```swift\nlet scrollView = UIScrollView()\nview.addSubview(scrollView)\nscrollView.snp_makeConstraints { (make) -> Void in\n    make.centerY.equalTo(view.snp_centerY)\n    make.left.right.equalTo(view)\n    make.height.equalTo(topScrollHeight)\n}\n```\n\n我们之前说过，使用Autolayout时，不用考虑frame布局。所以直接创建一个<font color = \"rgb(226,238,250)\">`scrollview `</font>对象。需要先把<font color = \"rgb(226,238,250)\">`scrollview `</font>添加到父视图上才能添加约束。\n\n对<font color = \"rgb(226,238,250)\">`scrollview `</font>添加约束没有什么难点，就像我们给其他视图添加约束一样。这里表示`scrollView`和父视图左右对齐，居中显示。\n\n###第二步：为container添加约束\n\n```swift\nscrollView.addSubview(containerView)\ncontainerView.snp_makeConstraints { (make) -> Void in\n    make.edges.equalTo(scrollView)\n    make.height.equalTo(topScrollHeight)\n}\n```\n\n这里对<font color = \"rgb(226,238,250)\">`container `</font>的约束非常重要，第一个约束表示自己上、下、左、右和<font color = \"rgb(226,238,250)\">`contentSize `</font>的距离为0，因此只要<font color = \"rgb(226,238,250)\">`container `</font>的大小确定，<font color = \"rgb(226,238,250)\">`contentSize `</font>也就可以确定了，因为此时它和<font color = \"rgb(226,238,250)\">`container `</font>大小、位置完全相同。\n\n第二个约束直接通过一个数值，确定<font color = \"rgb(226,238,250)\">`container `</font>的高度。避免了依赖<font color = \"rgb(226,238,250)\">`scrollview `</font>布局。这样一来，<font color = \"rgb(226,238,250)\">`scrollview `</font>就变成水平的了。<font color = \"rgb(226,238,250)\">`container `</font>的宽度直接决定了<font color = \"rgb(226,238,250)\">`scrollview `</font>的宽度。\n\n### 第三步：添加box\n\n```swift\nfor i in 0...5 {\n    let box = UIView()\n    containerView.addSubview(box)\n    \n    box.snp_makeConstraints(closure: { (make) -> Void in\n        make.top.height.equalTo(containerView)  // 确定top和height之后，box在竖直方向上完全确定\n        make.width.equalTo(boxWidth)\t\t//确定width后，只要再确定left，就可以在水平方向上完全确定\n        if i == 0 {\n            make.left.equalTo(containerView).offset(boxGap / 2)  //第一个box的left单独处理\n        }\n        else if let previousBox = containerView.subviews[i - 1] as? UIView{\n            make.left.equalTo(previousBox.snp_right).offset(boxGap)  // 在前一个box右侧15个距离\n        }\n        if i == 5 {\n            containerView.snp_makeConstraints(closure: { (make) -> Void in\n                make.right.equalTo(box)  // 确定container的右侧边界。\n            })\n        }\n    })\n}\n```\n\n对`box`的约束看似复杂，其实非常简单。因为<font color = \"rgb(226,238,250)\">`scrollview `</font>在Autolayout下的布局，难点就在于子视图布局时约束比较多。但现在，我们通过一个<font color = \"rgb(226,238,250)\">`container `</font>已经隔离了，也就说我们又回归了常规的Autolayout布局。以水平方向为例，我们只要确定`left`和`width`即可。\n\n在最后一个`if`语句中，我们为<font color = \"rgb(226,238,250)\">`container `</font>添加了右侧的约束。这样就确定了<font color = \"rgb(226,238,250)\">`container `</font>的宽度。由于<font color = \"rgb(226,238,250)\">`container `</font>封装了所有的`box`，所以对于<font color = \"rgb(226,238,250)\">`scrollview `</font>来说，它的子视图只有一个，就是<font color = \"rgb(226,238,250)\">`container `</font>，而<font color = \"rgb(226,238,250)\">`container `</font>自身的大小，上下左右四个方向和<font color = \"rgb(226,238,250)\">`contentSize `</font>距离在之前的约束中已经被定义为0，<font color = \"rgb(226,238,250)\">`contentSize `</font>也就可以确定了。\n\n##使用外部视图\n\n除了使用<font color = \"rgb(226,238,250)\">`container `</font>以外，我们还可以使用外部的视图确定子视图的位置。这种方法，步骤较少，和之前一样，第一步是创建`scrollView`并添加约束。接下来我们直接添加子视图：\n\n```swift\nbox.snp_makeConstraints(closure: { (make) -> Void in\n    make.top.equalTo(0)\n    make.bottom.equalTo(view).offset(-(ScreenHeight - topScrollHeight) / 2)  // This bottom can be incorret when device is rotated\n    make.height.equalTo(topScrollHeight)\n    \n    make.width.equalTo(boxWidth)\n    if i == 0 {\n        make.left.equalTo(boxGap / 2)\n    }\n    else if let previousBox = scrollView.subviews[i - 1] as? UIView{\n        make.left.equalTo(previousBox.snp_right).offset(boxGap)\n    }\n    \n    if i == 5 {\n        make.right.equalTo(scrollView)\n    }\n})\n```\n\n这时候，`box`是直接add到`scrollView`上的。我们直接指定它的`top`为0。前三个约束分别指定了`box`的顶部、底部和高度。这样就在竖直方向上满足了两大要求中的第二个要求。对于`bottom`的约束，它的参考物是`view`，这就是所谓的外部视图。\n\n接下来我们分别为`width`和`left`添加了约束。而且只要对最后一个`box`添加`right`约束即可在水平方向上满足第二个要求。由于我们的布局依赖于外部的视图，所以自然满足第一个要求，因此这种写法也是可以的。\n\n\n## Container与外部视图的优缺点\n\n与<font color = \"rgb(226,238,250)\">`container `</font>相比，使用外部视图出了代码量可能略少以外，我实在想不到它还有什么优点。\n\n首先，一旦我们使用了<font color = \"rgb(226,238,250)\">`container `</font>，首先它天然满足第一个要求，因为它并没有进行布局，只是让<font color = \"rgb(226,238,250)\">`contentSize `</font>与自己等大，然后设置自己的大小。而且它几乎已经满足了第二个要求。只要我们最后确定它的宽度或高度即可。其次，在<font color = \"rgb(226,238,250)\">`container `</font>内部，子视图布局不用考虑满足第二个要求，因为<font color = \"rgb(226,238,250)\">`container `</font>已经隔离了这一切，我们要做的只是按照习惯，确定子视图的位置，这样<font color = \"rgb(226,238,250)\">`container `</font>的位置也会随着子视图确定。\n\n其次，我发现的使用外部视图布局的缺点就至少有三个：\n\n1. 它依赖外部视图进行定位，这样的写法不够优雅\n2. 观察代码中对于bottom属性的约束，它不能完美适配旋转屏幕后的视图。因为此时的屏幕长和宽会对调。而且目测没有什么好的解决方案。\n3. 布局过程中容易踩到坑，比如对于`left`属性的约束，如果你的代码是这样的：\n\n```swift\nmake.left.equalTo(view).offset(boxGap / 2)\n```\n\n它和原来的写法几乎是等价的。但你仔细分析，或者试着滑动`scrollView`时，一定会大吃一惊。如果你不能一眼看出来这种写法的问题所在，那我建议你运行代码体验一下，并且以后尽量避免这种写法。\n\n#### 最后重复一下，代码地址在[https://github.com/649395594/MySampleCode/tree/master/AutolayoutScrollViewInCode](https://github.com/649395594/MySampleCode/tree/master/AutolayoutScrollViewInCode)，可以下载下来把玩研究一番，如果觉得对你有帮助，请给一个star。","html":"<p>网上有很多使用Storyboard完成<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>的例子，但是纯代码的例子却不多。有限的一些例子大多也是外国开发者用VFL写的。而这篇文章基于swift语言和SnapKit分析了如何用纯代码加Autolayout写<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>，完整代码已经上传到我的<a href=\"https://github.com/649395594/MySampleCode/tree/master/AutolayoutScrollViewInCode\">github</a>。</p>\n\n<p>在正文中，我会分析其中的关键代码。对于Autolayout，<strong>绝对不可取</strong>的态度是不停的试几个约束，一旦发现好用，也不管其原理，就放手不管了。事实上，我们写的每一个约束，都要明白它存在的价值是什么，要做到不写一个无用的约束，不漏一个必要的约束，明白为什么某种写法有效，而另一种写法就无效。</p>\n\n<p>废话不多说，估计大家用<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>时，都有过被Autolayout坑的经历，要么是布局不对，要么不能滑动，以及其他匪夷所思的bug。这与Autolayout和<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>各自的特性有关。</p>\n\n<h1 id=\"\">理论分析</h1>\n\n<p>首先，我们知道Autolayout改变了传统的以frame为主的布局思想。它其实是一种相对布局，核心思想是视图与视图之间的位置关系。比如，我们可以根据矩形的起始横坐标、纵坐标、长和宽这四个变量确定它的位置。或者，如果已经确定矩形A的位置，只要知道矩形B每条边的和A对应边之间的距离，也能确定B的位置。前者就是frame的思想，它基于绝对数值，而后者是Autolayout的思想，它基于偏移量的概念。</p>\n\n<p>其次，<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>有自己的frame也就是我们在屏幕上能看到的区域。它还有一个<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>的概念。在使用frame布局的时候，我们一般先设置好子视图的位置，最后再设置<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>,它会将所有的子视图包含在内。于是通过滑动，我们就可以在有限的布局中，看到所有的内容了。</p>\n\n<p>但是在Autolayout时代，为了简化布局，我们希望<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>能够自动设置。比如有一个scrollView，它有两个子视图。frame分别为(x: 0, y: 0, width: 10, height: 10)和(x: 10, y: 0, width: 10, height: 10)，那么我们自然会认为这两个视图左右并排排列，<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>为(x: 0, y: 0, width: 20, height: 10)：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Autolayout+Scrollview/sample1.png\" alt=\"自动计算contentSize\" /></p>\n\n<p>这种把若干个子视图合并，得出<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>的能力，人类是天生具备的，但是计算机却不是这样。仅凭以上信息，程序无法推断出真正的<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>。原因在于，我们没有明确的告诉系统，在这两个子视图拼接而成的区域以外，还有没有区域应该被<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>包含。</p>\n\n<p>也就是说，<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>也有可能是下图中的阴影部分：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Autolayout+Scrollview/sample2.png\" alt=\"更大的contentSize\" /></p>\n\n<p>如果需要指定<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>就是两个正方形拼接而成的区域，我们还需要提供四个信息：</p>\n\n<ol>\n<li>左边的正方形的左侧的边，距离contentSize左边的距离为0  </li>\n<li>右边的正方形的右侧的边，距离contentSize右边的距离为0</li>\n</ol>\n\n<p>……</p>\n\n<p>通过以上的分析，我们可以看到，其实<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>是依赖于子视图自身的大小，和上下左右四个方向的留白大小计算出的。而<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>的leading/trailing/top/bottom是相对于它的<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>而不是<code>bounds</code>来确定的。所以如果你写这样的代码，布局是肯定不会生效的：</p>\n\n<pre><code class=\"language-swift\">subview.snp_makeConstraints { (make) -&gt; Void in  \n    make.edges.equalTo(scrollView).offset(5)\n}\n</code></pre>\n\n<p>因为我们其实是在根据<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>的leading/trailing/top/bottom来确定子视图的位置，而我们已经分析过，<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>的leading/trailing/top/bottom是相对于自己的<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>而言的。而<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>又是根据子视图位置决定的。这就变成了一种你依赖我，我又依赖你的情况。</p>\n\n<p>为了打破这种循环依赖，为子视图添加约束的<strong>两个要求</strong>是：</p>\n\n<ol>\n<li>它不依赖于任何与<font color = \"rgb(226,238,250)\">scrollview</font>有关布局，也就是不能参考<font color = \"rgb(226,238,250)\">scrollview</font>的位置和大小。  </li>\n<li>它不仅要确定过自己的大小，还要确定自己与<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>四周的距离。</li>\n</ol>\n\n<p>第二个要求意思是说，正常使用autolayout时，我们确定一个矩形在水平方向上的范围，只要知道它的左边距离它左边的矩形有多远，以及它有多宽即可。但是在<font color = \"rgb(226,238,250)\"><code>UIScrollView</code>中布局时，还需要告诉<code>UIScrollView</code></font>，它的右边距离右边的视图有多远。这样<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>才能确定。否则<font color = \"rgb(226,238,250)\"><code>UIScrollView</code></font>就不知道<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>向右可以延伸多少。在竖直方向上也是同理。</p>\n\n<p><strong>这两大要求一定要牢记！</strong>接下来我们的代码都将围绕如何满足这两大要求展开。</p>\n\n<h1 id=\"\">动手实践</h1>\n\n<p>明白了问题的理论背景后，我们通过一个具体的需求，来看看正确的代码怎么写，以下面这个效果为例：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Autolayout+Scrollview/1.pic.png\" alt=\"任务目标\" /></p>\n\n<p>如图所示，中间是一个<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>,它的背景颜色是黄色。红色部分我们称之为<code>box</code>，它是一个普通的，红色背景的<code>UIView</code>。也就是说我们向<font color = \"rgb(226,238,250)\"><code>UIScrollview</code></font>中添加了多个<code>box</code>，每个子<code>box</code>之间间隔一定距离。我们分步实现这个功能</p>\n\n<h2 id=\"container\">使用container</h2>\n\n<p>首先我们介绍一种使用Container的方法。</p>\n\n<h3 id=\"scrollview\">第一步：为scrollView添加约束</h3>\n\n<pre><code class=\"language-swift\">let scrollView = UIScrollView()  \nview.addSubview(scrollView)  \nscrollView.snp_makeConstraints { (make) -&gt; Void in  \n    make.centerY.equalTo(view.snp_centerY)\n    make.left.right.equalTo(view)\n    make.height.equalTo(topScrollHeight)\n}\n</code></pre>\n\n<p>我们之前说过，使用Autolayout时，不用考虑frame布局。所以直接创建一个<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>对象。需要先把<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>添加到父视图上才能添加约束。</p>\n\n<p>对<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>添加约束没有什么难点，就像我们给其他视图添加约束一样。这里表示<code>scrollView</code>和父视图左右对齐，居中显示。</p>\n\n<h3 id=\"container\">第二步：为container添加约束</h3>\n\n<pre><code class=\"language-swift\">scrollView.addSubview(containerView)  \ncontainerView.snp_makeConstraints { (make) -&gt; Void in  \n    make.edges.equalTo(scrollView)\n    make.height.equalTo(topScrollHeight)\n}\n</code></pre>\n\n<p>这里对<font color = \"rgb(226,238,250)\"><code>container</code></font>的约束非常重要，第一个约束表示自己上、下、左、右和<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>的距离为0，因此只要<font color = \"rgb(226,238,250)\"><code>container</code></font>的大小确定，<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>也就可以确定了，因为此时它和<font color = \"rgb(226,238,250)\"><code>container</code></font>大小、位置完全相同。</p>\n\n<p>第二个约束直接通过一个数值，确定<font color = \"rgb(226,238,250)\"><code>container</code></font>的高度。避免了依赖<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>布局。这样一来，<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>就变成水平的了。<font color = \"rgb(226,238,250)\"><code>container</code></font>的宽度直接决定了<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>的宽度。</p>\n\n<h3 id=\"box\">第三步：添加box</h3>\n\n<pre><code class=\"language-swift\">for i in 0...5 {  \n    let box = UIView()\n    containerView.addSubview(box)\n\n    box.snp_makeConstraints(closure: { (make) -&gt; Void in\n        make.top.height.equalTo(containerView)  // 确定top和height之后，box在竖直方向上完全确定\n        make.width.equalTo(boxWidth)        //确定width后，只要再确定left，就可以在水平方向上完全确定\n        if i == 0 {\n            make.left.equalTo(containerView).offset(boxGap / 2)  //第一个box的left单独处理\n        }\n        else if let previousBox = containerView.subviews[i - 1] as? UIView{\n            make.left.equalTo(previousBox.snp_right).offset(boxGap)  // 在前一个box右侧15个距离\n        }\n        if i == 5 {\n            containerView.snp_makeConstraints(closure: { (make) -&gt; Void in\n                make.right.equalTo(box)  // 确定container的右侧边界。\n            })\n        }\n    })\n}\n</code></pre>\n\n<p>对<code>box</code>的约束看似复杂，其实非常简单。因为<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>在Autolayout下的布局，难点就在于子视图布局时约束比较多。但现在，我们通过一个<font color = \"rgb(226,238,250)\"><code>container</code></font>已经隔离了，也就说我们又回归了常规的Autolayout布局。以水平方向为例，我们只要确定<code>left</code>和<code>width</code>即可。</p>\n\n<p>在最后一个<code>if</code>语句中，我们为<font color = \"rgb(226,238,250)\"><code>container</code></font>添加了右侧的约束。这样就确定了<font color = \"rgb(226,238,250)\"><code>container</code></font>的宽度。由于<font color = \"rgb(226,238,250)\"><code>container</code></font>封装了所有的<code>box</code>，所以对于<font color = \"rgb(226,238,250)\"><code>scrollview</code></font>来说，它的子视图只有一个，就是<font color = \"rgb(226,238,250)\"><code>container</code></font>，而<font color = \"rgb(226,238,250)\"><code>container</code></font>自身的大小，上下左右四个方向和<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>距离在之前的约束中已经被定义为0，<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>也就可以确定了。</p>\n\n<h2 id=\"\">使用外部视图</h2>\n\n<p>除了使用<font color = \"rgb(226,238,250)\"><code>container</code></font>以外，我们还可以使用外部的视图确定子视图的位置。这种方法，步骤较少，和之前一样，第一步是创建<code>scrollView</code>并添加约束。接下来我们直接添加子视图：</p>\n\n<pre><code class=\"language-swift\">box.snp_makeConstraints(closure: { (make) -&gt; Void in  \n    make.top.equalTo(0)\n    make.bottom.equalTo(view).offset(-(ScreenHeight - topScrollHeight) / 2)  // This bottom can be incorret when device is rotated\n    make.height.equalTo(topScrollHeight)\n\n    make.width.equalTo(boxWidth)\n    if i == 0 {\n        make.left.equalTo(boxGap / 2)\n    }\n    else if let previousBox = scrollView.subviews[i - 1] as? UIView{\n        make.left.equalTo(previousBox.snp_right).offset(boxGap)\n    }\n\n    if i == 5 {\n        make.right.equalTo(scrollView)\n    }\n})\n</code></pre>\n\n<p>这时候，<code>box</code>是直接add到<code>scrollView</code>上的。我们直接指定它的<code>top</code>为0。前三个约束分别指定了<code>box</code>的顶部、底部和高度。这样就在竖直方向上满足了两大要求中的第二个要求。对于<code>bottom</code>的约束，它的参考物是<code>view</code>，这就是所谓的外部视图。</p>\n\n<p>接下来我们分别为<code>width</code>和<code>left</code>添加了约束。而且只要对最后一个<code>box</code>添加<code>right</code>约束即可在水平方向上满足第二个要求。由于我们的布局依赖于外部的视图，所以自然满足第一个要求，因此这种写法也是可以的。</p>\n\n<h2 id=\"container\">Container与外部视图的优缺点</h2>\n\n<p>与<font color = \"rgb(226,238,250)\"><code>container</code></font>相比，使用外部视图出了代码量可能略少以外，我实在想不到它还有什么优点。</p>\n\n<p>首先，一旦我们使用了<font color = \"rgb(226,238,250)\"><code>container</code></font>，首先它天然满足第一个要求，因为它并没有进行布局，只是让<font color = \"rgb(226,238,250)\"><code>contentSize</code></font>与自己等大，然后设置自己的大小。而且它几乎已经满足了第二个要求。只要我们最后确定它的宽度或高度即可。其次，在<font color = \"rgb(226,238,250)\"><code>container</code></font>内部，子视图布局不用考虑满足第二个要求，因为<font color = \"rgb(226,238,250)\"><code>container</code></font>已经隔离了这一切，我们要做的只是按照习惯，确定子视图的位置，这样<font color = \"rgb(226,238,250)\"><code>container</code></font>的位置也会随着子视图确定。</p>\n\n<p>其次，我发现的使用外部视图布局的缺点就至少有三个：</p>\n\n<ol>\n<li>它依赖外部视图进行定位，这样的写法不够优雅  </li>\n<li>观察代码中对于bottom属性的约束，它不能完美适配旋转屏幕后的视图。因为此时的屏幕长和宽会对调。而且目测没有什么好的解决方案。  </li>\n<li>布局过程中容易踩到坑，比如对于<code>left</code>属性的约束，如果你的代码是这样的：</li>\n</ol>\n\n<pre><code class=\"language-swift\">make.left.equalTo(view).offset(boxGap / 2)  \n</code></pre>\n\n<p>它和原来的写法几乎是等价的。但你仔细分析，或者试着滑动<code>scrollView</code>时，一定会大吃一惊。如果你不能一眼看出来这种写法的问题所在，那我建议你运行代码体验一下，并且以后尽量避免这种写法。</p>\n\n<h4 id=\"httpsgithubcom649395594mysamplecodetreemasterautolayoutscrollviewincodehttpsgithubcom649395594mysamplecodetreemasterautolayoutscrollviewincodestar\">最后重复一下，代码地址在<a href=\"https://github.com/649395594/MySampleCode/tree/master/AutolayoutScrollViewInCode\">https://github.com/649395594/MySampleCode/tree/master/AutolayoutScrollViewInCode</a>，可以下载下来把玩研究一番，如果觉得对你有帮助，请给一个star。</h4>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:09:08.000Z","created_by":1,"updated_at":"2016-01-14T08:11:20.000Z","updated_by":1,"published_at":"2015-12-21T08:09:00.000Z","published_by":1},{"id":10,"uuid":"c22d5ff7-6e0d-4d24-bde8-cda39818c09f","title":"程序员的自我修养读书笔记","slug":"cheng-xu-yuan-de-zi-wo-xiu-yang-du-shu-bi-ji","markdown":"最初买《程序员的自我修养》这本书，只因为在京东买书差一些钱，不够用优惠券。买回来以后的很长一段时间，我都以为这本书只是程序员用来调侃和自黑的。不过翻读了第一章以后，我就发现自己错的太离谱。我觉得即使一个不使用C/C++，甚至是写解释性语言(如JS等)的程序员，也有必要抽空读一读这本书。作为使用OC或Swift的iOS开发者，我认为这本书是必读的。\n\n所以这篇文章会简单梳理一下《程序员的自我修养》这本书的脉络结构，如果时间有限，又想快速阅读这本书，可以先看看这篇文章。标注了页号的地方表示详细知识可以在给出的页数获取详细的知识。为了简化问题，有些地方会省略一些原文中的细节，一切为了保证读者快速了解这本书。\n\n对于不是专门从事C和底层开发的程序猿来说，个人认为完整的看完本书的所有内容是不太现实，也不太必要的。这本书中有两大部分的知识点对于新手来说非常有必要了解：\n\n1. 一段源代码是怎么变成最后可执行的程序的\n2. 一个进程，在内存中是什么样的\n\n带着这两个问题去读书，收获会更大。在阅读原书之前，这里有几个相关内容的总结，我尽可能用简单的语言介绍某些知识背景。即使不能完全看懂，也有利于读书时的理解。\n\n<!--more-->\n\n## 从源码到程序\n\n程序最初的存在形式是源代码，也就是若干个`.c`文件。它要想变成一个可执行的程序，需要以下几个步骤：\n\n1. 预编译(P39)：负责这一步工作的叫“预编译器”。它主要负责处理所有的`#define`宏定义；所有的预编译指令，比如`#if`、`#endif`等。接下来会递归处理`#include`指令，用被包含的文件替换这个预编译指令。`.c`文件经过预编译，变为`.i`文件。\n2. 编译(P42)：这一步由编译器负责，主要又由词法分析、语法分析、语义分析、优化和生成汇编代码五个部分：\n\n\t* 词法分析：识别源代码中的各种括号、数字、标点等。比如有`(`但没有`)`，这一步就能发现错误\n\t* 语法分析：这一步会生成语法树，比如`2+4`就是一颗根节点为`+`，左右叶子节点分别为`2`和`4`的语法树。如果你只是写`2+`，在这一步就会报错。\n\t* 语义分析：这一步主要考虑类型声明、匹配和转换。比如你写`2 * \"3\"`在这一步就会报错\n\t* 中间语言生成：这一步会生成平台无关的三地址码，比如`2 + 3`会写成`t1 = 2 + 3`，同时也会把这样在编译期就可以确定的表达式进行优化\n\t* 目标代码生成：编译器根据三地址码生成依赖于目标机器的目标机器代码，也就是汇编语言。\n\n\t`.i`文件经过编译，得到汇编文件，后缀是`.s`\n\t\n3. 汇编(P40)：这一步由汇编器负责，将汇编语言转换成机器可以执行的语言(完全由0和1组成).汇编文件经过汇编，变成目标文件，后缀为`.o`。\n4. 链接(P41)：这一步是这本书的重点。之前的几个步骤，都是以`.c`文件为基本单位，一个`.c`源代码文件最终被汇编，生成目标文件。这一步就是处理如何把多个目标文件链接起来。\n\t\n\t考虑一个`.c`文件中，用到了另一个`.c`文件中的变量或函数。在编译这个文件时，我们无法在编译期确定这个变量或函数的地址。只有在把所有目标文件链接起来以后，才能确定。链接器主要负责地址重分配、符号名称绑定和重定位。\n\t\n从源代码到程序的运行要做的远远不止编译，很多时候我们说“把程序编译一下”，是不准确的。不过编译确实是整个流程中最复杂的部分。\n\n## 软件调用层次\n\n我们把整个计算机调用结构分为四层：\n\n1. 最上层是应用层。不管是浏览器、游戏，还是我们使用的各种开发工具，如Xcode，VS，汇编器自身等，都属于这一范畴。\n2. 第二层是操作系统的运行库。我们在程序里调用系统API，比如文件读写，就是调用了第二层提供的相应服务。这种调用通过操作系统的API完成，它沟通了应用层和操作系统的运行库。这也就是为什么不管是在Mac还是Windows上编程，我们都可以调用`printf()`或`fread()`等函数。因为不同的操作系统的运行库提供了不同底层的实现，但对应用层提供的API总是一样的。\n3. 第三层是操作系统内核。操作系统的运行库通过系统调用(System Call)调用系统内核提供的函数。比如`fread`属于API，它在Linux下会调用`read()`这个系统调用，而在Windows下会调用`ReadFile()`这个系统调用。应用程序可以直接调用系统调用，但是这样一来，我们需要考虑各个操作系统下系统调用的不同，而且系统调用由于更加底层，实现起来也就更加困难。最关键的是，系统调用是通过中断来完成的，涉及到堆栈的保存与恢复，频繁的系统调用会影响性能。\n4. 第四层是硬件层。程序无法直接访问这一层，只有操作系统的内核，通过硬件厂商提供的接口才能访问。\n\n这四层之间的关系如下图所示：\n\n![层次关系](http://7xonij.com1.z0.glb.clouddn.com/自我修养/hierarchy.png)\n\n## 虚拟地址空间\n\n在程序运行的过程中，最重要的概念就是虚拟地址空间。所谓的虚拟地址空间，是指应用程序自己认为，自己所处的地址空间。它区别于物理地址空间。后者是真实存在的，比如电脑有一根8G的内存条，物理地址空间就是0~8Gb。CPU的MMU负责把虚拟地址转换成物理地址。\n\n引入虚拟地址的第一个好处是，程序员不再关心真实的物理内存空间是什么样的，理论上来说，程序员有几乎无限大的虚拟内存空间可用，最后只要建立虚拟地址和物理地址的对应关系即可。另一方面，操作系统屏蔽了物理内存空间的细节，进程无法访问到操作系统禁止访问的物理地址，也不能访问到别的进程的地址空间，这大大增强了程序安全性。\n\n由虚拟地址空间引申出来的分页(Paging)技术，大大提高了内存的使用效率。要想运行一个程序，不再需要把整个程序都放入内存中执行，我们只要保证将要执行的页在内存中即可，如果不存在则导致页错误。\n\n关于地址空间的理解非常重要，书中有很多关于内存、和地址的描述，需要我们自己分析这是虚拟地址还是物理地址。如果分析错了，理解问题会比较麻烦。\n\n## 链接与重定位\n\n我们把`foo`函数定义在另一个文件中，然后在`main.c`中调用这个函数，单独编译`main.c`后代码如下：\n\n```c\n……\n0000000000000024\tcallq\t0x29\n0000000000000029\txorl\t%ecx, %ecx\n……\n```\n\n可以看到，本该调用`foo`函数的地方，我们直接调用了下一条命令，但是当`main.o`和`foo.o`链接起来后，就变成了：\n\n```c\n0000000100000f30\tpushq\t%rbp\n0000000100000f31\tmovq\t%rsp, %rbp\n0000000100000f34\tmovl\t$0x7b, %eax\n0000000100000f39\tmovl\t%edi, -0x4(%rbp)\n0000000100000f3c\tmovl\t%esi, -0x8(%rbp)\n0000000100000f3f\tpopq\t%rbp\n//以上为foo函数实现\n……\n0000000100000f74\tcallq\t0x100000f30\n0000000100000f79\txorl\t%ecx, %ecx\n……\n```\n\n这时候`foo`函数的位置就正确设置了。原因在于在`main.c`这个编译模块单独编译时，编译器无法确定`foo`的位置，只好临时用下一条指令的位置代替一下。\n\n链接器在链接过程中，就是要对这样的符号进行重定位。在重定位时，`main.o`中有`foo`函数经过修饰的符号名，同样的符号名在`foo.o`中也有，于是两者一拍即合，就这样被链接器连在了一起。`0x29`这个临时的调用地址被更新成了`0x100000f30 `。这个过程类似于拼图游戏，程序在链接时就是处理各种各样类似的问题，当所有编译模块都按照符号名完整的链接起来时，程序也就可以开始运行了。\n\n书中花了不少篇幅介绍目标文件的组成结构，其中很多都是为了重定位而准备的。一旦明白了重定位的原理和过程，在阅读相关内容时就会轻松很多。\n\n\n## 知识概要\n\n最后列出一部分知识点的简要概括和他们在书中的位置，方便读者参考：\n\n###静态链接部分\n\n这一部分主要是讨论多个`.c`文件怎么通过静态链接，得到一个静态库。\n\n* P58\n\n\t目标文件中分为若干个段，比如.text段存放代码，.data段存放存放已初始化的全局变量和局部静态变量，.bss段存放未初始化的全局变量和局部静态变量，除此以外目标文件还有很多其他的段。\n\t\n* P70\n\n\tLinux下的目标文件还有一个ELF文件头，用于汇总这个目标文件的各种信息,其中包括了ELF魔数、机器字节长度、数据存储方式、版本、运行平台、ABI版本，重定位类型、硬件平台及版本、入口地址、段表位置、段的数量等。\n\t\n* P74\n\t\n\t段表其实是一个数组，其中每一个元素都是结构体。结构体里面有段的名称、类型、加载地址、相对于文件头的偏移量，段的大小，链接信息等。\n\t\n* P79\n\n\t目标文件中还有一个重定位表。需要重定位的信息都记录在这个表里面。.text段中所有需要重定位的信息，都放在.rel.text段中。\n\t\n* P81\n\t\n\t在链接时，我们把函数名和变量都称为符号。每一个函数、变量都有自己独特的符号名，这样在链接时才能把它们对应起来。不同的语言有自己的符号修饰规则。UNIX下的C，编译出来的符号名前面加“\\_”，如函数foo在编译之后的结果为_foo。\n\t\n* P86\n\t\n\tC++的namespace就是用来避免符号名冲突。C++有一套自己的符号名修饰规则，可以通过c++filt命令还原被修饰过的符号名(demangle)。一旦了解了符号名的修饰规则，在写iOS时遇到`undefined symbol`或`duplicate symbol name`的报错，就非常好检查了。\n\t\n* P92\n\n\t符号分为强符号，和弱符号。强符号不可名称重复，弱符号（未初始化的全局变量）可以有符号名相同。对符号名的引用分为强引用和弱引用，强引用表示如果找不到符号定义会报错，弱引用不报错，默认为0或某个特殊值。\n\t\n* P99\n\n\t链接过程一般分为两步，首先地址分配，然后符号解析并重定位。\n\t\n\t由于不同的目标文件，可能含有相同的段，所以在链接过程中，我们可以合并相似段，这就是地址分配。\n\t\n\t合并完成后，所有符号的位置都可以唯一确定，此时可以就开始重定位工作了。链接完成后，我们就得到了静态库。\n\t\n* P118\n\t\n\t静态库可以看做一组目标文件的集合，同一个静态库中的不同目标文件可能相互依赖，不同的静态库也可以相互依赖。\n\t\n* P127\n\t\n\t链接控制脚本控制链接器的运行，将目标文件和库文件转化为可执行文件。链接控制脚本由链接脚本语言写成。可以认为的控制程序入口，某几个段合并，某几个段舍弃等\n\t\n### 动态装载\n\n这一部分主要是讨论经过链接后，可执行文件如何装载到内存中\n\n* P153\n\n\t有两种典型的动态装载方法：覆盖装入和页映射。覆盖装入允许互不依赖的两个模块共同享有同一块内存，在使用中互相替换。速度较慢，用时间换空间。我们常用的方案是页映射，把程序虚拟的内存空间分成多个页，由专门的页装载管理器负责管理虚拟页和物理内存中页的对应关系。\n\t\n* P157\n\n\t创建进程三步骤：首先进程自己的创建物理空间。设置好虚拟空间中各个页到物理空间里的页的映射关系（这一步可能在页错误之后发生）、然后建立虚拟空间与可执行文件的映射关系。Linux下，目标文件的每个段都有自己在虚拟内存中的位置，这叫虚拟内存区域（VMA, Virtual Memory Area），表示它装载在虚拟内存中的地址，最后指令寄存器设置为可执行文件入口。\n\t\n* P159\n\n\t进程创建后，只有物理页与虚拟页的对应关系，但是真正的指令和数据还没有放入物理页中，物理页的内存处于未分配状态。一旦访问到这个物理页，就会发生页错误。\n\t\n\t发生页错误时，操作系统立刻根据物理内存的页与虚拟内存的页的对应关系，找到这个页对应的虚拟内存，然后再查询每个段的VMA，就可以找这个页面在可执行文件中的偏移量。这时候操作系统先为物理页分配内存空间，然后把可执行文件中的数据和指令写入物理页，最后建立物理页和虚拟页联系即可。然后进程从发生页错误的地方重新执行。\n\t\n* P169\n\n\t可执行文件有很多Section，它们的大小各不相同，但有些小于页的大小，导致了空间浪费（不能连续存储不同的section是因为可能会有两个权限不同的section在同一个页中）。由于操作系统不关心每个Section的具体作用，但是关心它们的读写权限（是否可读、可写、可执行），所以往往把具有权限的Section合并成一个Segment\n\t\n* P172：\n\n\t进程运行后，操作系统会初始化进程的堆栈，其中存放了环境变量和命令行参数。这些参数被传给main函数（argc和argv两个参数对应参数数量和参数数组）\n\t\n### 动态链接\n\n* P181\n\n\t动态链接把程序按模块拆分成若干个相对独立的部分，模块之间的链接推迟到运行时。ELF的动态链接文件成为“动态共享对象（DSO）”，后缀为“.so”。动态链接的过程由动态链接器完成。动态链接可以节约内存（多个进程共享内存中的某一个模块）、方便升级（静态链接的每一个模块都会影响整个可执行文件）。\n\t\n* P188：\n\t\n\t由于动态共享对象会被多个程序使用，导致它在虚拟地址空间中的位置难以确定。不同模块的目标装载地址如果有相同的，那么同时导入这两个模块就会出问题。如果都不一样也不行，因为可能存在的模块太多了。没有那么多内存。所以动态共享对象需要在装载时重定位。\n\t\n* P191：\n\n\t装载时重定位会导致无法在多个进程间共享，目前采用的方案是地址无关代码技术。动态对象中的地址引用分为模块内部和外部，指令引用和数据引用，两两组合成四种。对于模块内部的指令或数据引用，采用相对偏移调用的方法。\n\t\n* P195：\n\n\t把地址相关需要重定位的部分放到数据段中，同时建立全局偏移表（GOT）。用.got和.got.plt表分别处理数据和函数引用。\n\t\n* P200：\n\n\t当函数第一次被用到的时候才重定位，从而提高程序运行速度。这种方法被称为延迟绑定（Lazy Binding）。Linux维护一个PLT（Procedure Linkage Table）来保存符号名和真实地址之间的对应关系\n\t\n* P208：\n\n\t动态链接中有两个重定位表.rel.dyn和.rel.plt分别对应.rel.text和.rel.data。前者对数据引用（.got）进行修正，后者对函数引用(.got.plt)进行修正。\n\t\n* P214：\n\n\t动态链接器是一个特殊共享对象，它不依赖于任何动态共享文件，且自己的重定位工作由自己完成。通过一段被称为自举（Bootstrap）的特殊代码，不用到任何静态或全部变量，完成这项工作\n\t\n#### 内存与库\n\n* P286：\n\n\ti386处理器下，栈顶有esp寄存器定位，由于栈向下生长，压栈使得栈顶地址减小\n\t\n* P287：\n\n\t栈保存了函数调用所需要的维护信息，被称为堆栈帧（Stack Frame）或活动记录，包含了函数的返回地址和函数，临时变量以及保存的上下文。ebp是帧指针指向活动记录的某一个固定位置。\n\t\n* P294：\n\n\t函数的调用方和被调用方要遵守同一个“调用惯例”。默认的cdecl惯例要求函数参数以从右到左的顺序入栈，由函数调用方负责参数的出栈。\n\t\n* P301：\n\n\t函数返回值的获取：如果是四个字节，放在eax中。4-8字节的返回值通过eax（低位）和edx（高位）联合存储。查过8字节的返回值，把返回值在栈中存放的地址放到eax中。\n\t\n* P306：\n\n\t栈上的数据在函数返回时就会被释放，全局地、动态的申请内存的方式是利用堆。如果由操作系统管理堆，由于总是进行系统调用，性能开销比较大，所以一般由应用程序“批发”一大块内存空间，然后自己进行内存管理。\n\t\n* P311：\n\n\t堆并不总是向上生长（如Windows的HeapCreate系列），调用malloc有可能产生系统调用（取决于进程预申请的空间是否足够），堆内存在进程结束后被操作系统回收，堆内存在虚拟地址空间中连续，在物理空间中可能不连续\n\t\n* P314：\n\n\t堆分配三种算法：空闲链表（简单，记录长度的字节容易被数组越界破坏）、位图（速度快（容易命中cache），稳定性好（不容易数组越界），易管理，会产生碎片，位图有可能过大）、对象池（针对固定大小的分配空间）\n\t\n* P319：\n\n\t创建进程后，操作系统把控制权交给运行库的某个入口函数，然后开始堆的构造，启动I/O，创建线程，进行全局变量构造等。然后调用main函数，main函数执行完成后，执行与之前相反的操作，进行系统调用结束进程。","html":"<p>最初买《程序员的自我修养》这本书，只因为在京东买书差一些钱，不够用优惠券。买回来以后的很长一段时间，我都以为这本书只是程序员用来调侃和自黑的。不过翻读了第一章以后，我就发现自己错的太离谱。我觉得即使一个不使用C/C++，甚至是写解释性语言(如JS等)的程序员，也有必要抽空读一读这本书。作为使用OC或Swift的iOS开发者，我认为这本书是必读的。</p>\n\n<p>所以这篇文章会简单梳理一下《程序员的自我修养》这本书的脉络结构，如果时间有限，又想快速阅读这本书，可以先看看这篇文章。标注了页号的地方表示详细知识可以在给出的页数获取详细的知识。为了简化问题，有些地方会省略一些原文中的细节，一切为了保证读者快速了解这本书。</p>\n\n<p>对于不是专门从事C和底层开发的程序猿来说，个人认为完整的看完本书的所有内容是不太现实，也不太必要的。这本书中有两大部分的知识点对于新手来说非常有必要了解：</p>\n\n<ol>\n<li>一段源代码是怎么变成最后可执行的程序的  </li>\n<li>一个进程，在内存中是什么样的</li>\n</ol>\n\n<p>带着这两个问题去读书，收获会更大。在阅读原书之前，这里有几个相关内容的总结，我尽可能用简单的语言介绍某些知识背景。即使不能完全看懂，也有利于读书时的理解。</p>\n\n<!--more-->\n\n<h2 id=\"\">从源码到程序</h2>\n\n<p>程序最初的存在形式是源代码，也就是若干个<code>.c</code>文件。它要想变成一个可执行的程序，需要以下几个步骤：</p>\n\n<ol>\n<li>预编译(P39)：负责这一步工作的叫“预编译器”。它主要负责处理所有的<code>#define</code>宏定义；所有的预编译指令，比如<code>#if</code>、<code>#endif</code>等。接下来会递归处理<code>#include</code>指令，用被包含的文件替换这个预编译指令。<code>.c</code>文件经过预编译，变为<code>.i</code>文件。  </li>\n<li><p>编译(P42)：这一步由编译器负责，主要又由词法分析、语法分析、语义分析、优化和生成汇编代码五个部分：</p>\n\n<ul><li>词法分析：识别源代码中的各种括号、数字、标点等。比如有<code>(</code>但没有<code>)</code>，这一步就能发现错误</li>\n<li>语法分析：这一步会生成语法树，比如<code>2+4</code>就是一颗根节点为<code>+</code>，左右叶子节点分别为<code>2</code>和<code>4</code>的语法树。如果你只是写<code>2+</code>，在这一步就会报错。</li>\n<li>语义分析：这一步主要考虑类型声明、匹配和转换。比如你写<code>2 * \"3\"</code>在这一步就会报错</li>\n<li>中间语言生成：这一步会生成平台无关的三地址码，比如<code>2 + 3</code>会写成<code>t1 = 2 + 3</code>，同时也会把这样在编译期就可以确定的表达式进行优化</li>\n<li>目标代码生成：编译器根据三地址码生成依赖于目标机器的目标机器代码，也就是汇编语言。</li></ul>\n\n<p><code>.i</code>文件经过编译，得到汇编文件，后缀是<code>.s</code></p></li>\n<li><p>汇编(P40)：这一步由汇编器负责，将汇编语言转换成机器可以执行的语言(完全由0和1组成).汇编文件经过汇编，变成目标文件，后缀为<code>.o</code>。  </p></li>\n<li><p>链接(P41)：这一步是这本书的重点。之前的几个步骤，都是以<code>.c</code>文件为基本单位，一个<code>.c</code>源代码文件最终被汇编，生成目标文件。这一步就是处理如何把多个目标文件链接起来。</p>\n\n<p>考虑一个<code>.c</code>文件中，用到了另一个<code>.c</code>文件中的变量或函数。在编译这个文件时，我们无法在编译期确定这个变量或函数的地址。只有在把所有目标文件链接起来以后，才能确定。链接器主要负责地址重分配、符号名称绑定和重定位。</p></li>\n</ol>\n\n<p>从源代码到程序的运行要做的远远不止编译，很多时候我们说“把程序编译一下”，是不准确的。不过编译确实是整个流程中最复杂的部分。</p>\n\n<h2 id=\"\">软件调用层次</h2>\n\n<p>我们把整个计算机调用结构分为四层：</p>\n\n<ol>\n<li>最上层是应用层。不管是浏览器、游戏，还是我们使用的各种开发工具，如Xcode，VS，汇编器自身等，都属于这一范畴。  </li>\n<li>第二层是操作系统的运行库。我们在程序里调用系统API，比如文件读写，就是调用了第二层提供的相应服务。这种调用通过操作系统的API完成，它沟通了应用层和操作系统的运行库。这也就是为什么不管是在Mac还是Windows上编程，我们都可以调用<code>printf()</code>或<code>fread()</code>等函数。因为不同的操作系统的运行库提供了不同底层的实现，但对应用层提供的API总是一样的。  </li>\n<li>第三层是操作系统内核。操作系统的运行库通过系统调用(System Call)调用系统内核提供的函数。比如<code>fread</code>属于API，它在Linux下会调用<code>read()</code>这个系统调用，而在Windows下会调用<code>ReadFile()</code>这个系统调用。应用程序可以直接调用系统调用，但是这样一来，我们需要考虑各个操作系统下系统调用的不同，而且系统调用由于更加底层，实现起来也就更加困难。最关键的是，系统调用是通过中断来完成的，涉及到堆栈的保存与恢复，频繁的系统调用会影响性能。  </li>\n<li>第四层是硬件层。程序无法直接访问这一层，只有操作系统的内核，通过硬件厂商提供的接口才能访问。</li>\n</ol>\n\n<p>这四层之间的关系如下图所示：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/自我修养/hierarchy.png\" alt=\"层次关系\" /></p>\n\n<h2 id=\"\">虚拟地址空间</h2>\n\n<p>在程序运行的过程中，最重要的概念就是虚拟地址空间。所谓的虚拟地址空间，是指应用程序自己认为，自己所处的地址空间。它区别于物理地址空间。后者是真实存在的，比如电脑有一根8G的内存条，物理地址空间就是0~8Gb。CPU的MMU负责把虚拟地址转换成物理地址。</p>\n\n<p>引入虚拟地址的第一个好处是，程序员不再关心真实的物理内存空间是什么样的，理论上来说，程序员有几乎无限大的虚拟内存空间可用，最后只要建立虚拟地址和物理地址的对应关系即可。另一方面，操作系统屏蔽了物理内存空间的细节，进程无法访问到操作系统禁止访问的物理地址，也不能访问到别的进程的地址空间，这大大增强了程序安全性。</p>\n\n<p>由虚拟地址空间引申出来的分页(Paging)技术，大大提高了内存的使用效率。要想运行一个程序，不再需要把整个程序都放入内存中执行，我们只要保证将要执行的页在内存中即可，如果不存在则导致页错误。</p>\n\n<p>关于地址空间的理解非常重要，书中有很多关于内存、和地址的描述，需要我们自己分析这是虚拟地址还是物理地址。如果分析错了，理解问题会比较麻烦。</p>\n\n<h2 id=\"\">链接与重定位</h2>\n\n<p>我们把<code>foo</code>函数定义在另一个文件中，然后在<code>main.c</code>中调用这个函数，单独编译<code>main.c</code>后代码如下：</p>\n\n<pre><code class=\"language-c\">……\n0000000000000024    callq   0x29  \n0000000000000029    xorl    %ecx, %ecx  \n……\n</code></pre>\n\n<p>可以看到，本该调用<code>foo</code>函数的地方，我们直接调用了下一条命令，但是当<code>main.o</code>和<code>foo.o</code>链接起来后，就变成了：</p>\n\n<pre><code class=\"language-c\">0000000100000f30    pushq   %rbp  \n0000000100000f31    movq    %rsp, %rbp  \n0000000100000f34    movl    $0x7b, %eax  \n0000000100000f39    movl    %edi, -0x4(%rbp)  \n0000000100000f3c    movl    %esi, -0x8(%rbp)  \n0000000100000f3f    popq    %rbp  \n//以上为foo函数实现\n……\n0000000100000f74    callq   0x100000f30  \n0000000100000f79    xorl    %ecx, %ecx  \n……\n</code></pre>\n\n<p>这时候<code>foo</code>函数的位置就正确设置了。原因在于在<code>main.c</code>这个编译模块单独编译时，编译器无法确定<code>foo</code>的位置，只好临时用下一条指令的位置代替一下。</p>\n\n<p>链接器在链接过程中，就是要对这样的符号进行重定位。在重定位时，<code>main.o</code>中有<code>foo</code>函数经过修饰的符号名，同样的符号名在<code>foo.o</code>中也有，于是两者一拍即合，就这样被链接器连在了一起。<code>0x29</code>这个临时的调用地址被更新成了<code>0x100000f30</code>。这个过程类似于拼图游戏，程序在链接时就是处理各种各样类似的问题，当所有编译模块都按照符号名完整的链接起来时，程序也就可以开始运行了。</p>\n\n<p>书中花了不少篇幅介绍目标文件的组成结构，其中很多都是为了重定位而准备的。一旦明白了重定位的原理和过程，在阅读相关内容时就会轻松很多。</p>\n\n<h2 id=\"\">知识概要</h2>\n\n<p>最后列出一部分知识点的简要概括和他们在书中的位置，方便读者参考：</p>\n\n<h3 id=\"\">静态链接部分</h3>\n\n<p>这一部分主要是讨论多个<code>.c</code>文件怎么通过静态链接，得到一个静态库。</p>\n\n<ul>\n<li><p>P58</p>\n\n<p>目标文件中分为若干个段，比如.text段存放代码，.data段存放存放已初始化的全局变量和局部静态变量，.bss段存放未初始化的全局变量和局部静态变量，除此以外目标文件还有很多其他的段。</p></li>\n<li><p>P70</p>\n\n<p>Linux下的目标文件还有一个ELF文件头，用于汇总这个目标文件的各种信息,其中包括了ELF魔数、机器字节长度、数据存储方式、版本、运行平台、ABI版本，重定位类型、硬件平台及版本、入口地址、段表位置、段的数量等。</p></li>\n<li><p>P74</p>\n\n<p>段表其实是一个数组，其中每一个元素都是结构体。结构体里面有段的名称、类型、加载地址、相对于文件头的偏移量，段的大小，链接信息等。</p></li>\n<li><p>P79</p>\n\n<p>目标文件中还有一个重定位表。需要重定位的信息都记录在这个表里面。.text段中所有需要重定位的信息，都放在.rel.text段中。</p></li>\n<li><p>P81</p>\n\n<p>在链接时，我们把函数名和变量都称为符号。每一个函数、变量都有自己独特的符号名，这样在链接时才能把它们对应起来。不同的语言有自己的符号修饰规则。UNIX下的C，编译出来的符号名前面加“_”，如函数foo在编译之后的结果为_foo。</p></li>\n<li><p>P86</p>\n\n<p>C++的namespace就是用来避免符号名冲突。C++有一套自己的符号名修饰规则，可以通过c++filt命令还原被修饰过的符号名(demangle)。一旦了解了符号名的修饰规则，在写iOS时遇到<code>undefined symbol</code>或<code>duplicate symbol name</code>的报错，就非常好检查了。</p></li>\n<li><p>P92</p>\n\n<p>符号分为强符号，和弱符号。强符号不可名称重复，弱符号（未初始化的全局变量）可以有符号名相同。对符号名的引用分为强引用和弱引用，强引用表示如果找不到符号定义会报错，弱引用不报错，默认为0或某个特殊值。</p></li>\n<li><p>P99</p>\n\n<p>链接过程一般分为两步，首先地址分配，然后符号解析并重定位。</p>\n\n<p>由于不同的目标文件，可能含有相同的段，所以在链接过程中，我们可以合并相似段，这就是地址分配。</p>\n\n<p>合并完成后，所有符号的位置都可以唯一确定，此时可以就开始重定位工作了。链接完成后，我们就得到了静态库。</p></li>\n<li><p>P118</p>\n\n<p>静态库可以看做一组目标文件的集合，同一个静态库中的不同目标文件可能相互依赖，不同的静态库也可以相互依赖。</p></li>\n<li><p>P127</p>\n\n<p>链接控制脚本控制链接器的运行，将目标文件和库文件转化为可执行文件。链接控制脚本由链接脚本语言写成。可以认为的控制程序入口，某几个段合并，某几个段舍弃等</p></li>\n</ul>\n\n<h3 id=\"\">动态装载</h3>\n\n<p>这一部分主要是讨论经过链接后，可执行文件如何装载到内存中</p>\n\n<ul>\n<li><p>P153</p>\n\n<p>有两种典型的动态装载方法：覆盖装入和页映射。覆盖装入允许互不依赖的两个模块共同享有同一块内存，在使用中互相替换。速度较慢，用时间换空间。我们常用的方案是页映射，把程序虚拟的内存空间分成多个页，由专门的页装载管理器负责管理虚拟页和物理内存中页的对应关系。</p></li>\n<li><p>P157</p>\n\n<p>创建进程三步骤：首先进程自己的创建物理空间。设置好虚拟空间中各个页到物理空间里的页的映射关系（这一步可能在页错误之后发生）、然后建立虚拟空间与可执行文件的映射关系。Linux下，目标文件的每个段都有自己在虚拟内存中的位置，这叫虚拟内存区域（VMA, Virtual Memory Area），表示它装载在虚拟内存中的地址，最后指令寄存器设置为可执行文件入口。</p></li>\n<li><p>P159</p>\n\n<p>进程创建后，只有物理页与虚拟页的对应关系，但是真正的指令和数据还没有放入物理页中，物理页的内存处于未分配状态。一旦访问到这个物理页，就会发生页错误。</p>\n\n<p>发生页错误时，操作系统立刻根据物理内存的页与虚拟内存的页的对应关系，找到这个页对应的虚拟内存，然后再查询每个段的VMA，就可以找这个页面在可执行文件中的偏移量。这时候操作系统先为物理页分配内存空间，然后把可执行文件中的数据和指令写入物理页，最后建立物理页和虚拟页联系即可。然后进程从发生页错误的地方重新执行。</p></li>\n<li><p>P169</p>\n\n<p>可执行文件有很多Section，它们的大小各不相同，但有些小于页的大小，导致了空间浪费（不能连续存储不同的section是因为可能会有两个权限不同的section在同一个页中）。由于操作系统不关心每个Section的具体作用，但是关心它们的读写权限（是否可读、可写、可执行），所以往往把具有权限的Section合并成一个Segment</p></li>\n<li><p>P172：</p>\n\n<p>进程运行后，操作系统会初始化进程的堆栈，其中存放了环境变量和命令行参数。这些参数被传给main函数（argc和argv两个参数对应参数数量和参数数组）</p></li>\n</ul>\n\n<h3 id=\"\">动态链接</h3>\n\n<ul>\n<li><p>P181</p>\n\n<p>动态链接把程序按模块拆分成若干个相对独立的部分，模块之间的链接推迟到运行时。ELF的动态链接文件成为“动态共享对象（DSO）”，后缀为“.so”。动态链接的过程由动态链接器完成。动态链接可以节约内存（多个进程共享内存中的某一个模块）、方便升级（静态链接的每一个模块都会影响整个可执行文件）。</p></li>\n<li><p>P188：</p>\n\n<p>由于动态共享对象会被多个程序使用，导致它在虚拟地址空间中的位置难以确定。不同模块的目标装载地址如果有相同的，那么同时导入这两个模块就会出问题。如果都不一样也不行，因为可能存在的模块太多了。没有那么多内存。所以动态共享对象需要在装载时重定位。</p></li>\n<li><p>P191：</p>\n\n<p>装载时重定位会导致无法在多个进程间共享，目前采用的方案是地址无关代码技术。动态对象中的地址引用分为模块内部和外部，指令引用和数据引用，两两组合成四种。对于模块内部的指令或数据引用，采用相对偏移调用的方法。</p></li>\n<li><p>P195：</p>\n\n<p>把地址相关需要重定位的部分放到数据段中，同时建立全局偏移表（GOT）。用.got和.got.plt表分别处理数据和函数引用。</p></li>\n<li><p>P200：</p>\n\n<p>当函数第一次被用到的时候才重定位，从而提高程序运行速度。这种方法被称为延迟绑定（Lazy Binding）。Linux维护一个PLT（Procedure Linkage Table）来保存符号名和真实地址之间的对应关系</p></li>\n<li><p>P208：</p>\n\n<p>动态链接中有两个重定位表.rel.dyn和.rel.plt分别对应.rel.text和.rel.data。前者对数据引用（.got）进行修正，后者对函数引用(.got.plt)进行修正。</p></li>\n<li><p>P214：</p>\n\n<p>动态链接器是一个特殊共享对象，它不依赖于任何动态共享文件，且自己的重定位工作由自己完成。通过一段被称为自举（Bootstrap）的特殊代码，不用到任何静态或全部变量，完成这项工作</p></li>\n</ul>\n\n<h4 id=\"\">内存与库</h4>\n\n<ul>\n<li><p>P286：</p>\n\n<p>i386处理器下，栈顶有esp寄存器定位，由于栈向下生长，压栈使得栈顶地址减小</p></li>\n<li><p>P287：</p>\n\n<p>栈保存了函数调用所需要的维护信息，被称为堆栈帧（Stack Frame）或活动记录，包含了函数的返回地址和函数，临时变量以及保存的上下文。ebp是帧指针指向活动记录的某一个固定位置。</p></li>\n<li><p>P294：</p>\n\n<p>函数的调用方和被调用方要遵守同一个“调用惯例”。默认的cdecl惯例要求函数参数以从右到左的顺序入栈，由函数调用方负责参数的出栈。</p></li>\n<li><p>P301：</p>\n\n<p>函数返回值的获取：如果是四个字节，放在eax中。4-8字节的返回值通过eax（低位）和edx（高位）联合存储。查过8字节的返回值，把返回值在栈中存放的地址放到eax中。</p></li>\n<li><p>P306：</p>\n\n<p>栈上的数据在函数返回时就会被释放，全局地、动态的申请内存的方式是利用堆。如果由操作系统管理堆，由于总是进行系统调用，性能开销比较大，所以一般由应用程序“批发”一大块内存空间，然后自己进行内存管理。</p></li>\n<li><p>P311：</p>\n\n<p>堆并不总是向上生长（如Windows的HeapCreate系列），调用malloc有可能产生系统调用（取决于进程预申请的空间是否足够），堆内存在进程结束后被操作系统回收，堆内存在虚拟地址空间中连续，在物理空间中可能不连续</p></li>\n<li><p>P314：</p>\n\n<p>堆分配三种算法：空闲链表（简单，记录长度的字节容易被数组越界破坏）、位图（速度快（容易命中cache），稳定性好（不容易数组越界），易管理，会产生碎片，位图有可能过大）、对象池（针对固定大小的分配空间）</p></li>\n<li><p>P319：</p>\n\n<p>创建进程后，操作系统把控制权交给运行库的某个入口函数，然后开始堆的构造，启动I/O，创建线程，进行全局变量构造等。然后调用main函数，main函数执行完成后，执行与之前相反的操作，进行系统调用结束进程。</p></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:12:39.000Z","created_by":1,"updated_at":"2016-01-14T08:13:23.000Z","updated_by":1,"published_at":"2015-12-22T08:12:00.000Z","published_by":1},{"id":11,"uuid":"77bc08df-c3ff-41fe-8bc1-003ebb9b1ab3","title":"Swift与OC中拷贝与可变性","slug":"differenceofcopybettenswiftandoc","markdown":"首先来看一下Objective-C中的拷贝与可变性。为了解释方便，定义两个类：<font color = \"rgb(226,238,250)\">`Person`</font>和<font color = \"rgb(226,238,250)\">`MyObject`</font>，它们都继承自<font color = \"rgb(226,238,250)\">`NSObject`</font>。他们的关系如下:\n\n```objc\n// Person.h\n@property (strong, nonatomic, nullable) MyObject *object;\n```\n\n```objc\n// MyObjec.h\n@property (copy, nonatomic) NSString *name;\n```\n\n##普通对象拷贝\n\n对于一个OC中的对象来说，可能涉及拷贝的有三种操作：\n\n1. <font color = \"rgb(226,238,250)\">`retain`</font>操作：\n\n\t```objc\n\tPerson *p = [[Person alloc] init];\n\tPerson *p1 = p;\n\t```\n\t\n\t这里的<font color = \"rgb(226,238,250)\">`p1`</font>默认是<font color = \"rgb(226,238,250)\">`__strong`</font>，所以它会对`p`进行<font color = \"rgb(226,238,250)\">`retain`</font>操作。<font color = \"rgb(226,238,250)\">`retain`</font>与复制无关，只会对引用计数加1。<font color = \"rgb(226,238,250)\">`p1`</font>和<font color = \"rgb(226,238,250)\">`p`</font>的地址是完全一样的：\n\t\n\t```objc\n\t2015-12-23 21:24:31.893 Copy[1300:120857] p = 0x1006012c0\n2015-12-23 21:24:31.894 Copy[1300:120857] p1 = 0x1006012c0\n\t```\n\t\n\t这种写法最简单，而且严格来说不是复制，但值得一提，因为在接下来的OC和Swift中，都会涉及到这样的代码。\n\t\n2. <font color = \"rgb(226,238,250)\">`copy`</font>方法：\n\n\t调用<font color = \"rgb(226,238,250)\">`copy`</font>方法需要实现<font color = \"rgb(226,238,250)\">`NSCopying`</font>协议，并提供<font color = \"rgb(226,238,250)\">`copyWithZone`</font>方法：\n\t\n\t```objc\n\t- (id)copyWithZone:(NSZone *)zone {\n    \tPerson *copyInstance = [[self class] allocWithZone:zone];\n    \tcopyInstance.object = self.object;\n    \treturn copyInstance;\n\t}\n\t```\n\t\n\t第二行代码就是刚刚所说的<font color = \"rgb(226,238,250)\">`retain`</font>操作。因此，我们虽然复制了<font color = \"rgb(226,238,250)\">`Person`</font>对象的指针，但是其内部的属性，依然和原来对象的相同。\n\t\n3. 自定义拷贝方法：\n\t\n\t我们当然可以自己定义一个拷贝方法，在复制<font color = \"rgb(226,238,250)\">`Person`</font>对象的同时，把其中的<font color = \"rgb(226,238,250)\">`object`</font>属性也复制，而不是仅仅<font color = \"rgb(226,238,250)\">`retain`</font>。\n\t\n\n第二三种复制方法的区别如图所示：\n\n![两种拷贝方式](http://7xonij.com1.z0.glb.clouddn.com/Copy/deepVSshallow.png)\n\n##浅拷贝与深拷贝\n\n标为红色的是两种拷贝方式的不同之处。对于左边这种，只拷贝指针本身的拷贝方法，我们称为浅拷贝。对于右边那种，不仅拷贝指针自身，还拷贝指针中所有元素的拷贝方法，我们称为深拷贝。\n\n没有明确的限制<font color = \"rgb(226,238,250)\">`copy`</font>和自定义的拷贝方法要如何实现。也就是说<font color = \"rgb(226,238,250)\">`copy`</font>方法可以用来进行深拷贝，我们也可以自定义浅拷贝的方法。这完全取决于我们自己如何实现<font color = \"rgb(226,238,250)\">`copy`</font>方法和自定义的拷贝方法。在OC中，对于自定义的类来说，浅拷贝与深拷贝只是一种概念，并没有明确的标注哪种方法就是浅拷贝。\n\n**注意**\n\n“深拷贝将被拷贝的对象完全复制”这种说法不完全正确，比如上图中我们看到<font color = \"rgb(226,238,250)\">`data`</font>的地址永远不会拷贝。这是因为，深拷贝只负责了对象的拷贝，以及对象中所有属性的拷贝。正是因为拷贝了属性，将<font color = \"rgb(226,238,250)\">`p`</font>深拷贝后得到的<font color = \"rgb(226,238,250)\">`p'`</font>的<font color = \"rgb(226,238,250)\">`object`</font>指针地址和<font color = \"rgb(226,238,250)\">`p`</font>的<font color = \"rgb(226,238,250)\">`object`</font>指针地址不同。\n\n但是至于<font color = \"rgb(226,238,250)\">`data`</font>会不会被拷贝，这取决于<font color = \"rgb(226,238,250)\">`MyObject`</font>类如何设计，如果<font color = \"rgb(226,238,250)\">`MyObject`</font>的<font color = \"rgb(226,238,250)\">`copy`</font>方法只是浅拷贝，就会形成如上图所示的情况。如果<font color = \"rgb(226,238,250)\">`MyObject`</font>的<font color = \"rgb(226,238,250)\">`copy`</font>方法也是深拷贝，那么<font color = \"rgb(226,238,250)\">`data`</font>的地址也会不同。\n\n##容器对象拷贝\n\n在OC中，所有<font color = \"rgb(226,238,250)\">`Foundation`</font>中的容器类，分为可变容器和不可变容器，它们的拷贝**都是浅拷贝**。这也就是为什么建议自定义的对象实现浅拷贝，如果有需要才自定义深拷贝方法。因为这样一来，所有的方法调用就都可以统一，不至于造成误解。\n\n如果我们把数组想象成一个三层的数据结构，第一层是数组自己的指针，第二层是存放在数组中的指针，第三层(如果第二层是指针)则是这些指针指向的对象。那么在复制数组时，复制的是前两层，第三层的对象不会被复制。如果把前两层看做指针，第三层看做对象，那么数组的拷贝，无论是<font color = \"rgb(226,238,250)\">`copy`</font>还是<font color = \"rgb(226,238,250)\">`mutableCopy`</font>都是浅拷贝。当然，也有人把这个称为“单层深拷贝”，这些概念性的定义都不重要，重要的是知道数组拷贝时的原理。\n\n这一点很好理解。首先，指针所指向的对象，也许很大，深拷贝可能占用过多的内存和时间。其次，容器不知道自己存储的对象是否实现了<font color = \"rgb(226,238,250)\">`NSCopying`</font>协议。如果容器的拷贝默认是深拷贝，同时你在数组中存放了<font color = \"rgb(226,238,250)\">`Person`</font>类的对象，而<font color = \"rgb(226,238,250)\">`Person`</font>类根本没有实现<font color = \"rgb(226,238,250)\">`NSCopying`</font>协议，后果是复制容器会导致程序崩溃。这是任何语言开发者都不希望看到的，所以设身处地想一下，如果是你来设计OC，也不会让数组深拷贝吧。\n\n观察下面这段代码，思考一下为什么<font color = \"rgb(226,238,250)\">`a1[0] = @0`</font>没有影响<font color = \"rgb(226,238,250)\">`a2`</font>：\n\n```objc\nNSMutableArray *a1 = [[NSMutableArray alloc] initWithObjects:@1, @2, nil];\nNSMutableArray *a2 = [a1 mutableCopy];\na1[0] = @0;\nNSLog(@\"a2 = %@\", a2);\n\n/*\n2015-12-23 23:11:53.711 Copy[1795:220469] a2 = (\n    0,\n    2\n)\n*/\n```\n\n## 可变性\n\n容器对象分为可变容器与不可变容器，<font color = \"rgb(226,238,250)\">`NSData`</font>、<font color = \"rgb(226,238,250)\">`NSArray`</font>、<font color = \"rgb(226,238,250)\">`NSString`</font>等都是不可变容器，以<font color = \"rgb(226,238,250)\">`NSMutable`</font>开头的则是它们的可变版本。下面统一用<font color = \"rgb(226,238,250)\">`NSArray`</font>和<font color = \"rgb(226,238,250)\">`NSMutableArray`</font>举例说明。\n\n因为<font color = \"rgb(226,238,250)\">`NSMutableArray`</font>是<font color = \"rgb(226,238,250)\">`NSArray`</font>的子类，所以<font color = \"rgb(226,238,250)\">`NSArray`</font>对象不能强制转换成<font color = \"rgb(226,238,250)\">`NSMutableArray`</font>，否则在调用<font color = \"rgb(226,238,250)\">`addObject`</font>方法时会崩溃。反之，<font color = \"rgb(226,238,250)\">`NSMutableArray`</font>可以转换成它的父类<font color = \"rgb(226,238,250)\">`NSArray`</font>，这么做会导致它失去可变性。\n\n容器拷贝的难点在于可变性的变化。容器有两种方法：<font color = \"rgb(226,238,250)\">`copy`</font>和<font color = \"rgb(226,238,250)\">`mutableCopy`</font>，再次强调这两者都是浅拷贝。它们的区别在于，返回值是否是可变的。前者返回不可变容器，后者返回可变容器。\n\n这也就是说，返回值的可变性与被拷贝对象的可变性无关，仅取决于调用了何种拷贝方法。比如：\n\n```objc\nNSMutableArray *mutableArray = [[NSMutableArray alloc] initWithObjects:@1, @2, nil];\nNSMutableArray *array = [mutableArray copy];\n[array addObject:@3];\n```\n\n尽管我们调用了<font color = \"rgb(226,238,250)\">`mutableArray`</font>的拷贝方法，返回值也声明为<font color = \"rgb(226,238,250)\">`NSMutableArray`</font>，但是调用<font color = \"rgb(226,238,250)\">`addObject`</font>方法时依然会导致运行时错误。这是由错误的调用了<font color = \"rgb(226,238,250)\">`copy`</font>方法导致的。\n\n调用一个对象的浅拷贝方法会得到一个新的对象(地址不同)，但是容器类中有一个特例：\n\n```objc\nNSArray *array1 = @[@1, @2];\nNSArray *array2 = [array1 copy];\n// array1和array2指向的数组对象地址相同\n```\n\n这是因为既然<font color = \"rgb(226,238,250)\">`array1`</font>和<font color = \"rgb(226,238,250)\">`array2`</font>都不能再修改，那么两者共用同一块内存也是无所谓的，所以OC做了这样的优化。\n\n## 字符串拷贝\n\n字符串也可以被当做容器来理解。它有<font color = \"rgb(226,238,250)\">`NSString`</font>和<font color = \"rgb(226,238,250)\">`NSMutableString`</font>两个版本。\n\n于是为什么字符串属性要定义成<font color = \"rgb(226,238,250)\">`@property(copy, nonatomic)`</font>就很好理解了。它主要用于处理这种情况：\n\n```objc\nNSMutableString *string = @\"hello\";\nself.propertyString = string;\n[string appendString:@\" world\"];\n```\n\n如果属性定义成<font color = \"rgb(226,238,250)\">`strong`</font>，那么在第二步执行了<font color = \"rgb(226,238,250)\">`retain`</font>操作，第三步对<font color = \"rgb(226,238,250)\">`string`</font>的修改就会影响到原来的属性。现在我们把属性定义为<font color = \"rgb(226,238,250)\">`copy`</font>，那么第二步操作其实是得到了一个新的，不可变字符串。这符合我们的预期目的。\n\n# Swift拷贝\n\n## 结构体拷贝\n\n数组、字典等容器在Swift中被定义成了结构体，它们的拷贝规则和OC完全不同：\n\n```swift\nvar array1 = [1,2,3]\nvar array2 = array1\n\narray1[0] = 0\nprint(array2) // 输出结果：[1, 2, 3]\n```\n\n可以看到，即使是最简单的等号赋值，也会浅拷贝原来的值。这是由Swift中结构体的值语义决定的。之所以说是浅拷贝而不是深拷贝，理由参见前文解释OC中容器的浅拷贝，尤其是第二点理由，不管是对于OC还是Swift来说都是通用的。\n\n## 对象拷贝\n\n和OC中指针赋值类似，对象的直接赋值操作与拷贝无关：\n\n```swift\nclass Person {\n    var name: String;\n    init(name:String) {\n        self.name = name\n    }\n}\n\nlet person1 = Person(name: \"zxy\")\nlet person2 = person1\nperson1.name = \"new name\"\n\nprint(person2.name) //结果是“new name”\n```\n\n如果要拷贝对象，有两种方法。首先，最自然想到的是实现<font color = \"rgb(226,238,250)\">`NSCopying`</font>协议，注意只有<font color = \"rgb(226,238,250)\">`NSObject`</font>类的对象才能实现这个协议：\n\n```swift\nclass Person : NSObject, NSCopying {\n    var name: String;\n    init(name:String) {\n        self.name = name\n    }\n    \n    func copyWithZone(zone: NSZone) -> AnyObject {\n        return Person(name: self.name)\n    }\n}\n\n```\n\n但这样做最大的问题在于，你必须继承自<font color = \"rgb(226,238,250)\">`NSObject`</font>，这就又回到了OC的那一套。如果我们希望定义纯粹的Swift类，完全可以自己定义并实现拷贝方法。\n\n“面向接口编程”的原则告诉我们，我们应该让<font color = \"rgb(226,238,250)\">`Person`</font>实现某个接口，而不是继承自某个子类：\n\n```swift\nprotocol Copyable {\n    func copy() -> Copyable\n}\n\nclass Person : Copyable {\n    var name: String;\n    init(name:String) {\n        self.name = name\n    }\n    \n    func copy() -> Copyable {\n        return Person(name: self.name)\n    }\n}\n\nlet person1 = Person(name: \"zxy\")\nlet person2 = person1.copy() as! Person\n```\n\n这样就完美的实现Swift-Style拷贝了。\n\n#总结\n\n在OC中，浅拷贝通常由<font color = \"rgb(226,238,250)\">`NSCopying`</font>协议的<font color = \"rgb(226,238,250)\">`copyWithZone`</font>方法实现，深拷贝需要自定义方法。直接赋值意味着<font color = \"rgb(226,238,250)\">`retain`</font>而不是拷贝。\n\n在Swift中，值类型直接用等号赋值意味着浅拷贝，引用类型的拷贝可以通过实现自定义的<font color = \"rgb(226,238,250)\">`Copyable`</font>协议或OC的<font color = \"rgb(226,238,250)\">`NSCopying`</font>协议完成。\n\n在OC中，我们需要容器的可变性，而Swift在这一点做的要比OC好得多。它的可变性非常简单，完全通过<font color = \"rgb(226,238,250)\">`let`</font>和<font color = \"rgb(226,238,250)\">`var`</font>控制，这也是Swift相比于OC的一个优点吧，毕竟高级的语言应该尽可能封装底层实现。","html":"<p>首先来看一下Objective-C中的拷贝与可变性。为了解释方便，定义两个类：<font color = \"rgb(226,238,250)\"><code>Person</code></font>和<font color = \"rgb(226,238,250)\"><code>MyObject</code></font>，它们都继承自<font color = \"rgb(226,238,250)\"><code>NSObject</code></font>。他们的关系如下:</p>\n\n<pre><code class=\"language-objc\">// Person.h\n@property (strong, nonatomic, nullable) MyObject *object;\n</code></pre>\n\n<pre><code class=\"language-objc\">// MyObjec.h\n@property (copy, nonatomic) NSString *name;\n</code></pre>\n\n<h2 id=\"\">普通对象拷贝</h2>\n\n<p>对于一个OC中的对象来说，可能涉及拷贝的有三种操作：</p>\n\n<ol>\n<li><p><font color = \"rgb(226,238,250)\"><code>retain</code></font>操作：</p>\n\n<p><code>objc\nPerson *p = [[Person alloc] init];\nPerson *p1 = p;\n</code></p>\n\n<p>这里的<font color = \"rgb(226,238,250)\"><code>p1</code></font>默认是<font color = \"rgb(226,238,250)\"><code>__strong</code></font>，所以它会对<code>p</code>进行<font color = \"rgb(226,238,250)\"><code>retain</code></font>操作。<font color = \"rgb(226,238,250)\"><code>retain</code></font>与复制无关，只会对引用计数加1。<font color = \"rgb(226,238,250)\"><code>p1</code></font>和<font color = \"rgb(226,238,250)\"><code>p</code></font>的地址是完全一样的：</p>\n\n<p><code>objc\n2015-12-23 21:24:31.893 Copy[1300:120857] p = 0x1006012c0\n2015-12-23 21:24:31.894 Copy[1300:120857] p1 = 0x1006012c0 <br />\n</code></p>\n\n<p>这种写法最简单，而且严格来说不是复制，但值得一提，因为在接下来的OC和Swift中，都会涉及到这样的代码。</p></li>\n<li><p><font color = \"rgb(226,238,250)\"><code>copy</code></font>方法：</p>\n\n<p>调用<font color = \"rgb(226,238,250)\"><code>copy</code></font>方法需要实现<font color = \"rgb(226,238,250)\"><code>NSCopying</code></font>协议，并提供<font color = \"rgb(226,238,250)\"><code>copyWithZone</code></font>方法：</p>\n\n<p>```objc</p>\n\n<ul><li>(id)copyWithZone:(NSZone *)zone {\nPerson *copyInstance = [[self class] allocWithZone:zone];\ncopyInstance.object = self.object;\nreturn copyInstance;\n}\n```</li></ul>\n\n<p>第二行代码就是刚刚所说的<font color = \"rgb(226,238,250)\"><code>retain</code></font>操作。因此，我们虽然复制了<font color = \"rgb(226,238,250)\"><code>Person</code></font>对象的指针，但是其内部的属性，依然和原来对象的相同。</p></li>\n<li><p>自定义拷贝方法：</p>\n\n<p>我们当然可以自己定义一个拷贝方法，在复制<font color = \"rgb(226,238,250)\"><code>Person</code></font>对象的同时，把其中的<font color = \"rgb(226,238,250)\"><code>object</code></font>属性也复制，而不是仅仅<font color = \"rgb(226,238,250)\"><code>retain</code></font>。</p></li>\n</ol>\n\n<p>第二三种复制方法的区别如图所示：</p>\n\n<p><img src=\"http://7xonij.com1.z0.glb.clouddn.com/Copy/deepVSshallow.png\" alt=\"两种拷贝方式\" /></p>\n\n<h2 id=\"\">浅拷贝与深拷贝</h2>\n\n<p>标为红色的是两种拷贝方式的不同之处。对于左边这种，只拷贝指针本身的拷贝方法，我们称为浅拷贝。对于右边那种，不仅拷贝指针自身，还拷贝指针中所有元素的拷贝方法，我们称为深拷贝。</p>\n\n<p>没有明确的限制<font color = \"rgb(226,238,250)\"><code>copy</code></font>和自定义的拷贝方法要如何实现。也就是说<font color = \"rgb(226,238,250)\"><code>copy</code></font>方法可以用来进行深拷贝，我们也可以自定义浅拷贝的方法。这完全取决于我们自己如何实现<font color = \"rgb(226,238,250)\"><code>copy</code></font>方法和自定义的拷贝方法。在OC中，对于自定义的类来说，浅拷贝与深拷贝只是一种概念，并没有明确的标注哪种方法就是浅拷贝。</p>\n\n<p><strong>注意</strong></p>\n\n<p>“深拷贝将被拷贝的对象完全复制”这种说法不完全正确，比如上图中我们看到<font color = \"rgb(226,238,250)\"><code>data</code></font>的地址永远不会拷贝。这是因为，深拷贝只负责了对象的拷贝，以及对象中所有属性的拷贝。正是因为拷贝了属性，将<font color = \"rgb(226,238,250)\"><code>p</code></font>深拷贝后得到的<font color = \"rgb(226,238,250)\"><code>p'</code></font>的<font color = \"rgb(226,238,250)\"><code>object</code></font>指针地址和<font color = \"rgb(226,238,250)\"><code>p</code></font>的<font color = \"rgb(226,238,250)\"><code>object</code></font>指针地址不同。</p>\n\n<p>但是至于<font color = \"rgb(226,238,250)\"><code>data</code></font>会不会被拷贝，这取决于<font color = \"rgb(226,238,250)\"><code>MyObject</code></font>类如何设计，如果<font color = \"rgb(226,238,250)\"><code>MyObject</code></font>的<font color = \"rgb(226,238,250)\"><code>copy</code></font>方法只是浅拷贝，就会形成如上图所示的情况。如果<font color = \"rgb(226,238,250)\"><code>MyObject</code></font>的<font color = \"rgb(226,238,250)\"><code>copy</code></font>方法也是深拷贝，那么<font color = \"rgb(226,238,250)\"><code>data</code></font>的地址也会不同。</p>\n\n<h2 id=\"\">容器对象拷贝</h2>\n\n<p>在OC中，所有<font color = \"rgb(226,238,250)\"><code>Foundation</code></font>中的容器类，分为可变容器和不可变容器，它们的拷贝<strong>都是浅拷贝</strong>。这也就是为什么建议自定义的对象实现浅拷贝，如果有需要才自定义深拷贝方法。因为这样一来，所有的方法调用就都可以统一，不至于造成误解。</p>\n\n<p>如果我们把数组想象成一个三层的数据结构，第一层是数组自己的指针，第二层是存放在数组中的指针，第三层(如果第二层是指针)则是这些指针指向的对象。那么在复制数组时，复制的是前两层，第三层的对象不会被复制。如果把前两层看做指针，第三层看做对象，那么数组的拷贝，无论是<font color = \"rgb(226,238,250)\"><code>copy</code></font>还是<font color = \"rgb(226,238,250)\"><code>mutableCopy</code></font>都是浅拷贝。当然，也有人把这个称为“单层深拷贝”，这些概念性的定义都不重要，重要的是知道数组拷贝时的原理。</p>\n\n<p>这一点很好理解。首先，指针所指向的对象，也许很大，深拷贝可能占用过多的内存和时间。其次，容器不知道自己存储的对象是否实现了<font color = \"rgb(226,238,250)\"><code>NSCopying</code></font>协议。如果容器的拷贝默认是深拷贝，同时你在数组中存放了<font color = \"rgb(226,238,250)\"><code>Person</code></font>类的对象，而<font color = \"rgb(226,238,250)\"><code>Person</code></font>类根本没有实现<font color = \"rgb(226,238,250)\"><code>NSCopying</code></font>协议，后果是复制容器会导致程序崩溃。这是任何语言开发者都不希望看到的，所以设身处地想一下，如果是你来设计OC，也不会让数组深拷贝吧。</p>\n\n<p>观察下面这段代码，思考一下为什么<font color = \"rgb(226,238,250)\"><code>a1[0] = @0</code></font>没有影响<font color = \"rgb(226,238,250)\"><code>a2</code></font>：</p>\n\n<pre><code class=\"language-objc\">NSMutableArray *a1 = [[NSMutableArray alloc] initWithObjects:@1, @2, nil];  \nNSMutableArray *a2 = [a1 mutableCopy];  \na1[0] = @0;  \nNSLog(@\"a2 = %@\", a2);\n\n/*\n2015-12-23 23:11:53.711 Copy[1795:220469] a2 = (  \n    0,\n    2\n)\n*/\n</code></pre>\n\n<h2 id=\"\">可变性</h2>\n\n<p>容器对象分为可变容器与不可变容器，<font color = \"rgb(226,238,250)\"><code>NSData</code></font>、<font color = \"rgb(226,238,250)\"><code>NSArray</code></font>、<font color = \"rgb(226,238,250)\"><code>NSString</code></font>等都是不可变容器，以<font color = \"rgb(226,238,250)\"><code>NSMutable</code></font>开头的则是它们的可变版本。下面统一用<font color = \"rgb(226,238,250)\"><code>NSArray</code></font>和<font color = \"rgb(226,238,250)\"><code>NSMutableArray</code></font>举例说明。</p>\n\n<p>因为<font color = \"rgb(226,238,250)\"><code>NSMutableArray</code></font>是<font color = \"rgb(226,238,250)\"><code>NSArray</code></font>的子类，所以<font color = \"rgb(226,238,250)\"><code>NSArray</code></font>对象不能强制转换成<font color = \"rgb(226,238,250)\"><code>NSMutableArray</code></font>，否则在调用<font color = \"rgb(226,238,250)\"><code>addObject</code></font>方法时会崩溃。反之，<font color = \"rgb(226,238,250)\"><code>NSMutableArray</code></font>可以转换成它的父类<font color = \"rgb(226,238,250)\"><code>NSArray</code></font>，这么做会导致它失去可变性。</p>\n\n<p>容器拷贝的难点在于可变性的变化。容器有两种方法：<font color = \"rgb(226,238,250)\"><code>copy</code></font>和<font color = \"rgb(226,238,250)\"><code>mutableCopy</code></font>，再次强调这两者都是浅拷贝。它们的区别在于，返回值是否是可变的。前者返回不可变容器，后者返回可变容器。</p>\n\n<p>这也就是说，返回值的可变性与被拷贝对象的可变性无关，仅取决于调用了何种拷贝方法。比如：</p>\n\n<pre><code class=\"language-objc\">NSMutableArray *mutableArray = [[NSMutableArray alloc] initWithObjects:@1, @2, nil];  \nNSMutableArray *array = [mutableArray copy];  \n[array addObject:@3];\n</code></pre>\n\n<p>尽管我们调用了<font color = \"rgb(226,238,250)\"><code>mutableArray</code></font>的拷贝方法，返回值也声明为<font color = \"rgb(226,238,250)\"><code>NSMutableArray</code></font>，但是调用<font color = \"rgb(226,238,250)\"><code>addObject</code></font>方法时依然会导致运行时错误。这是由错误的调用了<font color = \"rgb(226,238,250)\"><code>copy</code></font>方法导致的。</p>\n\n<p>调用一个对象的浅拷贝方法会得到一个新的对象(地址不同)，但是容器类中有一个特例：</p>\n\n<pre><code class=\"language-objc\">NSArray *array1 = @[@1, @2];  \nNSArray *array2 = [array1 copy];  \n// array1和array2指向的数组对象地址相同\n</code></pre>\n\n<p>这是因为既然<font color = \"rgb(226,238,250)\"><code>array1</code></font>和<font color = \"rgb(226,238,250)\"><code>array2</code></font>都不能再修改，那么两者共用同一块内存也是无所谓的，所以OC做了这样的优化。</p>\n\n<h2 id=\"\">字符串拷贝</h2>\n\n<p>字符串也可以被当做容器来理解。它有<font color = \"rgb(226,238,250)\"><code>NSString</code></font>和<font color = \"rgb(226,238,250)\"><code>NSMutableString</code></font>两个版本。</p>\n\n<p>于是为什么字符串属性要定义成<font color = \"rgb(226,238,250)\"><code>@property(copy, nonatomic)</code></font>就很好理解了。它主要用于处理这种情况：</p>\n\n<pre><code class=\"language-objc\">NSMutableString *string = @\"hello\";  \nself.propertyString = string;  \n[string appendString:@\" world\"];\n</code></pre>\n\n<p>如果属性定义成<font color = \"rgb(226,238,250)\"><code>strong</code></font>，那么在第二步执行了<font color = \"rgb(226,238,250)\"><code>retain</code></font>操作，第三步对<font color = \"rgb(226,238,250)\"><code>string</code></font>的修改就会影响到原来的属性。现在我们把属性定义为<font color = \"rgb(226,238,250)\"><code>copy</code></font>，那么第二步操作其实是得到了一个新的，不可变字符串。这符合我们的预期目的。</p>\n\n<h1 id=\"swift\">Swift拷贝</h1>\n\n<h2 id=\"\">结构体拷贝</h2>\n\n<p>数组、字典等容器在Swift中被定义成了结构体，它们的拷贝规则和OC完全不同：</p>\n\n<pre><code class=\"language-swift\">var array1 = [1,2,3]  \nvar array2 = array1\n\narray1[0] = 0  \nprint(array2) // 输出结果：[1, 2, 3]  \n</code></pre>\n\n<p>可以看到，即使是最简单的等号赋值，也会浅拷贝原来的值。这是由Swift中结构体的值语义决定的。之所以说是浅拷贝而不是深拷贝，理由参见前文解释OC中容器的浅拷贝，尤其是第二点理由，不管是对于OC还是Swift来说都是通用的。</p>\n\n<h2 id=\"\">对象拷贝</h2>\n\n<p>和OC中指针赋值类似，对象的直接赋值操作与拷贝无关：</p>\n\n<pre><code class=\"language-swift\">class Person {  \n    var name: String;\n    init(name:String) {\n        self.name = name\n    }\n}\n\nlet person1 = Person(name: \"zxy\")  \nlet person2 = person1  \nperson1.name = \"new name\"\n\nprint(person2.name) //结果是“new name”  \n</code></pre>\n\n<p>如果要拷贝对象，有两种方法。首先，最自然想到的是实现<font color = \"rgb(226,238,250)\"><code>NSCopying</code></font>协议，注意只有<font color = \"rgb(226,238,250)\"><code>NSObject</code></font>类的对象才能实现这个协议：</p>\n\n<pre><code class=\"language-swift\">class Person : NSObject, NSCopying {  \n    var name: String;\n    init(name:String) {\n        self.name = name\n    }\n\n    func copyWithZone(zone: NSZone) -&gt; AnyObject {\n        return Person(name: self.name)\n    }\n}\n</code></pre>\n\n<p>但这样做最大的问题在于，你必须继承自<font color = \"rgb(226,238,250)\"><code>NSObject</code></font>，这就又回到了OC的那一套。如果我们希望定义纯粹的Swift类，完全可以自己定义并实现拷贝方法。</p>\n\n<p>“面向接口编程”的原则告诉我们，我们应该让<font color = \"rgb(226,238,250)\"><code>Person</code></font>实现某个接口，而不是继承自某个子类：</p>\n\n<pre><code class=\"language-swift\">protocol Copyable {  \n    func copy() -&gt; Copyable\n}\n\nclass Person : Copyable {  \n    var name: String;\n    init(name:String) {\n        self.name = name\n    }\n\n    func copy() -&gt; Copyable {\n        return Person(name: self.name)\n    }\n}\n\nlet person1 = Person(name: \"zxy\")  \nlet person2 = person1.copy() as! Person  \n</code></pre>\n\n<p>这样就完美的实现Swift-Style拷贝了。</p>\n\n<h1 id=\"\">总结</h1>\n\n<p>在OC中，浅拷贝通常由<font color = \"rgb(226,238,250)\"><code>NSCopying</code></font>协议的<font color = \"rgb(226,238,250)\"><code>copyWithZone</code></font>方法实现，深拷贝需要自定义方法。直接赋值意味着<font color = \"rgb(226,238,250)\"><code>retain</code></font>而不是拷贝。</p>\n\n<p>在Swift中，值类型直接用等号赋值意味着浅拷贝，引用类型的拷贝可以通过实现自定义的<font color = \"rgb(226,238,250)\"><code>Copyable</code></font>协议或OC的<font color = \"rgb(226,238,250)\"><code>NSCopying</code></font>协议完成。</p>\n\n<p>在OC中，我们需要容器的可变性，而Swift在这一点做的要比OC好得多。它的可变性非常简单，完全通过<font color = \"rgb(226,238,250)\"><code>let</code></font>和<font color = \"rgb(226,238,250)\"><code>var</code></font>控制，这也是Swift相比于OC的一个优点吧，毕竟高级的语言应该尽可能封装底层实现。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:15:10.000Z","created_by":1,"updated_at":"2016-01-14T08:17:22.000Z","updated_by":1,"published_at":"2015-12-23T08:15:00.000Z","published_by":1},{"id":12,"uuid":"9a3a588a-9b3f-4d0f-a167-1e281e7db51e","title":"OC和Swift闭包对比总结","slug":"oche-swiftbi-bao-dui-bi-zong-jie","markdown":"#OC的block\n\nOC的block已经有很多相关的文章介绍了，主要难点在于`__block`修饰符的作用和原理，以及循环引用问题。首先看一看`__block`修饰符，最后分析循环引用问题。这里的讨论都是基于ARC的。\n\n### 截获基本类型\n\n\n```objc\nint value = 10;\nvoid(^block)() = ^{\n    NSLog(@\"value = %d\", value);\n};\nvalue = 20;\nblock();\n\n// 打印结果是：\"value = 10\"\n```\n\nOC的block会截获外部变量，对于`int`等基本数据类型，block的内部会拷贝一份，简单来说，它的实现大概是这样的：\n\n```objc\nstruct block_impl {\n\t//其它内容\n\tint value;\n};\n```\n\n因为block内部拷贝了截获的变量的副本，所以生成block后再修改变量，不会影响被block截获的变量。同时block内部也不能修改这个变量。\n\n### 修改基本类型\n\n如果要想在block中修改被截获的基本类型变量，需要把它标记为`__block`：\n\n```objc\n__block int value = 10;\nvoid(^block)() = ^{\n    NSLog(@\"value = %d\", value);\n};\nvalue = 20;\nblock();\n\n// 打印结果是：\"value = 20\"\n```\n\n这是因为，对于被标记了`__block`的变量，block在截获它时，会保存一个指针。简单来说，它的实现大概是这样的：\n\n```objc\nstruct block_impl {\n\t//其它内容\n\tblock_ref_value *value;\n};\n\nstruct block_ref_value {\n\tint value; // 这里保存的才是被截获的value的值。\n};\n```\n\n由于block中一直有一个指针指向value，所以block内部对它的修改，可以影响到block外部的变量。因为block修改的就是那个外部变量而不是外部变量的副本。\n\n上面关于block具体实现的例子只是一个简化模型，事实上并非如此，但本质类似。总的来说，只有由`__block`修饰符修饰的基本类型变量，在被block截获时才是可变的。关于这方面的详细解释，可以参考这三篇文章：\n\n* [iOS OC语言: Block底层实现原理](http://www.jianshu.com/p/e23078c11518)：这个很详细地讲了`__block`的实现原理\n* [Block的引用循环问题 (ARC & non-ARC)](http://blog.csdn.net/wildfireli/article/details/22063001)：这个讲了一些block底层的实现原理以及循环引用问题。\n* [你真的理解__block修饰符的原理么？](http://blog.csdn.net/abc649395594/article/details/47086751)：这是我之前写过的一篇介绍`__block`原理的文章，内容会详细一些。\n\n### 截获指针\n\nblock截获指针和截获基本类型是相似的，不过稍稍复杂一些。这是一个最简单的例子。\n\n```objc\nPerson *p = [[Person alloc] initWithName:@\"zxy\"];    \nvoid(^block)() = ^{\n    NSLog(@\"person name = %@\", p.name);\n};\n    \np.name = @\"new name\";\nblock();\n\n// 打印结果是：\"person name = new name\"\n```\n\n在截获基本类型时，block内部可能会有`int capturedValue = value;`这样的代码，类比到指针也是一样的，block内部也会有这样的代码：`Person *capturedP = p;`。在ARC下，这其实是强引用(retain)了block外部的`p`。\n\n由于block内部的`p`和外部的`p`指向的是同一块内存地址。所以在block外部修改`p`的属性，依然会影响到block内部截获的`p`。不过这里的`p`依然不是可变的。修改`p`的`name`不是改变`p`，只是改变`p`内部的属性：\n\n```objc\nPerson *p = [[Person alloc] initWithName:@\"zxy\"];    \nvoid(^block)() = ^{\n\tp.name = @\"new name\"; //OK，没有改变p\n\tp = [[Person alloc] initWithName:@\"new name\"]; //编译错误\n    NSLog(@\"person name = %@\", p.name);\n};\n  \nblock();\n```\n\n### 改变指针\n\n类比`__block`修饰符对基本类型的作用原理，由它修饰的指针，在被block截获时，截获的其实是这个指针的指针。把刚刚的例子修改一下：\n\n```objc\n__block Person *p = [[Person alloc] initWithName:@\"zxy\"];    \nvoid(^block)() = ^{\n    NSLog(@\"person name = %@\", p.name);\n};\n    \np = nil;\nblock();\n\n// 打印结果是：\"person name = (null)\"\n```\n\n此时，block内部有一个指向外部的`p`的指针,一旦`p`被设为`nil`，这个内部的指针就指向了`nil`。所以打印结果就是`null`了。\n\n### __block与强引用\n\n还记得以前有一次面试时被问到，`__block`会不会`retain`变量？答案是：会的。从原理上分析，`__block`修饰的变量被封装在结构体中，block内部持有对这个结构体的强引用。这一点不管是对于基本类型还是指针都是通用的。从实际例子上来说：\n\n```objc\nBlock block;\nif (true) {\n    __block Person *p = [[Person alloc] initWithName:@\"zxy\"];\n    block = ^{\n        NSLog(@\"person name = %@\", p.name);\n    };\n}\nblock();\n\n// 打印结果是：\"person name = zxy\"\n```\n\n如果没有`retain`被标记为`__block`的指针`p`，那么超出作用于后应该会得到`nil`。不过这样的代码不会导致循环引用，因为稍后`block`也会被释放。\n\n### 避免循环引用\n\n不管对象是否标记为`__block`,一旦block截获了它，就会强引用它。所以，判断是否发生循环引用，只要判断block截获的对象，是否也持有block即可。如果这个对象确实需要直接或间接持有block，那么就需要避免block强引用这个对象。解决办法是使用`__weak`修饰符。\n\n```objc\n// block是self的一个属性\n\nid __weak weakSelf = self;\nblock = ^{\n\t//使用weakSelf代替self\n};\n```\n\nblock不会强引用被标记为`__weak`的对象，只会对其产生弱引用。为了防止在block内的操作会释放`wself`,可以先强引用它。这种做法有一个很漂亮的名字叫`weak-strong dacne`，具体实现方法可以参考RAC的`@strongify`和`@weakify`。\n\n### OC中block总结\n\n简单来说，除非标记为`__weak`，block总是会强引用任何捕获的对象。而`__block`表示捕获的就是指针本身,而非另一个指向这个对象的指针。也就是说，被`__block`修饰的对象在block内、外的改动会互相影响。\n\n如果想避免循环引用问题，首先要确定block引用了哪些对象，然后判断这些对象是否直接或间接持有block，如果有的话把这些对象标记为`__weak`避免block强引用它。\n\n# Swift的闭包\n               \nOC中的`__block`是一个很讨厌的修饰符。它不仅不容易理解，而且在ARC和非ARC的表现截然不同。`__block`修饰符本质上是通过截获变量的指针来达到在闭包内修改被截获的变量的目的。\n\n在Swift中，这叫做截获变量的引用。闭包默认会截取变量的引用，也就是说所有变量默认情况下都是加了`__block`修饰符的。\n\n```swift\nvar x = 42\nlet f = {\n\t// [x] in //如果取消注释，结果是42\n    print(x)\n}\nx = 43\nf() // 结果是43\n```\n\n如果如果被截获的变量是引用，和OC一样，那么在闭包内部有一个引用的引用：\n\n```swift\nvar block2: (() -> ())?\nif true {\n    var a: A? = A()\n    block2 = {\n        print(a?.name)\n    }\n    a = A(name: \"new name\")\n}\nblock2?() //结果是：\"Optional(\"new name\")\"\n```\n\n如果把变量写在截获列表中，那么block内部会有一个指向对象的强引用，这和在OC中什么都不写的效果是一样的：\n\n```swift\nvar block2: (() -> ())?\nif true {\n    var a: A? = A()\n    block2 = {\n        [a] in\n        print(a?.name)\n    }\n    a = A(name: \"new name\")\n}\nblock2?() //结果是：\"Optional(\"old name\")\"\n```\n               \nSwift会自动持有被截获的变量的引用，这样就可以在block内部直接修改变量。不过在一些特殊情况下，Swift会做一些优化。通过之前OC中对`__block`的分析可以看到，持有变量的引用肯定比直接持有变量开销更大。所以Swift会自动判断你是否在闭包中或闭包外改变了变量。如果没有改变，闭包会直接持有变量，即使你没有显式的把它卸载捕获列表中。下面这句话截取自[Swift官方文档](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94)：\n\n> As an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by or outside a closure.\n\n### Swift循环引用\n\n不管是否显示的把变量写进捕获列表，闭包都会对对象有强引用。如果闭包是某个对象的属性，而且闭包中截获了对象本身，或对象的某个属性，就会导致循环引用。这和OC中是完全一样的。解决方法是在捕获列表中把被截获的变量标记为`weak`或`unowned`。\n\n关于Swift的循环引用，有一个需要注意的例子：\n\n```swift\nclass A {\n    var name: String = \"A\"\n    var block: (() -> ())?\n    \n    //其他方法\n}\n\nvar a: A? = A()\nvar block = {\n    print(a?.name)\n}\na?.block = block\na = nil\nblock()\n```\n\n我们先创建了可选类型的变量`a`，然后创建一个闭包变量，并把它赋值给`a`的`block`属性。这个闭包内部又会截获`a`，那这样是否会导致循环引用呢？\n\n答案是否定的。虽然从表面上看，对象的闭包属性截获了对象本身。但是如果你运行上面这段代码，你会发现对象的`deinit`方法确实被调用了，打印结果不是“A”而是“nil”。\n\n这是因为我们忽略了可选类型这个因素。这里的`a`不是A类型的对象，而是一个可选类型变量，其内部封装了A的实例对象。闭包截获的是可选类型变量`a`，当你执行`a = nil`时，并不是释放了变量`a`，而是释放了`a`中包含的A类型实例对象。所以A的`deinit`方法会执行，当你调用block时，由于使用了可选链，就会得到`nil`，如果使用强制解封，程序就会崩溃。\n\n如果想要人为造成循环引用，代码要这样写：\n\n```swift\nvar block: (() -> ())?\nif true {\n    var a = A()\n    block = {\n        print(a.name)\n    }\n    a.name = \"New Name\"\n}\nblock!()\n```\n\n### Weak-Strong Dance\n\n为了避免`weak`变量在闭包中提前被释放，我们需要在block一开始强引用它。这在OC部分已经讲过如何使用了。Swift中实现Weak-Strong Dance一般有三种方法。分别是最简单的`if let`可选绑定、标准库的`withExtendedLifetime `方法和自定义的`withExtendedLifetime `方法。\n\n# 总结\n\n1. OC中默认截获变量，Swift默认截获变量的引用。它们都会强引用被截获的变量。\n2. Swift中没有`__block`修饰符，但是多了截获列表。通过把截获的变量标记为`weak`避免引用循环\n3. 两者都有Weak-Strong Dance，不过这一点上OC的写法更简单。\n4. 在使用可选类型时，要明确闭包截获了可选类型还是实例变量。这样才能正确判断是否发生循环引用。","html":"<h1 id=\"ocblock\">OC的block</h1>\n\n<p>OC的block已经有很多相关的文章介绍了，主要难点在于<code>__block</code>修饰符的作用和原理，以及循环引用问题。首先看一看<code>__block</code>修饰符，最后分析循环引用问题。这里的讨论都是基于ARC的。</p>\n\n<h3 id=\"\">截获基本类型</h3>\n\n<pre><code class=\"language-objc\">int value = 10;  \nvoid(^block)() = ^{  \n    NSLog(@\"value = %d\", value);\n};\nvalue = 20;  \nblock();\n\n// 打印结果是：\"value = 10\"\n</code></pre>\n\n<p>OC的block会截获外部变量，对于<code>int</code>等基本数据类型，block的内部会拷贝一份，简单来说，它的实现大概是这样的：</p>\n\n<pre><code class=\"language-objc\">struct block_impl {  \n    //其它内容\n    int value;\n};\n</code></pre>\n\n<p>因为block内部拷贝了截获的变量的副本，所以生成block后再修改变量，不会影响被block截获的变量。同时block内部也不能修改这个变量。</p>\n\n<h3 id=\"\">修改基本类型</h3>\n\n<p>如果要想在block中修改被截获的基本类型变量，需要把它标记为<code>__block</code>：</p>\n\n<pre><code class=\"language-objc\">__block int value = 10;  \nvoid(^block)() = ^{  \n    NSLog(@\"value = %d\", value);\n};\nvalue = 20;  \nblock();\n\n// 打印结果是：\"value = 20\"\n</code></pre>\n\n<p>这是因为，对于被标记了<code>__block</code>的变量，block在截获它时，会保存一个指针。简单来说，它的实现大概是这样的：</p>\n\n<pre><code class=\"language-objc\">struct block_impl {  \n    //其它内容\n    block_ref_value *value;\n};\n\nstruct block_ref_value {  \n    int value; // 这里保存的才是被截获的value的值。\n};\n</code></pre>\n\n<p>由于block中一直有一个指针指向value，所以block内部对它的修改，可以影响到block外部的变量。因为block修改的就是那个外部变量而不是外部变量的副本。</p>\n\n<p>上面关于block具体实现的例子只是一个简化模型，事实上并非如此，但本质类似。总的来说，只有由<code>__block</code>修饰符修饰的基本类型变量，在被block截获时才是可变的。关于这方面的详细解释，可以参考这三篇文章：</p>\n\n<ul>\n<li><a href=\"http://www.jianshu.com/p/e23078c11518\">iOS OC语言: Block底层实现原理</a>：这个很详细地讲了<code>__block</code>的实现原理</li>\n<li><a href=\"http://blog.csdn.net/wildfireli/article/details/22063001\">Block的引用循环问题 (ARC &amp; non-ARC)</a>：这个讲了一些block底层的实现原理以及循环引用问题。</li>\n<li><a href=\"http://blog.csdn.net/abc649395594/article/details/47086751\">你真的理解__block修饰符的原理么？</a>：这是我之前写过的一篇介绍<code>__block</code>原理的文章，内容会详细一些。</li>\n</ul>\n\n<h3 id=\"\">截获指针</h3>\n\n<p>block截获指针和截获基本类型是相似的，不过稍稍复杂一些。这是一个最简单的例子。</p>\n\n<pre><code class=\"language-objc\">Person *p = [[Person alloc] initWithName:@\"zxy\"];  \nvoid(^block)() = ^{  \n    NSLog(@\"person name = %@\", p.name);\n};\n\np.name = @\"new name\";  \nblock();\n\n// 打印结果是：\"person name = new name\"\n</code></pre>\n\n<p>在截获基本类型时，block内部可能会有<code>int capturedValue = value;</code>这样的代码，类比到指针也是一样的，block内部也会有这样的代码：<code>Person *capturedP = p;</code>。在ARC下，这其实是强引用(retain)了block外部的<code>p</code>。</p>\n\n<p>由于block内部的<code>p</code>和外部的<code>p</code>指向的是同一块内存地址。所以在block外部修改<code>p</code>的属性，依然会影响到block内部截获的<code>p</code>。不过这里的<code>p</code>依然不是可变的。修改<code>p</code>的<code>name</code>不是改变<code>p</code>，只是改变<code>p</code>内部的属性：</p>\n\n<pre><code class=\"language-objc\">Person *p = [[Person alloc] initWithName:@\"zxy\"];  \nvoid(^block)() = ^{  \n    p.name = @\"new name\"; //OK，没有改变p\n    p = [[Person alloc] initWithName:@\"new name\"]; //编译错误\n    NSLog(@\"person name = %@\", p.name);\n};\n\nblock();  \n</code></pre>\n\n<h3 id=\"\">改变指针</h3>\n\n<p>类比<code>__block</code>修饰符对基本类型的作用原理，由它修饰的指针，在被block截获时，截获的其实是这个指针的指针。把刚刚的例子修改一下：</p>\n\n<pre><code class=\"language-objc\">__block Person *p = [[Person alloc] initWithName:@\"zxy\"];  \nvoid(^block)() = ^{  \n    NSLog(@\"person name = %@\", p.name);\n};\n\np = nil;  \nblock();\n\n// 打印结果是：\"person name = (null)\"\n</code></pre>\n\n<p>此时，block内部有一个指向外部的<code>p</code>的指针,一旦<code>p</code>被设为<code>nil</code>，这个内部的指针就指向了<code>nil</code>。所以打印结果就是<code>null</code>了。</p>\n\n<h3 id=\"__block\">__block与强引用</h3>\n\n<p>还记得以前有一次面试时被问到，<code>__block</code>会不会<code>retain</code>变量？答案是：会的。从原理上分析，<code>__block</code>修饰的变量被封装在结构体中，block内部持有对这个结构体的强引用。这一点不管是对于基本类型还是指针都是通用的。从实际例子上来说：</p>\n\n<pre><code class=\"language-objc\">Block block;  \nif (true) {  \n    __block Person *p = [[Person alloc] initWithName:@\"zxy\"];\n    block = ^{\n        NSLog(@\"person name = %@\", p.name);\n    };\n}\nblock();\n\n// 打印结果是：\"person name = zxy\"\n</code></pre>\n\n<p>如果没有<code>retain</code>被标记为<code>__block</code>的指针<code>p</code>，那么超出作用于后应该会得到<code>nil</code>。不过这样的代码不会导致循环引用，因为稍后<code>block</code>也会被释放。</p>\n\n<h3 id=\"\">避免循环引用</h3>\n\n<p>不管对象是否标记为<code>__block</code>,一旦block截获了它，就会强引用它。所以，判断是否发生循环引用，只要判断block截获的对象，是否也持有block即可。如果这个对象确实需要直接或间接持有block，那么就需要避免block强引用这个对象。解决办法是使用<code>__weak</code>修饰符。</p>\n\n<pre><code class=\"language-objc\">// block是self的一个属性\n\nid __weak weakSelf = self;  \nblock = ^{  \n    //使用weakSelf代替self\n};\n</code></pre>\n\n<p>block不会强引用被标记为<code>__weak</code>的对象，只会对其产生弱引用。为了防止在block内的操作会释放<code>wself</code>,可以先强引用它。这种做法有一个很漂亮的名字叫<code>weak-strong dacne</code>，具体实现方法可以参考RAC的<code>@strongify</code>和<code>@weakify</code>。</p>\n\n<h3 id=\"ocblock\">OC中block总结</h3>\n\n<p>简单来说，除非标记为<code>__weak</code>，block总是会强引用任何捕获的对象。而<code>__block</code>表示捕获的就是指针本身,而非另一个指向这个对象的指针。也就是说，被<code>__block</code>修饰的对象在block内、外的改动会互相影响。</p>\n\n<p>如果想避免循环引用问题，首先要确定block引用了哪些对象，然后判断这些对象是否直接或间接持有block，如果有的话把这些对象标记为<code>__weak</code>避免block强引用它。</p>\n\n<h1 id=\"swift\">Swift的闭包</h1>\n\n<p>OC中的<code>__block</code>是一个很讨厌的修饰符。它不仅不容易理解，而且在ARC和非ARC的表现截然不同。<code>__block</code>修饰符本质上是通过截获变量的指针来达到在闭包内修改被截获的变量的目的。</p>\n\n<p>在Swift中，这叫做截获变量的引用。闭包默认会截取变量的引用，也就是说所有变量默认情况下都是加了<code>__block</code>修饰符的。</p>\n\n<pre><code class=\"language-swift\">var x = 42  \nlet f = {  \n    // [x] in //如果取消注释，结果是42\n    print(x)\n}\nx = 43  \nf() // 结果是43  \n</code></pre>\n\n<p>如果如果被截获的变量是引用，和OC一样，那么在闭包内部有一个引用的引用：</p>\n\n<pre><code class=\"language-swift\">var block2: (() -&gt; ())?  \nif true {  \n    var a: A? = A()\n    block2 = {\n        print(a?.name)\n    }\n    a = A(name: \"new name\")\n}\nblock2?() //结果是：\"Optional(\"new name\")\"  \n</code></pre>\n\n<p>如果把变量写在截获列表中，那么block内部会有一个指向对象的强引用，这和在OC中什么都不写的效果是一样的：</p>\n\n<pre><code class=\"language-swift\">var block2: (() -&gt; ())?  \nif true {  \n    var a: A? = A()\n    block2 = {\n        [a] in\n        print(a?.name)\n    }\n    a = A(name: \"new name\")\n}\nblock2?() //结果是：\"Optional(\"old name\")\"  \n</code></pre>\n\n<p>Swift会自动持有被截获的变量的引用，这样就可以在block内部直接修改变量。不过在一些特殊情况下，Swift会做一些优化。通过之前OC中对<code>__block</code>的分析可以看到，持有变量的引用肯定比直接持有变量开销更大。所以Swift会自动判断你是否在闭包中或闭包外改变了变量。如果没有改变，闭包会直接持有变量，即使你没有显式的把它卸载捕获列表中。下面这句话截取自<a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94\">Swift官方文档</a>：</p>\n\n<blockquote>\n  <p>As an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by or outside a closure.</p>\n</blockquote>\n\n<h3 id=\"swift\">Swift循环引用</h3>\n\n<p>不管是否显示的把变量写进捕获列表，闭包都会对对象有强引用。如果闭包是某个对象的属性，而且闭包中截获了对象本身，或对象的某个属性，就会导致循环引用。这和OC中是完全一样的。解决方法是在捕获列表中把被截获的变量标记为<code>weak</code>或<code>unowned</code>。</p>\n\n<p>关于Swift的循环引用，有一个需要注意的例子：</p>\n\n<pre><code class=\"language-swift\">class A {  \n    var name: String = \"A\"\n    var block: (() -&gt; ())?\n\n    //其他方法\n}\n\nvar a: A? = A()  \nvar block = {  \n    print(a?.name)\n}\na?.block = block  \na = nil  \nblock()  \n</code></pre>\n\n<p>我们先创建了可选类型的变量<code>a</code>，然后创建一个闭包变量，并把它赋值给<code>a</code>的<code>block</code>属性。这个闭包内部又会截获<code>a</code>，那这样是否会导致循环引用呢？</p>\n\n<p>答案是否定的。虽然从表面上看，对象的闭包属性截获了对象本身。但是如果你运行上面这段代码，你会发现对象的<code>deinit</code>方法确实被调用了，打印结果不是“A”而是“nil”。</p>\n\n<p>这是因为我们忽略了可选类型这个因素。这里的<code>a</code>不是A类型的对象，而是一个可选类型变量，其内部封装了A的实例对象。闭包截获的是可选类型变量<code>a</code>，当你执行<code>a = nil</code>时，并不是释放了变量<code>a</code>，而是释放了<code>a</code>中包含的A类型实例对象。所以A的<code>deinit</code>方法会执行，当你调用block时，由于使用了可选链，就会得到<code>nil</code>，如果使用强制解封，程序就会崩溃。</p>\n\n<p>如果想要人为造成循环引用，代码要这样写：</p>\n\n<pre><code class=\"language-swift\">var block: (() -&gt; ())?  \nif true {  \n    var a = A()\n    block = {\n        print(a.name)\n    }\n    a.name = \"New Name\"\n}\nblock!()  \n</code></pre>\n\n<h3 id=\"weakstrongdance\">Weak-Strong Dance</h3>\n\n<p>为了避免<code>weak</code>变量在闭包中提前被释放，我们需要在block一开始强引用它。这在OC部分已经讲过如何使用了。Swift中实现Weak-Strong Dance一般有三种方法。分别是最简单的<code>if let</code>可选绑定、标准库的<code>withExtendedLifetime</code>方法和自定义的<code>withExtendedLifetime</code>方法。</p>\n\n<h1 id=\"\">总结</h1>\n\n<ol>\n<li>OC中默认截获变量，Swift默认截获变量的引用。它们都会强引用被截获的变量。  </li>\n<li>Swift中没有<code>__block</code>修饰符，但是多了截获列表。通过把截获的变量标记为<code>weak</code>避免引用循环  </li>\n<li>两者都有Weak-Strong Dance，不过这一点上OC的写法更简单。  </li>\n<li>在使用可选类型时，要明确闭包截获了可选类型还是实例变量。这样才能正确判断是否发生循环引用。</li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:18:06.000Z","created_by":1,"updated_at":"2016-01-14T08:19:09.000Z","updated_by":1,"published_at":"2015-12-26T08:18:00.000Z","published_by":1},{"id":13,"uuid":"df7854f6-a907-4354-80b8-bdcbec9453e3","title":"我的2015年总结","slug":"wo-de-2015nian-zong-jie","markdown":"我一直认为，对于程序员来说，写一天代码不算什么，也许这只是解决了一个bug，或者干脆就没能搞定。一周的时间学习内容页有限，可能是一两个困扰已久的知识点终于悟透了，也可能是新学了某个知识点。但是和一个月前的自己相比，总是感觉自己进步颇大，和一年前的自己相比，就有一种判若两人的感觉了。2015就要过去了，我想有必要总结一下这一年来的收获得失。\n\n# 从小白开始\n\n从去年年底正式开始写iOS开始，到大约三四月份，一直在开发自己的第一个iOS应用，现在回顾那段时间的博客，主要是关于UI方面的总结，以及一些常见错误的解决方法。在这个过程中了解了怎么处理HTTP请求和Json解析(没错，当时还不知道HTTP请求是什么)，图片的异步加载与缓存，`UIScrollview`和`UITableView`这些稍微“高端”一些的UI控件。也开始接触了定时器、内存管理等知识。APP上架以后我就天真的以为自己已经把iOS学得差不多了。\n\n# 第一次失败\n\n五月份的时候做过两个小的项目，一个APP上架(广告赚了将近200)，一个Xcode插件在Github，然后兴冲冲的去面了一家公司。待遇是12K+包吃住，虽然也没觉得自己达到这个水平，不过真正到了第二轮被拒的时候还是有一些小伤感。面试虽然没过，却还是有些收获：\n\n1. 逐渐开始过渡到用Google查资料，平时关注Objc.io并RSS订阅各个大牛的技术博客，偶尔在StackOverflow提个问题。总的来说就是层次提高了，获取知识的来源拓宽了。这一点至今让我受益匪浅。\n\n2. 关于UI方面的一些细节，以前做项目，只想着效果OK就可以，面试官问我怎么处理图片的拉伸问题我就一问三不知。还有一些比较底层的知识，比如`CoreGraphis`、`CoreAnimation`等也是之前欠缺的。\n\n3. 以前只会嘴上喊MVC模式，实际代码中VC负责一切。被面试官一下子问个正着。现在严格遵循MVC模式，而且学习了MVVM模式，写了几篇分析ReactiveCocoa源码的文章：[ReactiveCocoa详解](http://blog.csdn.net/column/details/reactivecocoa.html)。可惜对函数式编程的思想还是不够熟练，在项目中用了一两次之后就暂时搁置了，听说美团在用RAC。\n\n# 第二次失败\n\n面试结束后，把面试过程中遇到的问题总结了一下，又投了一份简历。可能是运气不错，我准备的问题被问到了好几个，也有可能是那个创业公司比较缺人，所以成功的拿到了Offer。当时谈了400一天，后来因为晚上加班，最后实际给了440一天（大二就月入过万了，当时还是有点小骄傲）。六月份开始入职，但是问题来的比工资快。现在想来主要是这几点：\n\n1. 不适应身份的转变。企业是企业，学校是学校，在学校的团队里，自己是技术leader同时还身兼产品经理。自己定好需求再实现。但是在公司里，产品经理的需求一日三变，写完的代码leader看技术实现，产品经理看效果，美工检查UI布局。由于以前基础太不扎实，态度也比较敷衍，所以这么一来漏洞百出，顾此失彼。\n\n2. 心态不够好。刚开始干劲十足，但总是被PM改需求，被leader批评。后来慢慢的也有些失望，甚至是抵触。其中的过程比较复杂，至今也不太能理清楚，\n\n总的来说，第二次失败的原因有两个。一是自己技术水平不够，这里有代码规范问题也有iOS开发上的问题，二是太以自我为中心，如果当时能多站在公司的角度考虑问题，也许情况就不是那样。后来和公司的关系越来越僵，最后九月初选择了提前离职，回到学校继续钻研技术。\n\n回到学校之后的整整两个月都没有看技术。半主动离职让我开始怀疑自己，虽然对公司的领导、氛围小有愤懑，但毕竟自己的问题更加严重。于是选择了逃避，每天玩游戏、看电影，甚至去大连旅游了一趟。回家呆了一段时间，再回学校已经是11月，感觉逃避也不是办法，只是还是要一点点学。\n\n# 读书\n\n15年读了不少好书，收益颇丰。实习期间看完了《Effective Objective-C 2.0》和《Objective-C高级编程》，对不少基础知识，比如ARC、block和GCD都有了更加深入的了解。\n\n实习的时候还看了一本《老码说编程之玩转Swift江湖》，当时Swift还是1.x版本。从这一点来说，我是个不合格的实习生。实习期间路上、晚上都在看书，导致白天精力不济。因为当时的思想还是利用实习期间多学技术，但创业公司要求的其实是实习生为他创造效益。\n\n11月读了《程序员的自我修养》，对程序的运行和操作系统有了更透彻的理解。读完之后写了一篇[读后感](http://bestswifter.com/blog/2015/12/22/cheng-xu-yuan-de-zi-wo-xiu-yang-du-shu-bi-ji/)。12月的Swift 2开源，感觉Swift是大势所趋，所以开始学习objc出版的\"Advanced Swift\"，同时自己也写了它的[中文翻译版](http://www.jianshu.com/p/18744b078508)，后来有人提醒我版权问题，所以已经暂停原文翻译了，后面的几篇文章都是对原文进行加工和总结后得出的。\n\n阅读和翻译英文书的收获非常大，对很多的知识的理解比直接阅读中文教程要深刻的多，同时也大幅度提高了自己阅读英文教程的能力。\n\n# 收获\n\n最大的收获，莫过于Swift的学习了，了解基本语法的同时，有机会也会自己看一下已经开源的部分的实现原理。\n\n磨刀不误砍柴工，我减少了很多写项目的时间，希望把基础知识弄扎实，因为很多bug往往来自于对某个概念的错误理解。与其一知半解的去解决bug，不如先掌握知识。所以在读书的同时，我也开始深入的思考iOS开发的一些基础知识：\n\n* AutoLayout和UIScrollview的联合使用\n* UIScrollview性能优化\n* GCD和NSOperationQueue\n* UIView的生命周期\n* Swift与OC在复制对象时的异同\n* Swift与OC闭包的异同\n\n感谢Google上的各种资料，我完成了自己的[Xcode插件](https://github.com/649395594/XcodeCareer-Plugin)，用来统计在Xcode中所有写过的代码行数和写代码时间，不过好像有隐藏的bug，后来也就不维护了。因为看过《程序员的自我修养》，对一些底层的知识有了浅显的了解，所以在Google的帮助下，自己破解了一款收费应用：[一个数字的魔法——破解Mac软件之旅](http://bestswifter.com/blog/2015/11/24/%5B%3F%5D-ge-shu-zi-de-mo-fa-po-jie-macruan-jian-zhi-lu/)\n\n仔细想想，其他乱七八糟的东西也学了不少，实习期间相当长的时间在做C++项目，写了一个静态库分别给OC和Java调用，所以也稍微了解了一下C++。发现了CSDN博客的一个bug，又去了解了一下Python，写了一个脚本把自己积分刷到了第一。学校有安卓的课，所以不得不写了个[安卓应用](https://github.com/649395594/MathModeling-Android)，也算是了解了一些简单的Java和安卓开发。年底的时候注册了现在用的这个域名，虽然注定要被打脸，但也希望能够鞭策自己吧。\n\n# 2016年的计划\n\n1. 文章要继续阅读和翻译英文书籍。目前Advanced Swift翻译了三分之二，一月份估计可以结束。下一个目标或许还是Objc的书：Core Data。事实上总是有读不完的好书的。\n\n2. 阅读优秀的博文。实际上今年2015年的很多时间浪费在一些低质量的文章上，不仅学不到知识，还把自己弄得晕头转向。NSHispter和Objc.io有非常多优秀的文章，足够在2016年好好拜读了。\n\n3. 技术与基础。有些知识点还没来得及学习，有些学过但是长期不用已经忘了，目前想到的涉及这几点：响应者链与事件处理、KVO、几种消息传递机制的比较、Runtime、NSUrlSession、CALayer等等等等。虽然要学的太多，不过一直很喜欢一句话：“怕什么真理无穷,进一寸有一寸的欢喜”。\n\n4. 大学期间就该做大学里该做的事，比如读书。目前想到的是《代码整洁之道》、《图解TCP/IP协议》，如果有空希望可以深入了解Mac与iOS操作系统。\n\n5. 实习。目前对创业公司有了一定了解，希望能够到一家大公司实习几个月。\n\n虽然任务浩繁，不过总得尽力完成，愿一年后的自己与现在判若两人！","html":"<p>我一直认为，对于程序员来说，写一天代码不算什么，也许这只是解决了一个bug，或者干脆就没能搞定。一周的时间学习内容页有限，可能是一两个困扰已久的知识点终于悟透了，也可能是新学了某个知识点。但是和一个月前的自己相比，总是感觉自己进步颇大，和一年前的自己相比，就有一种判若两人的感觉了。2015就要过去了，我想有必要总结一下这一年来的收获得失。</p>\n\n<h1 id=\"\">从小白开始</h1>\n\n<p>从去年年底正式开始写iOS开始，到大约三四月份，一直在开发自己的第一个iOS应用，现在回顾那段时间的博客，主要是关于UI方面的总结，以及一些常见错误的解决方法。在这个过程中了解了怎么处理HTTP请求和Json解析(没错，当时还不知道HTTP请求是什么)，图片的异步加载与缓存，<code>UIScrollview</code>和<code>UITableView</code>这些稍微“高端”一些的UI控件。也开始接触了定时器、内存管理等知识。APP上架以后我就天真的以为自己已经把iOS学得差不多了。</p>\n\n<h1 id=\"\">第一次失败</h1>\n\n<p>五月份的时候做过两个小的项目，一个APP上架(广告赚了将近200)，一个Xcode插件在Github，然后兴冲冲的去面了一家公司。待遇是12K+包吃住，虽然也没觉得自己达到这个水平，不过真正到了第二轮被拒的时候还是有一些小伤感。面试虽然没过，却还是有些收获：</p>\n\n<ol>\n<li><p>逐渐开始过渡到用Google查资料，平时关注Objc.io并RSS订阅各个大牛的技术博客，偶尔在StackOverflow提个问题。总的来说就是层次提高了，获取知识的来源拓宽了。这一点至今让我受益匪浅。</p></li>\n<li><p>关于UI方面的一些细节，以前做项目，只想着效果OK就可以，面试官问我怎么处理图片的拉伸问题我就一问三不知。还有一些比较底层的知识，比如<code>CoreGraphis</code>、<code>CoreAnimation</code>等也是之前欠缺的。</p></li>\n<li><p>以前只会嘴上喊MVC模式，实际代码中VC负责一切。被面试官一下子问个正着。现在严格遵循MVC模式，而且学习了MVVM模式，写了几篇分析ReactiveCocoa源码的文章：<a href=\"http://blog.csdn.net/column/details/reactivecocoa.html\">ReactiveCocoa详解</a>。可惜对函数式编程的思想还是不够熟练，在项目中用了一两次之后就暂时搁置了，听说美团在用RAC。</p></li>\n</ol>\n\n<h1 id=\"\">第二次失败</h1>\n\n<p>面试结束后，把面试过程中遇到的问题总结了一下，又投了一份简历。可能是运气不错，我准备的问题被问到了好几个，也有可能是那个创业公司比较缺人，所以成功的拿到了Offer。当时谈了400一天，后来因为晚上加班，最后实际给了440一天（大二就月入过万了，当时还是有点小骄傲）。六月份开始入职，但是问题来的比工资快。现在想来主要是这几点：</p>\n\n<ol>\n<li><p>不适应身份的转变。企业是企业，学校是学校，在学校的团队里，自己是技术leader同时还身兼产品经理。自己定好需求再实现。但是在公司里，产品经理的需求一日三变，写完的代码leader看技术实现，产品经理看效果，美工检查UI布局。由于以前基础太不扎实，态度也比较敷衍，所以这么一来漏洞百出，顾此失彼。</p></li>\n<li><p>心态不够好。刚开始干劲十足，但总是被PM改需求，被leader批评。后来慢慢的也有些失望，甚至是抵触。其中的过程比较复杂，至今也不太能理清楚，</p></li>\n</ol>\n\n<p>总的来说，第二次失败的原因有两个。一是自己技术水平不够，这里有代码规范问题也有iOS开发上的问题，二是太以自我为中心，如果当时能多站在公司的角度考虑问题，也许情况就不是那样。后来和公司的关系越来越僵，最后九月初选择了提前离职，回到学校继续钻研技术。</p>\n\n<p>回到学校之后的整整两个月都没有看技术。半主动离职让我开始怀疑自己，虽然对公司的领导、氛围小有愤懑，但毕竟自己的问题更加严重。于是选择了逃避，每天玩游戏、看电影，甚至去大连旅游了一趟。回家呆了一段时间，再回学校已经是11月，感觉逃避也不是办法，只是还是要一点点学。</p>\n\n<h1 id=\"\">读书</h1>\n\n<p>15年读了不少好书，收益颇丰。实习期间看完了《Effective Objective-C 2.0》和《Objective-C高级编程》，对不少基础知识，比如ARC、block和GCD都有了更加深入的了解。</p>\n\n<p>实习的时候还看了一本《老码说编程之玩转Swift江湖》，当时Swift还是1.x版本。从这一点来说，我是个不合格的实习生。实习期间路上、晚上都在看书，导致白天精力不济。因为当时的思想还是利用实习期间多学技术，但创业公司要求的其实是实习生为他创造效益。</p>\n\n<p>11月读了《程序员的自我修养》，对程序的运行和操作系统有了更透彻的理解。读完之后写了一篇<a href=\"http://bestswifter.com/blog/2015/12/22/cheng-xu-yuan-de-zi-wo-xiu-yang-du-shu-bi-ji/\">读后感</a>。12月的Swift 2开源，感觉Swift是大势所趋，所以开始学习objc出版的\"Advanced Swift\"，同时自己也写了它的<a href=\"http://www.jianshu.com/p/18744b078508\">中文翻译版</a>，后来有人提醒我版权问题，所以已经暂停原文翻译了，后面的几篇文章都是对原文进行加工和总结后得出的。</p>\n\n<p>阅读和翻译英文书的收获非常大，对很多的知识的理解比直接阅读中文教程要深刻的多，同时也大幅度提高了自己阅读英文教程的能力。</p>\n\n<h1 id=\"\">收获</h1>\n\n<p>最大的收获，莫过于Swift的学习了，了解基本语法的同时，有机会也会自己看一下已经开源的部分的实现原理。</p>\n\n<p>磨刀不误砍柴工，我减少了很多写项目的时间，希望把基础知识弄扎实，因为很多bug往往来自于对某个概念的错误理解。与其一知半解的去解决bug，不如先掌握知识。所以在读书的同时，我也开始深入的思考iOS开发的一些基础知识：</p>\n\n<ul>\n<li>AutoLayout和UIScrollview的联合使用</li>\n<li>UIScrollview性能优化</li>\n<li>GCD和NSOperationQueue</li>\n<li>UIView的生命周期</li>\n<li>Swift与OC在复制对象时的异同</li>\n<li>Swift与OC闭包的异同</li>\n</ul>\n\n<p>感谢Google上的各种资料，我完成了自己的<a href=\"https://github.com/649395594/XcodeCareer-Plugin\">Xcode插件</a>，用来统计在Xcode中所有写过的代码行数和写代码时间，不过好像有隐藏的bug，后来也就不维护了。因为看过《程序员的自我修养》，对一些底层的知识有了浅显的了解，所以在Google的帮助下，自己破解了一款收费应用：<a href=\"http://bestswifter.com/blog/2015/11/24/%5B%3F%5D-ge-shu-zi-de-mo-fa-po-jie-macruan-jian-zhi-lu/\">一个数字的魔法——破解Mac软件之旅</a></p>\n\n<p>仔细想想，其他乱七八糟的东西也学了不少，实习期间相当长的时间在做C++项目，写了一个静态库分别给OC和Java调用，所以也稍微了解了一下C++。发现了CSDN博客的一个bug，又去了解了一下Python，写了一个脚本把自己积分刷到了第一。学校有安卓的课，所以不得不写了个<a href=\"https://github.com/649395594/MathModeling-Android\">安卓应用</a>，也算是了解了一些简单的Java和安卓开发。年底的时候注册了现在用的这个域名，虽然注定要被打脸，但也希望能够鞭策自己吧。</p>\n\n<h1 id=\"2016\">2016年的计划</h1>\n\n<ol>\n<li><p>文章要继续阅读和翻译英文书籍。目前Advanced Swift翻译了三分之二，一月份估计可以结束。下一个目标或许还是Objc的书：Core Data。事实上总是有读不完的好书的。</p></li>\n<li><p>阅读优秀的博文。实际上今年2015年的很多时间浪费在一些低质量的文章上，不仅学不到知识，还把自己弄得晕头转向。NSHispter和Objc.io有非常多优秀的文章，足够在2016年好好拜读了。</p></li>\n<li><p>技术与基础。有些知识点还没来得及学习，有些学过但是长期不用已经忘了，目前想到的涉及这几点：响应者链与事件处理、KVO、几种消息传递机制的比较、Runtime、NSUrlSession、CALayer等等等等。虽然要学的太多，不过一直很喜欢一句话：“怕什么真理无穷,进一寸有一寸的欢喜”。</p></li>\n<li><p>大学期间就该做大学里该做的事，比如读书。目前想到的是《代码整洁之道》、《图解TCP/IP协议》，如果有空希望可以深入了解Mac与iOS操作系统。</p></li>\n<li><p>实习。目前对创业公司有了一定了解，希望能够到一家大公司实习几个月。</p></li>\n</ol>\n\n<p>虽然任务浩繁，不过总得尽力完成，愿一年后的自己与现在判若两人！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2016-01-14T08:19:27.000Z","created_by":1,"updated_at":"2016-01-14T08:20:16.000Z","updated_by":1,"published_at":"2015-12-31T08:19:00.000Z","published_by":1}],"posts_tags":[{"id":2,"post_id":2,"tag_id":2,"sort_order":0},{"id":3,"post_id":3,"tag_id":3,"sort_order":0},{"id":4,"post_id":3,"tag_id":4,"sort_order":1},{"id":5,"post_id":4,"tag_id":5,"sort_order":0},{"id":6,"post_id":5,"tag_id":6,"sort_order":0},{"id":7,"post_id":5,"tag_id":7,"sort_order":1},{"id":8,"post_id":5,"tag_id":8,"sort_order":2},{"id":9,"post_id":7,"tag_id":9,"sort_order":0},{"id":10,"post_id":7,"tag_id":10,"sort_order":1},{"id":11,"post_id":7,"tag_id":11,"sort_order":2},{"id":12,"post_id":6,"tag_id":9,"sort_order":0},{"id":13,"post_id":6,"tag_id":10,"sort_order":1},{"id":14,"post_id":6,"tag_id":11,"sort_order":2},{"id":15,"post_id":8,"tag_id":9,"sort_order":0},{"id":16,"post_id":9,"tag_id":3,"sort_order":0},{"id":17,"post_id":9,"tag_id":12,"sort_order":1},{"id":18,"post_id":10,"tag_id":13,"sort_order":0},{"id":19,"post_id":10,"tag_id":2,"sort_order":1},{"id":20,"post_id":11,"tag_id":9,"sort_order":0},{"id":21,"post_id":11,"tag_id":14,"sort_order":1},{"id":22,"post_id":11,"tag_id":15,"sort_order":2},{"id":23,"post_id":12,"tag_id":14,"sort_order":0},{"id":24,"post_id":12,"tag_id":9,"sort_order":1},{"id":25,"post_id":13,"tag_id":16,"sort_order":0}],"roles":[{"id":1,"uuid":"9d69a637-ac1f-4338-ba1d-1cf3c292681f","name":"Administrator","description":"管理员","created_at":"2016-01-11T13:11:46.000Z","created_by":1,"updated_at":"2016-01-11T13:11:46.000Z","updated_by":1},{"id":2,"uuid":"2986361a-6621-48cd-8fd6-c87472f144b7","name":"Editor","description":"编辑","created_at":"2016-01-11T13:11:46.000Z","created_by":1,"updated_at":"2016-01-11T13:11:46.000Z","updated_by":1},{"id":3,"uuid":"8cfc6b70-6ad5-4386-b036-ea0eb9dc2a35","name":"Author","description":"作者","created_at":"2016-01-11T13:11:46.000Z","created_by":1,"updated_at":"2016-01-11T13:11:46.000Z","updated_by":1},{"id":4,"uuid":"f9da9a04-55f0-48b8-94f2-69e677654ef8","name":"Owner","description":"博客所有者","created_at":"2016-01-11T13:11:46.000Z","created_by":1,"updated_at":"2016-01-11T13:11:46.000Z","updated_by":1}],"roles_users":[{"id":1,"role_id":4,"user_id":1}],"settings":[{"id":1,"uuid":"77a95eaa-c73f-4130-b778-0310bdaa3741","key":"databaseVersion","value":"004","type":"core","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T13:11:48.000Z","updated_by":1},{"id":2,"uuid":"8a239d97-b6cb-4d6b-8c65-8c5f7b0f7dda","key":"dbHash","value":"e6007452-5c61-4a78-b237-66dcc8f88a8d","type":"core","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T13:11:48.000Z","updated_by":1},{"id":3,"uuid":"14cbf063-0af8-42ca-b446-cee130053cd0","key":"nextUpdateCheck","value":"1452842135","type":"core","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-14T07:15:35.000Z","updated_by":1},{"id":4,"uuid":"a250de0f-aea1-4499-9add-90379ef96728","key":"displayUpdateNotification","value":"0.7.0","type":"core","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-14T07:15:35.000Z","updated_by":1},{"id":5,"uuid":"bf76d7cb-f128-4976-8926-709e18adc0ad","key":"title","value":"kt's Dev","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":6,"uuid":"815cdb56-8d22-4f4f-b838-13fc9086670c","key":"description","value":"欢迎来到Kt的iOS开发小站，我是张星宇(@KtZhang)，目前在读大三，热爱iOS开发。","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":7,"uuid":"c6502fb4-3871-4c31-a341-6dd09f77fe93","key":"logo","value":"/content/images/2016/01/avator.jpg","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":8,"uuid":"2301d509-d56a-461f-b5ea-224935a47410","key":"cover","value":"/content/images/2016/01/background.jpg","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":9,"uuid":"a6654a11-d191-462f-aabc-81c395033240","key":"defaultLang","value":"zh_CN","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":10,"uuid":"5c161af8-f6f5-4fd7-9d32-231bef54773f","key":"postsPerPage","value":"5","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":11,"uuid":"e3ce8226-ea96-4bf2-9496-a02dbb339ee1","key":"forceI18n","value":"true","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":12,"uuid":"a47c3754-72bc-4d52-ab15-c056f0880667","key":"permalinks","value":"/:slug/","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":13,"uuid":"b0e2509d-3b7f-48b5-84f2-3d490f3677d9","key":"ghost_head","value":"","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":14,"uuid":"ca7889d3-5809-49cc-957d-2b6d57c5d790","key":"ghost_foot","value":"","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":15,"uuid":"48835feb-a53f-4285-bbb4-902db49883ff","key":"labs","value":"{}","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":16,"uuid":"ade3cf3c-fee3-453d-9ce3-d78c981bb18f","key":"navigation","value":"[{\"label\":\"首页\", \"url\":\"/\"}]","type":"blog","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":17,"uuid":"3f812b37-8e8a-43f2-80e1-acbf8355e02f","key":"activeApps","value":"[]","type":"app","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T13:11:48.000Z","updated_by":1},{"id":18,"uuid":"97f9a055-2bbf-4c9e-aea5-39e3dac1631e","key":"installedApps","value":"[]","type":"app","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-13T03:05:06.000Z","updated_by":1},{"id":19,"uuid":"d6a30726-ecb7-41f7-8304-9cecc634cc2e","key":"isPrivate","value":"false","type":"private","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":20,"uuid":"c873facc-cdda-4406-a54f-0d618baf1e82","key":"password","value":"","type":"private","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1},{"id":21,"uuid":"bdd195a1-4a2e-44c9-aad2-a1a60bea1a17","key":"activeTheme","value":"vno","type":"theme","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T14:22:45.000Z","updated_by":1}],"tags":[{"id":5,"uuid":"0b25e63d-70c7-41ef-b0c5-1d48a2734dc0","name":"算法","slug":"suan-fa","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-11T15:09:47.000Z","created_by":1,"updated_at":"2016-01-11T15:09:47.000Z","updated_by":1},{"id":2,"uuid":"701c482c-15c7-4656-9c0f-ad0c55699b75","name":"基础知识","slug":"ji-chu-zhi-shi","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-11T13:39:34.000Z","created_by":1,"updated_at":"2016-01-11T13:39:34.000Z","updated_by":1},{"id":3,"uuid":"e3e59c47-2764-4832-ad85-aeec5af87808","name":"iOS","slug":"ios","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-11T13:48:17.000Z","created_by":1,"updated_at":"2016-01-11T13:48:17.000Z","updated_by":1},{"id":4,"uuid":"37a48c42-a716-4bcd-a157-f8fe9f85f518","name":"UI","slug":"ui","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-11T13:48:17.000Z","created_by":1,"updated_at":"2016-01-11T13:48:17.000Z","updated_by":1},{"id":6,"uuid":"ea71ba68-1217-43ef-99de-d4161fa87414","name":"GCD","slug":"gcd","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T07:58:20.000Z","created_by":1,"updated_at":"2016-01-14T07:58:20.000Z","updated_by":1},{"id":7,"uuid":"389aa2ce-9a97-4614-b4dc-72c77ed1def8","name":"NSOperation","slug":"nsoperation","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T07:58:20.000Z","created_by":1,"updated_at":"2016-01-14T07:58:20.000Z","updated_by":1},{"id":8,"uuid":"37e5d0d8-bc29-4514-9af3-304c69f58d41","name":"多线程","slug":"duo-xian-cheng","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T07:58:20.000Z","created_by":1,"updated_at":"2016-01-14T07:58:20.000Z","updated_by":1},{"id":9,"uuid":"fab2b53b-dc77-436b-bd45-784f96d073d7","name":"Swift","slug":"swift","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:05:35.000Z","created_by":1,"updated_at":"2016-01-14T08:05:35.000Z","updated_by":1},{"id":10,"uuid":"1bf98384-bd51-46b7-bc76-2eab1dfdced4","name":"Array","slug":"array","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:05:35.000Z","created_by":1,"updated_at":"2016-01-14T08:05:35.000Z","updated_by":1},{"id":11,"uuid":"f947f221-cfff-4e71-80c4-144dcd68ec58","name":"源码","slug":"yuan-ma","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:05:35.000Z","created_by":1,"updated_at":"2016-01-14T08:05:35.000Z","updated_by":1},{"id":12,"uuid":"1dae2c6f-9d56-4138-a8f0-ee689eafae3a","name":"Autolayout","slug":"autolayout","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:11:20.000Z","created_by":1,"updated_at":"2016-01-14T08:11:20.000Z","updated_by":1},{"id":13,"uuid":"ada537a4-3529-461f-becb-201a6ca20f40","name":"读书","slug":"du-shu","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:13:23.000Z","created_by":1,"updated_at":"2016-01-14T08:13:23.000Z","updated_by":1},{"id":14,"uuid":"67162769-aeb9-4661-90c1-4e6a5aaab759","name":"Objective-C","slug":"objective-c","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:17:19.000Z","created_by":1,"updated_at":"2016-01-14T08:17:19.000Z","updated_by":1},{"id":15,"uuid":"a7bfc143-972b-470c-b118-64baa4ab75e5","name":"Foundation","slug":"foundation","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:17:19.000Z","created_by":1,"updated_at":"2016-01-14T08:17:19.000Z","updated_by":1},{"id":16,"uuid":"142ea3f4-6d4a-4bba-82dd-166fce2f6525","name":"总结","slug":"zong-jie","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2016-01-14T08:20:16.000Z","created_by":1,"updated_at":"2016-01-14T08:20:16.000Z","updated_by":1}],"users":[{"id":1,"uuid":"dd6c4295-3190-434c-9c55-76b6388a923c","name":"张星宇","slug":"zhang","password":"$2a$10$L4nMNQU4yqljOtjhWYKK/e35x/8.SnzeTHFlP8FPB2Mmvw3QgKyh6","email":"649395594@qq.com","image":null,"cover":null,"bio":null,"website":null,"location":null,"accessibility":null,"status":"active","language":"zh_CN","meta_title":null,"meta_description":null,"tour":null,"last_login":"2016-01-11T13:12:55.000Z","created_at":"2016-01-11T13:11:48.000Z","created_by":1,"updated_at":"2016-01-11T13:12:55.000Z","updated_by":1}]}}]}